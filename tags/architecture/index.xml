<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architecture on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/architecture/</link><description>Recent content in Architecture on 識之箱庭</description><generator>Hugo</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Mon, 30 Jun 2025 10:00:00 +0800</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Software Design - Architecture - Unity Slot Game Client</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---unity-slot-game-client/</link><pubDate>Mon, 30 Jun 2025 10:00:00 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---unity-slot-game-client/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;前端開發時，「狀態管理」一直是個大哉問。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;本次的應用是 &lt;strong&gt;Slot Game&lt;/strong&gt;，這類應用強調「表現層細節」，所以對於狀態的控制不像一般資料應用一樣單純，需要處理許多細部和即時的變化。&lt;/p&gt;
&lt;h3 id="狀態管理挑戰"&gt;狀態管理挑戰&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;響應式 data-binding 限制 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若完全依賴響應式 data-binding，容易產生太多「中間態」(例如動畫進行中、結果待顯示、部分組件已經觸發&amp;hellip;等)。&lt;/li&gt;
&lt;li&gt;這樣會造成 state 爆炸、難以追蹤維護。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令式流程控制的必要性 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部分場景下，直接用命令式（imperative）流程更有效率。&lt;/li&gt;
&lt;li&gt;多組件聯動時的「動畫序列控制」。&lt;/li&gt;
&lt;li&gt;一連串的 user action/遊戲事件，需明確依序觸發。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-技術棧一覽"&gt;⚙️ 技術棧一覽&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UniTask (異步)&lt;/li&gt;
&lt;li&gt;R3 (Rx，UniRx 後繼者)&lt;/li&gt;
&lt;li&gt;VContainer (依賴注入)&lt;/li&gt;
&lt;li&gt;LitMotion (Tween)&lt;/li&gt;
&lt;li&gt;YooAsset (資源管理)&lt;/li&gt;
&lt;li&gt;Newtonsoft Json (Json 解析)&lt;/li&gt;
&lt;li&gt;Alchemy (編輯器擴充)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="專案結構"&gt;專案結構&lt;/h2&gt;
&lt;h3 id="modules-主架構"&gt;Modules 主架構&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;project-root/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── _Debug/ &lt;span style="color:#75715e"&gt;# 測試或實驗用模組&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── App/ &lt;span style="color:#75715e"&gt;# 啟動點與業務邏輯總控&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── GameAPI/ &lt;span style="color:#75715e"&gt;# 遊戲 API 定義&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── GameRunner/ &lt;span style="color:#75715e"&gt;# 遊戲平台通用組件 (純 UIComponent)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── GameStage/ &lt;span style="color:#75715e"&gt;# 遊戲表演組件 (純 UIComponent)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── Shared/ &lt;span style="color:#75715e"&gt;# 共用模組&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;App：負責組合、調度各個模組，等於是專案的大腦。&lt;/li&gt;
&lt;li&gt;GameAPI：只放介面定義，跨模組通訊與擴充。&lt;/li&gt;
&lt;li&gt;GameRunner / GameStage：都是純 UIComponent (基本都是 Mono)。&lt;/li&gt;
&lt;li&gt;Shared：共用邏輯、工具類、資料結構都放這裡。&lt;/li&gt;
&lt;li&gt;_Debug：僅用於測試、debug，正式版本不打包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="module-模組以單一模組為例"&gt;Module 模組（以單一模組為例）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;module-root/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Res/ &lt;span style="color:#75715e"&gt;# 模組獨立資源&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── Scripts/ &lt;span style="color:#75715e"&gt;# 腳本程式碼&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ├── Editor/ &lt;span style="color:#75715e"&gt;# 編輯器相關&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; └── Runtime/ &lt;span style="color:#75715e"&gt;# 執行時相關&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Res：模組內專屬資源包。&lt;/li&gt;
&lt;li&gt;Scripts/Editor：編輯器工具。&lt;/li&gt;
&lt;li&gt;Scripts/Runtime：模組實際邏輯，遊戲執行時會用到的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="app-runtime運行時架構"&gt;App-Runtime（運行時架構）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;App-Runtime-root/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Configs/ &lt;span style="color:#75715e"&gt;# 配置與定義&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Services/ &lt;span style="color:#75715e"&gt;# 封裝各種業務操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Presenters/ &lt;span style="color:#75715e"&gt;# 控制流程、狀態綁定&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── Stores/ &lt;span style="color:#75715e"&gt;# 狀態管理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Configs：所有定義類、配置文件，便於集中管理。&lt;/li&gt;
&lt;li&gt;Services：將業務操作進行封裝，利於重用及維護。&lt;/li&gt;
&lt;li&gt;Presenters：類似 MVP Pattern 的 Presenter，專注於流程控制和資料流。&lt;/li&gt;
&lt;li&gt;Stores：專責狀態儲存，確保資料一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="實作體悟-1實務上的狀態變化"&gt;實作體悟 1：實務上的狀態變化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一個操作觸發多處改變（One-to-Many Updates）&lt;br&gt;
例如：用戶點擊「開始」後，同時啟動動畫、鎖定按鈕、重置分數、播放音效。&lt;/p&gt;</description></item><item><title>Software Design - Architecture - Modularization</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---modularization/</link><pubDate>Wed, 22 Feb 2023 20:00:00 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---modularization/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;對於軟體模組化，我個人傾向採用漸進式的策略。不同的專案規模，從單一功能的小型專案到多功能的中型專案，各自有其適合的模組化方案。&lt;/p&gt;
&lt;p&gt;在深入探討之前，強烈建議先參考以下連結中的圖表，這對於理解 Clean Architecture 的實際應用細節至關重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/serodriguez68/clean-architecture/blob/master/part-6-details.md#chapter-34---the-missing-chapter---actual-implementation-details-of-an-architecture"&gt;連結 34章摘要心得&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="guide"&gt;Guide&lt;/h2&gt;
&lt;h3 id="clean-architecture-模組化"&gt;Clean Architecture 模組化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://proandroiddev.com/multiple-ways-of-defining-clean-architecture-layers-bbb70afa5d4a"&gt;Multiple ways of defining Clean Architecture layers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.ttulka.com/package-by-component-with-clean-modules-in-java/"&gt;Package by Component with Clean Modules in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learning-notes.mistermicheels.com/architecture-design/reference-architectures/package-by-feature-or-component/"&gt;Package by feature or component&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="垂直切片架構-vertical-slice"&gt;垂直切片架構 (Vertical Slice)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://codeopinion.com/restructuring-to-a-vertical-slice-architecture/?fbclid=IwAR0Ek5KW6_MWQ9K5Rxv6P5BpqatHs5tsjfHZ_B9GZmrkd3YaBoH-HHuNZE4"&gt;Restructuring to a Vertical Slice Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=L2Wnq0ChAIA"&gt;Vertical Slice Architecture, not Layers!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="模組化單體架構-modular-monolith"&gt;模組化單體架構 (Modular Monolith)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.kamilgrzybek.com/design/modular-monolith-primer/"&gt;Modular Monolith architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="thinking"&gt;Thinking&lt;/h2&gt;
&lt;p&gt;以下我將以一個新的 Unity 專案為例，說明我的模組化實踐過程。&lt;/p&gt;</description></item><item><title>Software Design - Architecture - Clean Architecture</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---clean-architecture/</link><pubDate>Sat, 04 Feb 2023 20:00:00 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---clean-architecture/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;談到 Clean Architecture (CA)，我們總會先看到 Uncle Bob 的這張經典分層圖：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"&gt;
 &lt;img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="CA Layers"&gt;

&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文不會逐一詳解 CA 的所有規則與細節，而是更側重於分享它如何改變了我的設計思維，以及在實際開發中的一些經驗與權衡。畢竟，對於追求可擴展性的專案來說，系統架構是確保應用程式能夠持續健康演化的關鍵。&lt;/p&gt;
&lt;p&gt;如果想深入了解 CA 的完整概念，文末的參考資料整理了相當豐富的連結。&lt;/p&gt;
&lt;p&gt;Clean Architecture 並非銀彈，導入它需要付出額外的設計與分層成本。但它所倡導的&lt;strong&gt;關注點分離&lt;/strong&gt;、&lt;strong&gt;單向依賴&lt;/strong&gt;和&lt;strong&gt;以業務為核心&lt;/strong&gt;的理念，即使不完全照搬，也能為我們在設計任何規模的系統時，提供一個清晰且強大的思考框架。&lt;/p&gt;
&lt;h2 id="guide"&gt;Guide&lt;/h2&gt;
&lt;p&gt;「這份清單是我從數百篇文章中精選而來，每一篇都相當有價值，建議深入閱讀。」&lt;/p&gt;
&lt;h3 id="basic"&gt;Basic&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://atomiv.org/knowledgebase/software-architecture/clean-architecture"&gt;Software Architecture - Clean Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learning-notes.mistermicheels.com/architecture-design/reference-architectures/clean-architecture/"&gt;Clean Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pusher.com/tutorials/clean-architecture-introduction/#adapters"&gt;Clean architecture for the rest of us&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/serodriguez68/clean-architecture"&gt;GitHub - serodriguez68/clean-architecture: A detailed summary of Clean Architecture by Robert C Martin (Uncle Bob)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/t2-kob/items/02a76572693130c9a66e"&gt;Clean Architecture の勘所は『鎖国』だ。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://teddy-chen-tw.blogspot.com/2019/12/blog-post_10.html"&gt;搞笑談軟工: 領域邏輯與應用邏輯&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="practice"&gt;Practice&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developers.wonderpla.net/entry/2021/02/18/121932"&gt;Unityを利用した大規模なゲーム開発にクリーンアーキテクチャを採用した話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cobeisfresh.com/blog/getting-started-with-clean-architecture-for-android-part-1"&gt;Getting Started With Clean Architecture for Android [Part 1]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/bespoyasov/clean-architecture-on-frontend-4311"&gt;Clean Architecture on Frontend&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="discussion"&gt;Discussion&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;以下參考資料著重於觀念釐清（可能會帶有較重的教條色彩），以及初期探索時容易踩坑的地方與相關討論串。&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>