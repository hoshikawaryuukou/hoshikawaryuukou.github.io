<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architecture on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/architecture/</link><description>Recent content in Architecture on 識之箱庭</description><generator>Hugo</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Sun, 05 Oct 2025 22:16:53 +0800</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Unity - Architecture - Client Research</title><link>https://HoshikawaRyuukou.github.io/posts/unity---architecture---client-research/</link><pubDate>Sun, 05 Oct 2025 22:16:53 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity---architecture---client-research/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;在設計一個&lt;strong&gt;真正符合自身需求&lt;/strong&gt;的架構過程中，我查閱了許多開發者與企業的設計分享。
不同規模、不同組織背景下，策略與取捨自然各不相同。&lt;/p&gt;
&lt;p&gt;這些實作未必人人適用，但往往能從中擷取值得借鑑的部分。
許多案例都是針對 Unity 實務場景所 &lt;strong&gt;特化（Customized）&lt;/strong&gt; 過的 Clean Architecture，例如省略部分介面或簡化層級結構。&lt;/p&gt;
&lt;p&gt;這樣的做法完全合理——&lt;strong&gt;能貼近實際生產需求的架構，才是真正的好設計。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下整理幾篇值得參考的文章，並附上簡要導讀。&lt;/p&gt;
&lt;h2 id="guide"&gt;Guide&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developers.wonderpla.net/entry/2021/02/18/121932"&gt;Unityを利用した大規模なゲーム開発にクリーンアーキテクチャを採用した話&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手遊系專案&lt;/li&gt;
&lt;li&gt;較為標準的 Clean Architecture 實作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://note.g2-studios.net/n/nada00da3dcd1"&gt;Unityを利用したスマホゲーム開発のアプリ内課金システムに単体テストを導入した話｜G2 Studios株式会社&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手遊系專案&lt;/li&gt;
&lt;li&gt;精簡化版本的 Clean Architecture 實作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.docswell.com/s/torisoup/5YWX2E-xrkaigi2023#p79"&gt;バーチャルキャストの舞台裏 : メタバースの長期運用を実現する技術と戦略 | ドクセル&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特化過的 Clean Architecture 實作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://yotiky.hatenablog.com/entry/2018/11/16/Unity%E3%81%A8%E5%8D%94%E8%AA%BF%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%80%8EMVP4U%E3%80%8F"&gt;Unityと協調するためのアーキテクチャ『MVP4U』 - yotiky Tech Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;採用 MVP + Orchestrator 的子模組串接架構&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://qiita.com/sansuke05/items/c353f287dfc9b19d3a14"&gt;clusterのUnity UI周りの開発紹介 #Cluster - Qiita&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;採用 MVP + 單向依賴的輕量化設計&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://tech-blog.cluster.mu/entry/2022/09/22/215019"&gt;「本日クラスターに入社したUnity Engineerが読む記事」の紹介 - Cluster Tech Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clean Architecture 實作&lt;/li&gt;
&lt;li&gt;表現層最初使用 MVP，後續因內製 UI Framework 的開發逐步轉向 MVVM&lt;/li&gt;
&lt;li&gt;延伸閱讀：&lt;a href="https://tech-blog.cluster.mu/entry/2024/10/18"&gt;内製のUnity UI Frameworkの開発から導入・運用 - Cluster Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://sg.wantedly.com/companies/endroll/post_articles/883646"&gt;ENDROLL の Unity アーキテクチャとかの話 | 株式会社ENDROLL&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Unity - Architecture - Fundamental Client</title><link>https://HoshikawaRyuukou.github.io/posts/unity---architecture---fundamental-client/</link><pubDate>Thu, 02 Oct 2025 11:39:32 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity---architecture---fundamental-client/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;因應 AI 輔助開發的浪潮，我將個人最熟悉的輕量級應用開發模式進行了系統化的整理與規範。&lt;/p&gt;
&lt;p&gt;這個架構的核心理念是讓 AI 扮演「填空者」的角色。開發者預先定義好應用的骨架與規範，而 AI 則專注於填充細部的實作邏輯。如此一來，開發者便能在自己熟悉的框架下，快速理解並整合 AI 的產出，有效降低驗證與重構的認知成本。&lt;/p&gt;
&lt;p&gt;關於這個架構的詳細構成請參考以下文檔&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/hoshikawaryuukou/MGSU_DesignGuide_Fundamental_Client"&gt;GitHub - hoshikawaryuukou/MGSU_DesignGuide_Fundamental_Client&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="develop-flow-inside-out"&gt;Develop Flow (Inside-Out)&lt;/h2&gt;
&lt;p&gt;⚠️請確保閱讀過上述連結。&lt;/p&gt;
&lt;p&gt;我的開發順序，是從最純粹的業務邏輯開始，一層層往外擴展到具體的框架與畫面。這個流程確保我能先專注在真正重要的核心功能上。&lt;/p&gt;
&lt;h3 id="第一步先專注打造可獨立運作的邏輯核心-core"&gt;第一步：先專注打造可獨立運作的邏輯核心 (Core)&lt;/h3&gt;
&lt;p&gt;在動手寫任何 Unity 相關程式碼之前，我會先完成這一層。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;框出功能邊界 (UseCase)&lt;/strong&gt;
我會先問自己：「這個 App 到底能做什麼？」然後把這些功能點，例如「建立遊戲」、「移動棋子」，直接定義成一個個的 &lt;code&gt;UseCase&lt;/code&gt; 類別。這能讓我快速建立起整個應用的功能藍圖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定義依賴與產出 (Port, Store, Event)&lt;/strong&gt;
接著，我會思考每個 &lt;code&gt;UseCase&lt;/code&gt; 的「輸入與輸出」是什麼：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;輸入 (依賴)&lt;/strong&gt;：這個功能需要哪些「外部能力」？例如存檔。我會定義一個 &lt;code&gt;ISaveGamePort&lt;/code&gt; 介面，但&lt;strong&gt;先不管誰來實作它&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;產出 (結果)&lt;/strong&gt;：功能執行完後，會改變哪些「狀態」或觸發什麼「事件」？我會定義出對應的 &lt;code&gt;Store&lt;/code&gt; 和 &lt;code&gt;Event&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;完成核心邏輯&lt;/strong&gt;
最後，把上面定義好的零件組裝起來，完成 &lt;code&gt;UseCase&lt;/code&gt; 的內部流程。如果邏輯很複雜（如棋盤規則），我會再把這部分抽成更純粹的 &lt;code&gt;Domain&lt;/code&gt; 物件。到這裡，核心功能就完成了，而且&lt;strong&gt;完全不依賴 Unity&lt;/strong&gt;，可以獨立測試。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="第二步實作與外部世界溝通的適配器-adapter"&gt;第二步：實作與外部世界溝通的適配器 (Adapter)&lt;/h3&gt;
&lt;p&gt;核心邏輯建好後，我才開始處理與 Unity 框架的互動。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;實作外部能力 (Infrastructure)&lt;/strong&gt;
我會開始實作之前在 Core 層定義的 &lt;code&gt;Port&lt;/code&gt; 介面。例如，用 &lt;code&gt;PlayerPrefs&lt;/code&gt; 來實作 &lt;code&gt;ISaveGamePort&lt;/code&gt;。因為 Core 只依賴介面，未來要換成雲端存檔也很容易。&lt;/p&gt;</description></item><item><title>Software Design - Architecture - Unity Slot Game Client</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---unity-slot-game-client/</link><pubDate>Mon, 30 Jun 2025 10:00:00 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---unity-slot-game-client/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;前端開發時，「狀態管理」一直是個大哉問。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本次的應用是 &lt;strong&gt;Slot Game&lt;/strong&gt;，這類應用強調「表現層細節」，所以對於狀態的控制不像一般資料應用一樣單純，需要處理許多細部和即時的變化。&lt;/p&gt;
&lt;h3 id="狀態管理挑戰"&gt;狀態管理挑戰&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;響應式 data-binding 限制 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若完全依賴響應式 data-binding，容易產生太多「中間態」(例如動畫進行中、結果待顯示、部分組件已經觸發&amp;hellip;等)。&lt;/li&gt;
&lt;li&gt;這樣會造成 state 爆炸、難以追蹤維護。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令式流程控制的必要性 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部分場景下，直接用命令式（imperative）流程更有效率。&lt;/li&gt;
&lt;li&gt;多組件聯動時的「動畫序列控制」。&lt;/li&gt;
&lt;li&gt;一連串的 user action/遊戲事件，需明確依序觸發。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-技術棧一覽"&gt;⚙️ 技術棧一覽&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UniTask (異步)&lt;/li&gt;
&lt;li&gt;R3 (Rx，UniRx 後繼者)&lt;/li&gt;
&lt;li&gt;VContainer (依賴注入)&lt;/li&gt;
&lt;li&gt;LitMotion (Tween)&lt;/li&gt;
&lt;li&gt;YooAsset (資源管理)&lt;/li&gt;
&lt;li&gt;Newtonsoft Json (Json 解析)&lt;/li&gt;
&lt;li&gt;Alchemy (編輯器擴充)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="專案結構"&gt;專案結構&lt;/h2&gt;
&lt;h3 id="modules-主架構"&gt;Modules 主架構&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;project-root/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── _Debug/ &lt;span style="color:#75715e"&gt;# 測試或實驗用模組&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── App/ &lt;span style="color:#75715e"&gt;# 啟動點與業務邏輯總控&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── GameAPI/ &lt;span style="color:#75715e"&gt;# 遊戲 API 定義&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── GameRunner/ &lt;span style="color:#75715e"&gt;# 遊戲平台通用組件 (純 UIComponent)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── GameStage/ &lt;span style="color:#75715e"&gt;# 遊戲表演組件 (純 UIComponent)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── Shared/ &lt;span style="color:#75715e"&gt;# 共用模組&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;App：負責組合、調度各個模組，等於是專案的大腦。&lt;/li&gt;
&lt;li&gt;GameAPI：只放介面定義，跨模組通訊與擴充。&lt;/li&gt;
&lt;li&gt;GameRunner / GameStage：都是純 UIComponent (基本都是 Mono)。&lt;/li&gt;
&lt;li&gt;Shared：共用邏輯、工具類、資料結構都放這裡。&lt;/li&gt;
&lt;li&gt;_Debug：僅用於測試、debug，正式版本不打包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="module-模組以單一模組為例"&gt;Module 模組（以單一模組為例）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;module-root/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Res/ &lt;span style="color:#75715e"&gt;# 模組獨立資源&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── Scripts/ &lt;span style="color:#75715e"&gt;# 腳本程式碼&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ├── Editor/ &lt;span style="color:#75715e"&gt;# 編輯器相關&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; └── Runtime/ &lt;span style="color:#75715e"&gt;# 執行時相關&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Res：模組內專屬資源包。&lt;/li&gt;
&lt;li&gt;Scripts/Editor：編輯器工具。&lt;/li&gt;
&lt;li&gt;Scripts/Runtime：模組實際邏輯，遊戲執行時會用到的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="app-runtime運行時架構"&gt;App-Runtime（運行時架構）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;App-Runtime-root/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Configs/ &lt;span style="color:#75715e"&gt;# 配置與定義&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Services/ &lt;span style="color:#75715e"&gt;# 封裝各種業務操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Presenters/ &lt;span style="color:#75715e"&gt;# 控制流程、狀態綁定&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── Stores/ &lt;span style="color:#75715e"&gt;# 狀態管理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Configs：所有定義類、配置文件，便於集中管理。&lt;/li&gt;
&lt;li&gt;Services：將業務操作進行封裝，利於重用及維護。&lt;/li&gt;
&lt;li&gt;Presenters：類似 MVP Pattern 的 Presenter，專注於流程控制和資料流。&lt;/li&gt;
&lt;li&gt;Stores：專責狀態儲存，確保資料一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="實作體悟-1實務上的狀態變化"&gt;實作體悟 1：實務上的狀態變化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一個操作觸發多處改變（One-to-Many Updates）&lt;br&gt;
例如：用戶點擊「開始」後，同時啟動動畫、鎖定按鈕、重置分數、播放音效。&lt;/p&gt;</description></item><item><title>Software Design - Architecture - Modularization</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---modularization/</link><pubDate>Wed, 22 Feb 2023 20:00:00 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---modularization/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;對於軟體模組化，我個人傾向採用漸進式的策略。不同的專案規模，從單一功能的小型專案到多功能的中型專案，各自有其適合的模組化方案。&lt;/p&gt;
&lt;p&gt;在深入探討之前，強烈建議先參考以下連結中的圖表，這對於理解 Clean Architecture 的實際應用細節至關重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/serodriguez68/clean-architecture/blob/master/part-6-details.md#chapter-34---the-missing-chapter---actual-implementation-details-of-an-architecture"&gt;連結 34章摘要心得&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="guide"&gt;Guide&lt;/h2&gt;
&lt;h3 id="clean-architecture-模組化"&gt;Clean Architecture 模組化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://proandroiddev.com/multiple-ways-of-defining-clean-architecture-layers-bbb70afa5d4a"&gt;Multiple ways of defining Clean Architecture layers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.ttulka.com/package-by-component-with-clean-modules-in-java/"&gt;Package by Component with Clean Modules in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learning-notes.mistermicheels.com/architecture-design/reference-architectures/package-by-feature-or-component/"&gt;Package by feature or component&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="垂直切片架構-vertical-slice"&gt;垂直切片架構 (Vertical Slice)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://codeopinion.com/restructuring-to-a-vertical-slice-architecture/?fbclid=IwAR0Ek5KW6_MWQ9K5Rxv6P5BpqatHs5tsjfHZ_B9GZmrkd3YaBoH-HHuNZE4"&gt;Restructuring to a Vertical Slice Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=L2Wnq0ChAIA"&gt;Vertical Slice Architecture, not Layers!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="模組化單體架構-modular-monolith"&gt;模組化單體架構 (Modular Monolith)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.kamilgrzybek.com/design/modular-monolith-primer/"&gt;Modular Monolith architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="thinking"&gt;Thinking&lt;/h2&gt;
&lt;p&gt;以下我將以一個新的 Unity 專案為例，說明我的模組化實踐過程。&lt;/p&gt;</description></item><item><title>Software Design - Architecture - Clean Architecture</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---clean-architecture/</link><pubDate>Sat, 04 Feb 2023 20:00:00 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---clean-architecture/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;談到 Clean Architecture (CA)，我們總會先看到 Uncle Bob 的這張經典分層圖：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"&gt;
 &lt;img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="CA Layers"&gt;

&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文不會逐一詳解 CA 的所有規則與細節，而是更側重於分享它如何改變了我的設計思維，以及在實際開發中的一些經驗與權衡。畢竟，對於追求可擴展性的專案來說，系統架構是確保應用程式能夠持續健康演化的關鍵。&lt;/p&gt;
&lt;p&gt;如果想深入了解 CA 的完整概念，文末的參考資料整理了相當豐富的連結。&lt;/p&gt;
&lt;p&gt;Clean Architecture 並非銀彈，導入它需要付出額外的設計與分層成本。但它所倡導的&lt;strong&gt;關注點分離&lt;/strong&gt;、&lt;strong&gt;單向依賴&lt;/strong&gt;和&lt;strong&gt;以業務為核心&lt;/strong&gt;的理念，即使不完全照搬，也能為我們在設計任何規模的系統時，提供一個清晰且強大的思考框架。&lt;/p&gt;
&lt;h2 id="guide"&gt;Guide&lt;/h2&gt;
&lt;p&gt;「這份清單是我從數百篇文章中精選而來，每一篇都相當有價值，建議深入閱讀。」&lt;/p&gt;
&lt;h3 id="basic"&gt;Basic&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://atomiv.org/knowledgebase/software-architecture/clean-architecture"&gt;Software Architecture - Clean Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learning-notes.mistermicheels.com/architecture-design/reference-architectures/clean-architecture/"&gt;Clean Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pusher.com/tutorials/clean-architecture-introduction/#adapters"&gt;Clean architecture for the rest of us&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/serodriguez68/clean-architecture"&gt;GitHub - serodriguez68/clean-architecture: A detailed summary of Clean Architecture by Robert C Martin (Uncle Bob)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/t2-kob/items/02a76572693130c9a66e"&gt;Clean Architecture の勘所は『鎖国』だ。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://teddy-chen-tw.blogspot.com/2019/12/blog-post_10.html"&gt;搞笑談軟工: 領域邏輯與應用邏輯&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="practice"&gt;Practice&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developers.wonderpla.net/entry/2021/02/18/121932"&gt;Unityを利用した大規模なゲーム開発にクリーンアーキテクチャを採用した話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cobeisfresh.com/blog/getting-started-with-clean-architecture-for-android-part-1"&gt;Getting Started With Clean Architecture for Android [Part 1]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/bespoyasov/clean-architecture-on-frontend-4311"&gt;Clean Architecture on Frontend&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="discussion"&gt;Discussion&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;以下參考資料著重於觀念釐清（可能會帶有較重的教條色彩），以及初期探索時容易踩坑的地方與相關討論串。&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>