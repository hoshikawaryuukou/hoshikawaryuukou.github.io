<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architecture on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/architecture/</link><description>Recent content in Architecture on 識之箱庭</description><generator>Hugo</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Mon, 30 Jun 2025 21:05:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Software Design - Architecture - Slot Game Client</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---slot-game-client/</link><pubDate>Mon, 30 Jun 2025 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---slot-game-client/</guid><description>&lt;h2 id="quick-chat">Quick Chat&lt;/h2>
&lt;blockquote>
&lt;p>前端開發時，「狀態管理」一直是個大哉問。&lt;/p>&lt;/blockquote>
&lt;p>本次的應用是 &lt;strong>Slot Game&lt;/strong>，這類應用強調「表現層細節」，所以對於狀態的控制不像一般資料應用一樣單純，需要處理許多細部和即時的變化。&lt;/p>
&lt;h3 id="狀態管理挑戰">狀態管理挑戰&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>響應式 data-binding 限制 :&lt;/p>
&lt;ul>
&lt;li>若完全依賴響應式 data-binding，容易產生太多「中間態」(例如動畫進行中、結果待顯示、部分組件已經觸發&amp;hellip;等)。&lt;/li>
&lt;li>這樣會造成 state 爆炸、難以追蹤維護。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>命令式流程控制的必要性 :&lt;/p>
&lt;ul>
&lt;li>部分場景下，直接用命令式（imperative）流程更有效率。&lt;/li>
&lt;li>多組件聯動時的「動畫序列控制」。&lt;/li>
&lt;li>一連串的 user action/遊戲事件，需明確依序觸發。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="-技術棧一覽">⚙️ 技術棧一覽&lt;/h3>
&lt;ul>
&lt;li>UniTask (異步)&lt;/li>
&lt;li>R3 (Rx，UniRx 後繼者)&lt;/li>
&lt;li>VContainer (依賴注入)&lt;/li>
&lt;li>LitMotion (Tween)&lt;/li>
&lt;li>YooAsset (資源管理)&lt;/li>
&lt;li>Newtonsoft Json (Json 解析)&lt;/li>
&lt;li>Alchemy (編輯器擴充)&lt;/li>
&lt;/ul>
&lt;h2 id="專案結構">專案結構&lt;/h2>
&lt;h3 id="modules-主架構">Modules 主架構&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>project-root/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── _Debug/ &lt;span style="color:#75715e"># 測試或實驗用模組&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── App/ &lt;span style="color:#75715e"># 啟動點與業務邏輯總控&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── GameAPI/ &lt;span style="color:#75715e"># 遊戲 API 定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── GameRunner/ &lt;span style="color:#75715e"># 遊戲平台通用組件 (純 UIComponent)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── GameStage/ &lt;span style="color:#75715e"># 遊戲表演組件 (純 UIComponent)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Shared/ &lt;span style="color:#75715e"># 共用模組&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>App：負責組合、調度各個模組，等於是專案的大腦。&lt;/li>
&lt;li>GameAPI：只放介面定義，跨模組通訊與擴充。&lt;/li>
&lt;li>GameRunner / GameStage：都是純 UIComponent (基本都是 Mono)。&lt;/li>
&lt;li>Shared：共用邏輯、工具類、資料結構都放這裡。&lt;/li>
&lt;li>_Debug：僅用於測試、debug，正式版本不打包。&lt;/li>
&lt;/ul>
&lt;h3 id="module-模組以單一模組為例">Module 模組（以單一模組為例）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>module-root/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Res/ &lt;span style="color:#75715e"># 模組獨立資源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Scripts/ &lt;span style="color:#75715e"># 腳本程式碼&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ├── Editor/ &lt;span style="color:#75715e"># 編輯器相關&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── Runtime/ &lt;span style="color:#75715e"># 執行時相關&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Res：模組內專屬資源包。&lt;/li>
&lt;li>Scripts/Editor：編輯器工具。&lt;/li>
&lt;li>Scripts/Runtime：模組實際邏輯，遊戲執行時會用到的部分。&lt;/li>
&lt;/ul>
&lt;h3 id="app-runtime運行時架構">App-Runtime（運行時架構）&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>App-Runtime-root/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Configs/ &lt;span style="color:#75715e"># 配置與定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Services/ &lt;span style="color:#75715e"># 封裝各種業務操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Presenters/ &lt;span style="color:#75715e"># 控制流程、狀態綁定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Stores/ &lt;span style="color:#75715e"># 狀態管理&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Configs：所有定義類、配置文件，便於集中管理。&lt;/li>
&lt;li>Services：將業務操作進行封裝，利於重用及維護。&lt;/li>
&lt;li>Presenters：類似 MVP Pattern 的 Presenter，專注於流程控制和資料流。&lt;/li>
&lt;li>Stores：專責狀態儲存，確保資料一致性。&lt;/li>
&lt;/ul>
&lt;h2 id="實作體悟-1實務上的狀態變化">實作體悟 1：實務上的狀態變化&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>一個操作觸發多處改變（One-to-Many Updates）&lt;br>
例如：用戶點擊「開始」後，同時啟動動畫、鎖定按鈕、重置分數、播放音效。&lt;/p></description></item><item><title>Software Design - Architecture Design</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture-design/</link><pubDate>Wed, 25 Dec 2024 20:03:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture-design/</guid><description>&lt;h2 id="thinking">Thinking&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://minds.md/zakirullin/cognitive#long">Cognitive load is what matters&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Software Design - Architecture - Web &amp; Desktop app</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---web--desktop-app/</link><pubDate>Sat, 05 Oct 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---web--desktop-app/</guid><description>&lt;h2 id="quick-chat">Quick Chat&lt;/h2>
&lt;p>(⚠️ 實驗中) 當一個要開發一個同時支援 &lt;strong>網頁端&lt;/strong> 與 &lt;strong>桌面端&lt;/strong> 的應用時，該如何設計。以下範例說明使用&lt;/p>
&lt;ul>
&lt;li>UIFramework : Vue3&lt;/li>
&lt;li>Desktop Framework : Electron&lt;/li>
&lt;/ul>
&lt;h2 id="architecture">Architecture&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>project-root/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── core/ &lt;span style="color:#75715e"># 核心業務邏輯&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── services/ &lt;span style="color:#75715e"># 服務層，包含業務邏輯 (e.g., FileManager)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── models/ &lt;span style="color:#75715e"># 共享的資料模型和接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── interfaces/ &lt;span style="color:#75715e"># 定義服務的接口 (e.g., IFileService)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── presentation/ &lt;span style="color:#75715e"># UI 表現層 (Vue3 應用)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── components/ &lt;span style="color:#75715e"># Vue 組件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── views/ &lt;span style="color:#75715e"># Vue 頁面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── stores/ &lt;span style="color:#75715e"># Pinia 狀態管理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── App.vue &lt;span style="color:#75715e"># Vue 入口文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── web/ &lt;span style="color:#75715e"># 瀏覽器端特定實現&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── services/ &lt;span style="color:#75715e"># 瀏覽器環境下的文件操作等服務實現 (e.g., BrowserFileService)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── index.html &lt;span style="color:#75715e"># 網頁版的入口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── main.js &lt;span style="color:#75715e"># 網頁版的啟動點，將核心業務注入 Vue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── desktop/ &lt;span style="color:#75715e"># Electron 桌面端特定實現&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── main/ &lt;span style="color:#75715e"># 主進程相關文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ │ ├── main.js &lt;span style="color:#75715e"># Electron 主進程入口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ │ └── preload.js &lt;span style="color:#75715e"># 預加載腳本，用於將 Node API 注入到渲染進程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── renderer.js &lt;span style="color:#75715e"># 渲染進程啟動點，將核心業務注入 Vue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── package.json &lt;span style="color:#75715e"># 項目配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="thought">Thought&lt;/h2>
&lt;p>主體思想是基於 Clean Architecture，Clean Architecture 主張將業務邏輯與框架、UI 和其他技術細節分離，使得核心業務邏輯不依賴於特定的運行環境或框架。&lt;/p></description></item><item><title>Electron - Design Context</title><link>https://HoshikawaRyuukou.github.io/posts/electron---design-context/</link><pubDate>Fri, 27 Sep 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/electron---design-context/</guid><description>&lt;h2 id="context---將現有的前端專案包裝成桌面端應用">Context - 將現有的前端專案包裝成桌面端應用&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>情境：&lt;/strong> 已有一個完整的前端專案，但由於一些特定需求（例如離線操作的能力），決定將其包裝成桌面端應用。本質上，這個應用仍是一個網頁應用，因此基本上不會有額外的桌面端互動需求，也不需要特別增強和操作系統的整合。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>目的：&lt;/strong> 主要為了滿足離線存取與更佳的用戶體驗，但不需要深度的桌面端特性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>技術重點：&lt;/strong> 專注於如何將現有的 Web 應用以 Electron 進行包裝，保持與原生前端相同的開發流程，並且避免過多改動。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>限制：&lt;/strong> 盡量維持輕量化，減少與桌面平台的耦合，僅利用 Electron 提供的框架和包裝功能。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="context---基於前端技術開發桌面端應用">Context - 基於前端技術開發桌面端應用&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>情境：&lt;/strong> 目標是開發桌面端應用，只是基於前端技術來實現。這意味著應用程式將包含一些桌面應用所特有的特性，例如系統通知、檔案系統操作、離線儲存等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>目的：&lt;/strong> 充分利用 Electron 提供的 API 來增強桌面應用的功能，使其可以提供超越單純網頁應用的體驗。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>技術重點：&lt;/strong> 基於前端技術棧（如 Vue、React 等），但需要使用 Electron 來實現與桌面系統的交互，包括檔案存取、系統托盤等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>設計考量：&lt;/strong> 需要兼顧應用的桌面特性與前端開發的靈活性，保證兩者間的有效融合。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="context---electron-與-前端技術-僅是實作細節">Context - Electron 與 前端技術 僅是實作細節&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>情境：&lt;/strong> 設計理念以業務需求為核心，Electron 以及前端技術只是達成目標的手段和細節。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>業務為中心的設計：&lt;/strong> 設計時不局限於技術選型，而是先分析業務需求，再根據需求選擇最佳的技術方案。最終選擇的技術（Electron、前端技術）只是為了實現業務需求的手段。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>基於 Clean Architecture：&lt;/strong> 使用乾淨架構來分離業務邏輯與實作細節，確保應用程式具有良好的可擴展性與可維護性。Electron 與前端技術被隔離在具體的實作層，任何一方都可以被替換而不影響業務邏輯。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>技術重點：&lt;/strong> 強調框架的選擇與使用不應該影響到核心業務邏輯，業務邏輯應獨立於 UI、技術框架的變更，專注於系統的彈性與維護性。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Software Design - Architecture - VIPER</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---viper/</link><pubDate>Fri, 19 Jan 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---viper/</guid><description>&lt;h2 id="簡述">簡述&lt;/h2>
&lt;p>VIPER (View-Interactor-Presenter-Entity-Router)&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://juejin.cn/post/6844903491941433351">iOS VIPER架構實踐(一)：從MVC到MVVM到VIPER&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/tyndale1993/article/details/80777324">VIPER，更清晰的架构，解决复用和测试问题的利器系列1：VIPER架构演进史&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>有很多種實作流派，下圖是我比較偏好的模式呈現&lt;/p>
&lt;p>
 &lt;img src="https://HoshikawaRyuukou.github.io/images/VIPER.png" alt="VIPER">

&lt;/p>
&lt;p>VIPER 借鏡了 CA (Clean Architecture) 的思想為 MVC 提供一個新的設計方案&lt;/p>
&lt;ul>
&lt;li>Entity 對應原本的 Model&lt;/li>
&lt;li>Controller 責任過重 -&amp;gt; 將業務邏輯移至 Interactor 並提高重用性&lt;/li>
&lt;li>Controllers 之間耦合 -&amp;gt; 將導航邏輯移至 Router&lt;/li>
&lt;li>Presenter 作為 Binder 將 View / Interactor / Router 整合&lt;/li>
&lt;/ul>
&lt;h2 id="啟發">啟發&lt;/h2>
&lt;p>VIPER 是筆者學習架構路上很重要的一個過渡，有以下兩點的思想轉變&lt;/p>
&lt;h3 id="顆粒度更細的單一職責">顆粒度更細的單一職責&lt;/h3>
&lt;p>Interactor 封裝業務的概念在純 MVX 中是無法直接體會到，因此對之後學習 CA 時起了很大的緩衝，不然對於 Usecase 的設計應該會很不適應。&lt;/p>
&lt;h3 id="重視-navigation">重視 Navigation&lt;/h3>
&lt;p>在學習 CA 中始終沒題到 feature/componet module 之間是如何互動的，也是在回頭複習 VIPER 時才重新意識到 Router 的重要性。當沒有特別規劃 Navigation 時很容易會造成 module 之間的耦合。&lt;/p></description></item><item><title>Software Design - Architecture - Clean Architecture</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---clean-architecture/</link><pubDate>Sat, 04 Feb 2023 20:03:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---architecture---clean-architecture/</guid><description>&lt;p>以下 Clean Architecture 簡稱 CA&lt;/p>
&lt;p>這裡還是先引用 Uncle Bob 的分層圖
&lt;a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Code Blog - The Clean Architecture&lt;/a>

 &lt;img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="CA Layers">

&lt;/p>
&lt;p>筆者認爲可擴展性是系統架構的重要考量。畢竟應用程式會演化，必須不斷更新與修改系統以滿足新的需求，而 CA 是其中一種實現方針。筆者在這裡不會寫出詳細的介紹，想了解的可以參考 Ref 整理的連結或是 CA 相關書籍。&lt;/p>
&lt;p>本文著重於促使筆者思考方式改變的幾個重要觀念。&lt;/p>
&lt;h2 id="依賴關係">依賴關係&lt;/h2>
&lt;ul>
&lt;li>相依性: 向內圈依賴，且盡量避免跨層依賴 (有些例外之後說明)。&lt;/li>
&lt;li>Dependency Inversion Principle (DIP): 內圈定義介面，外圈實作。&lt;/li>
&lt;/ul>
&lt;p>基於這兩個規則所帶來的是&lt;/p>
&lt;ul>
&lt;li>單向依賴流 : 紊亂的依賴流可能造成牽一髮動全身的窘境。尤其是當 Domain 去依賴到細節時。&lt;/li>
&lt;li>延後實作 : UseCase/Adapter 都是依賴於應用層所開出的介面。因此業務/畫面能獨立開發，不用互相等待(理想狀態)。&lt;/li>
&lt;/ul>
&lt;p>而筆者在實作時的基本型架構通常如下圖(比較接近 CA 書中的另外一張圖，我這裡做了簡化)，Adapter 只分成 Input/Output Port。

 &lt;img src="https://HoshikawaRyuukou.github.io/images/CleanArchitectureBasic.png" alt="Clean Architecture Basic">

&lt;/p>
&lt;ul>
&lt;li>Domain: 領域邏輯&lt;/li>
&lt;li>UseCase: 應用邏輯&lt;/li>
&lt;li>Domain + UseCase: 業務邏輯&lt;/li>
&lt;li>InputPort: 用例功能使用方介面&lt;/li>
&lt;li>OutputPort: 用例功能支援方介面&lt;/li>
&lt;li>Adapter: 將外部與用例功能接合的膠水代碼&lt;/li>
&lt;/ul>
&lt;p>不過架構會針對不同情況做調整，細節參考另一篇文章&lt;/p>
&lt;p>架構設計 - Clean Architecture and Modularization&lt;/p></description></item></channel></rss>