<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Principle on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/principle/</link><description>Recent content in Principle on 識之箱庭</description><generator>Hugo</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Thu, 16 Jan 2025 20:00:00 +0800</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/principle/index.xml" rel="self" type="application/rss+xml"/><item><title>Software Design - Principle - Inversion of Control (IoC)</title><link>https://HoshikawaRyuukou.github.io/posts/software-design---principle---inversion-of-control-ioc/</link><pubDate>Thu, 16 Jan 2025 20:00:00 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design---principle---inversion-of-control-ioc/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;「控制反轉（Inversion of Control, IoC）」這個詞常常讓人一頭霧水──到底反轉了什麼？&lt;/p&gt;
&lt;p&gt;更麻煩的是，它還很容易和「依賴倒置（Dependency Inversion）」混淆 😅&lt;/p&gt;
&lt;p&gt;如果你在開發時有出現以下這些疑惑，那麼你其實已經在思考 IoC 要解決的問題了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;為什麼到處都要 &lt;code&gt;new&lt;/code&gt;？&lt;/li&gt;
&lt;li&gt;建構子的參數要怎麼安排？初始化邏輯怎麼整理？&lt;/li&gt;
&lt;li&gt;物件能不能被共享？生命週期誰來管理？何時該釋放？&lt;/li&gt;
&lt;li&gt;是否需要一個「專門管理依賴」的角色？&lt;/li&gt;
&lt;li&gt;這個類別既要處理業務邏輯，又要負責 &lt;code&gt;new&lt;/code&gt; 物件，職責是不是太混亂了？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IoC 正是為了解決這些問題而提出的，它帶來一個核心理念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;依賴的「使用者」不再自己主動去建立和配置依賴，而是把這個「控制權」交給外部機制（通常是 IoC 容器）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;換句話說：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;依賴的「使用者」只需要「接收」或「查詢」它所需的依賴，然後專心「使用」它們。這樣它就能專注在核心邏輯上，而不必分心處理依賴管理，進而提升模組化與可維護性。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="advantages"&gt;Advantages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;降低耦合度：&lt;/strong&gt; 需求方與具體實現之間不再直接關聯，每個模組都可以獨立開發、測試與替換，互不影響。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;集中管理依賴：&lt;/strong&gt; 容器統一管理所有物件的建立和生命週期。當您需要替換某個服務的實作時，只需要修改容器的配置，而不需要動到多處程式碼。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免重複建構：&lt;/strong&gt; 容器可以管理共享的物件實例，有效避免重複建立，提高資源利用率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提升測試便利性：&lt;/strong&gt; 透過 IoC 容器，在進行單元測試時，可以輕鬆地將真實的服務替換為&lt;strong&gt;模擬物件（mock）&lt;/strong&gt; 或 &lt;strong&gt;測試替身（stub）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="practice"&gt;Practice&lt;/h2&gt;
&lt;p&gt;實現 IoC 有兩種常見方式：&lt;strong&gt;依賴注入（Dependency Injection, DI）&lt;/strong&gt; 和 &lt;strong&gt;依賴尋找（Dependency Lookup）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="依賴注入di"&gt;依賴注入（DI）&lt;/h3&gt;
&lt;p&gt;這是目前最主流且推薦的實踐方式，核心概念是&lt;strong&gt;由容器「被動地」將依賴項傳遞給需求方&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;實作原理：&lt;/strong&gt; 容器會主動將所需的依賴（如服務物件）透過以下方式注入到您的類別中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;建構子注入（Constructor Injection）：&lt;/strong&gt; 在物件建構時，透過建構子的參數傳入依賴。這是最推薦的方式，因為它可以確保物件在建立時就擁有所有必要的依賴，讓依賴關係更清晰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;屬性注入（Property Injection）：&lt;/strong&gt; 透過公開的屬性（Setter）來傳入依賴。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方法注入（Method Injection）：&lt;/strong&gt; 透過特定的方法來傳入依賴。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;優點：&lt;/strong&gt; 這種方式讓您的程式碼無需知道容器的存在（理想狀態），因為依賴是「被動」傳入的，大大降低了耦合度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="依賴尋找dependency-lookup"&gt;依賴尋找（Dependency Lookup）&lt;/h3&gt;
&lt;p&gt;這種方式的核心是&lt;strong&gt;由需求方「主動地」向容器請求所需的依賴&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;實作原理：&lt;/strong&gt; 需求方會直接呼叫容器的方法（例如 &lt;code&gt;container.resolve()&lt;/code&gt;），來取得所需的服務。&lt;/p&gt;</description></item></channel></rss>