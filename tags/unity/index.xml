<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unity on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/unity/</link><description>Recent content in Unity on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Sat, 13 Apr 2024 21:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/unity/index.xml" rel="self" type="application/rss+xml"/><item><title>Unity - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/unity-packages/</link><pubDate>Sat, 13 Apr 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-packages/</guid><description>Package Manager Installing Packages using UPM Package manager -&amp;gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -&amp;gt; Packages: My Registries -&amp;gt; Install Guide Unity中 .asmdef文件的作用 使用OpenUPM发布自己的Unity项目 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM 【Unity】Package Manager活用術 Package Collection killop/anything_about_game baba-s/awesome-unity-open-source-on-github Animation PrimeTween Async UniTask Debug UnityIngameDebugConsole Dependency Injection VContainer Dialogue YarnSpinner-Unity Editor NaughtyAttributes Alchemy HotFix HybridCLR Localization Lean Localization Media UnityNativeCamera Messaging MessagePipe Particle Effect ParticleEffectForUGUI Persistence PlayerPrefs Editor &amp;amp; Utilities Resource Management YooAsset Rx (Reactive Extensions) UniRx R3 Serialization Newtonsoft.</description></item><item><title>Unity - Basic - WebGL</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-webgl/</link><pubDate>Sat, 09 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-webgl/</guid><description>前述 使用 Unity 2022.3 開發，Unity 2022.1 在 iPhone/Android 上運行時不再顯示警告。似乎可以逐漸用於智慧手機專案。 Context 是 2D 小遊戲，以 webgl 1 輸出，暫時不需要 webgl 2 畫面效果。 Guide Unity User Manual 2022.3 (LTS)Platform developmentWebGL Unity WebGLビルドメモ - フレームシンセシス Unity 製 WebGL ゲームを AWS でお手軽公開 Unity WebGL 微信小游戏适配方案(公测) Template (Unity) Better Minimal WebGL Template Tests Unity WebGL Loading Test Instant Game Meta Instant Games Unity Instant Game Recommended Basic Todo 資源使用 Assetbundle 分包 資源限制下載數 ( 10個以內 ) 資源緩存 啟動封面範本修改 閒置時段下載資源 wasm 分包 (方案尋找中) Others 【Unity】WebGL開発時の注意事項 #Unity 游戏一键打包 #Facebook小游戏 解决方案 My WebGL assets Unity Webgl 问题总结 UnityWebGL移动端兼容性说明 Unity发布webgl获取浏览器的URL Unity WebGL で WebSocket を使う</description></item><item><title>Unity - Package - UniTask</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-unitask/</link><pubDate>Sat, 10 Feb 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-unitask/</guid><description>前述 UniTask - Unity 中實現效能最好的 async/await 的函式庫
Cysharp/UniTask Unity 中預設的非同步實現是 - Coroutine 協程，但協程有以下缺點
無法使用回傳值，需使用 callback 來解決。 異常處理很困難，因為不能在 try-catch 區塊內使用 yield。 需透過 MonoBehaviour.StartCoroutine 才能啟動。 UniTask 相較於 C# 原生的 Task 做了以下改進
刪除了 Task 在 Unity 不需要的功能。 非 MonoBehaviour 裡也能實現非同步。 記憶體/ GC / Unity PlayerLoop 等方面做最佳化。 UniTaskTracker 提供編輯器上可視化追蹤 await 狀態，這對於檢查是否有洩漏很有用。 UniTask 官方文件的基本功能寫得相當清楚，並附上一些入門介紹
UniTaskを使おう！ UniTask機能紹介 以下紀錄幾個重點主題
Awaiter UniTask 已經實作了相當豐富的 Awaiter 擴充，有需要自訂的可以參考以下規範
.NET 中什么样的类是可使用 await 异步等待的？ Thread UniTask.SwitchToThreadPool 允許後續處理在執行緒池中進行。 UniTask.SwitchToMainThread 切換到主執行緒，不會等待下一幀。 也可以使用 UniTask.Yield 切換到主執行緒，但它總是等待一幀。 但目前尚未有使用到的情境，之後有遇到再嘗試。</description></item><item><title>Unity - Basic - Android Build</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-android-build/</link><pubDate>Sat, 03 Feb 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-android-build/</guid><description>Settings gradleTemplate.properties : 專案的全域 Gradle 配置。 AndroidManifest.xml ：用於向 Android 構建工具、Android 作業系統和 Google Play 描述應用的基本資訊。 launcherManifest.xml 定義應用的啟動配置資訊 mainTemplate.gradle：自定義 Android 專案的 Gradle 構建過程，包括添加依賴項、修改編譯設定、配置簽名資訊等。 launcherTemolate.gradle ：包含有關如何構建 Android 應用程式的指令 baseProjectTemplate.gradle：所含的配置會在其他所有範本/Gradle 專案之間共用 Ref Unity 不通過Android studio 打包接SDK</description></item><item><title>Unity - Basic - AndroidJNIModule</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-androidjava/</link><pubDate>Sun, 28 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-androidjava/</guid><description>前述 這次的業務需求是
將 Google Play Install Referrer 接入 Unity
目前有使用到 AndroidJNIModule 中的
AndroidJavaClass AndroidJavaObject AndroidJavaProxy 但中途採了不少坑，特此紀錄一下。
基本知識 UnityEngine.AndroidJNIModule How to Create Android Java Callbacks to C# in Unity UnityからAndroidのクラスや関数を呼び出す AndroidJavaClass 可以實例化 Java 類、調用 Java 類的靜態方法，以及訪問 Java 類的靜態屬性。 AndroidJavaObject 創建 Java 對象的實例。 AndroidJavaProxy 允許在 Unity C# 腳本中實現 Java 接口。 允許我們在 Java 中調用方法，這些方法將調用 C# 類上的 匹配 方法。 注意 函數名匹配 (建議直接看 source code 裡面的值，本此次就遇到 官方文件與 jar 為匹配) android.os.Build.VERSION 將意味著要到一個公開類 android.os.Build$VERSION 將意味著進入一個內部類</description></item><item><title>Unity - Service - Google Play Install Referrer</title><link>https://HoshikawaRyuukou.github.io/posts/unity-service-google-play-install-referrer/</link><pubDate>Thu, 25 Jan 2024 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-service-google-play-install-referrer/</guid><description>簡述 Play Install Referrer
Play Install Referrer API : 非 Kotlin / Java 用戶使用 Play Install Referrer Library : 將上者封裝更方便 Kotlin / Java 使用 透過該服務能對 App 的下載與使用者進行歸因分析，用於評估推廣服務得成效，進而提升推廣效果與報酬率。
舊版 Play Install Referrer 在使用者下載應用程式後透過廣播傳送包含歸因參數的訊息。然而廣播的不可靠性和安全性問題，目前不再建議使用這個版本。 新版 Play Install Referrer 直接訪問本機 Google Play 應用程式商店中的記錄，索取 referrer 值，因此更加可靠。 快速上手 Unity 專案: 將依賴加在 maintemplate.gradle
dependencies { implementation(&amp;#34;com.android.installreferrer:installreferrer:2.2&amp;#34;) } 因為官方 API 文件寫的不全，建議到以下網站直接下載 aar 查看 jar 來對接 API
Google&amp;rsquo;s Maven Repository Maven Repository 使用服務的工作流為如下
建立連線 等待 callback 連線成功 索取 referrer 關閉連線 Referrer 格式 https://play.</description></item><item><title>Unity - Service - Cloud Diagnostics</title><link>https://HoshikawaRyuukou.github.io/posts/unity-service-cloud-diagnostics/</link><pubDate>Tue, 16 Jan 2024 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-service-cloud-diagnostics/</guid><description>簡述 Official Home Page Official Doc 監控崩潰和異常報告 測試人員和應用使用者能直接提供用戶報告 啟用成本極低且非侵入式 有免費套餐，Personal 常規操作應該是沒問題，一旦超出了免費額度，系統將要求添加付款方式以繼續使用服務 快速上手 Cloud Diagnostics エラーやクラッシュを記録し、バグ特定の手助けになるUnity公式の無料サービス Unity Cloud Diagnostics UnityエディタやUnityで作ったゲームを強制的にクラッシュさせる方法 注意 Apple&amp;rsquo;s privacy survey Google Play data safety disclosures for Cloud Diagnostics</description></item><item><title>Unity - Environment</title><link>https://HoshikawaRyuukou.github.io/posts/unity-environment/</link><pubDate>Tue, 16 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-environment/</guid><description> ⚠️ 以下使用 unity 6
VSCode 移除 Visual Studio Code Editor 已經停止維護 安裝 Visual Studio Editor Edit &amp;gt; Preferences &amp;gt; External Tools &amp;gt; External Script Editor 安裝 .NET Core Extension - C# Dev Kit</description></item><item><title>Unity - Package Manager - Modify A Package</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-modify-a-package/</link><pubDate>Fri, 12 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-modify-a-package/</guid><description>情境 有需要客製化 Unity 官方 / git 直接導入 的 Package 時
操作 至 ProjrctRoot\Library\PackageCache 找到目標的 Package 剪下貼上至 ProjrctRoot\Packages 即可 Ref How can I modify built-in packages? Unity - 如何修改一个 Package 或是如何将 Package Local化</description></item><item><title>Unity - Package Manager - Private GitHub Repository</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-private-github-repository/</link><pubDate>Sun, 24 Dec 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-private-github-repository/</guid><description>情境 想分享私有庫但又不想去更改團隊或人員權限，Github 提供 Fine-Grained Token 能做到客製化的權限控制
操作 至 GitHub &amp;laquo;帳戶設定&amp;raquo;（非儲存庫設定） Developer Settings -&amp;gt; Personal Access Tokens -&amp;gt; Fine-Grained Tokens 生成 Token (Read-Only Permission for the repo Content). &amp;#34;com.yourusername.yourpackage&amp;#34;: &amp;#34;git+https://x-oauth-basic:&amp;lt;token&amp;gt;@&amp;lt;repo&amp;gt;?path=&amp;lt;folder&amp;gt;&amp;#34; Ref Install Unity Package from a private GitHub repository</description></item><item><title>Unity - Package - External Dependency Manager for Unity (EDM4U)</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-external-dependency-manager-for-unity-edm4u/</link><pubDate>Wed, 08 Nov 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-external-dependency-manager-for-unity-edm4u/</guid><description>前言 Google 停止維護 Game Package Registry (GPR) 導致不能直接使用 Package Manager 導入包。必須到封存檔網站下載「.tgz」手動導入。
Google Unity 套件 Install a package from a local tarball file 其他的相關的 Google Service 依賴(AR/Firebase/Google Play等)也可以用此方法導入。
設定 Assets &amp;gt; External Dependency Manager &amp;gt; Android Resolver &amp;gt; Settings 啟用這三個 Patch 並至 Player Settings &amp;gt; Publishing Settings 啟用以下選項 Auto resolution Assets &amp;gt; External Dependency Manager &amp;gt; Android Resolver &amp;gt; Force Resolve 後會去收集專案所有 Editor 資料夾下的 *Dependencies.xml 加到 mainTemplate 中</description></item><item><title>Unity - Basic - Asset Management</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</link><pubDate>Sat, 09 Sep 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</guid><description>AssetBundle Assets, Resources and AssetBundles Case Studies of Unity AssetBundle Efficient Encryption Addressable Frameworks Addressables 是在 AssetBundle 的基礎上對操作進行更友善的封裝，AssetBundle 有很多要小心的地方
AssetBundle 卸載 Addressable System 主要改善幾點
透過 name/label，而是不與資源直接連結，減少因移動或重命名資產而出錯的機會。 本地或是異地都可以追踪。 簡化打包和依賴管理(name/label/group/catalog)。 較好的記憶體管理機制(引用計數)與性能分析系統。 不同 Framework 在常規操作上大同小異，可以從資源最多的 Addressables 做觀念入門
Unity Addressables资源管理方式用起来太爽了，资源打包、加载、热更变得如此轻松（Addressable Asset System | 简称AA） Unity - Addressables项目总结（一）：基础工作流 Unity - Addressables项目总结（二）：业务需求 静态包、动态包有什么区别？何时使用增量更新？Addressables 更新流程大梳理 Repo Addressables tuyoogame/YooAsset Extra 为什么抛弃了 Addressable</description></item><item><title>Unity - Basic - Memory Profiler</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</link><pubDate>Sun, 30 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</guid><description>注意 由於Unity 無法將性能分析器本身佔用的記憶體與運行模式的記憶體完全分開。要獲得應用程序的更精確數字和記憶體使用情況，應在要運行應用程序的目標設備和操作系統上分析應用程序。 如果需要在記憶體受限的平台上運行應用程序，設備上的總駐留量對於檢查低記憶體警告和由於記憶體耗盡而強制關閉非常有用。作為一般規則，它不應超過設備上可用總物理內存的 70%。 偵測 Leaked Managed Shell 的功能在 Memory Profiler 1.1.0-pre.1 Ref Memory Profiler Memory Profiler | 1.1.0-pre.1 - Unity - Manual Unity でメモリリーク？ Memory Profiler で Leaked Managed Shell をチェックしてみよう！ Inspecting memory with the new Memory Profiler package Memory Profiler로 애플리케이션의 물리적 메모리 사용량 분석 Unity内存分析与优化实践(1.1版本前)</description></item><item><title>Unity - Basic - Preprocessor Directives</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-preprocessor-directives/</link><pubDate>Fri, 07 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-preprocessor-directives/</guid><description>前述 中文稱作 : 前置處理器指示詞
筆者最近接觸到的遺舊專案中發現裡面大量地使用 條件式編譯
#if DEBUG Console.WriteLine(&amp;#34;Debug version&amp;#34;); #endif 筆者之前有使用也基本只使用 定義區域 (排版效果)
#region MyClass definition public class MyClass { static void Main(){...} } #endregion Unity 在處理平台裝置時也蠻常會出現的
public class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(&amp;#34;Unity Editor&amp;#34;); #endif #if UNITY_IOS Debug.Log(&amp;#34;iOS&amp;#34;); #endif #if UNITY_STANDALONE_OSX Debug.Log(&amp;#34;Standalone OSX&amp;#34;); #endif #if UNITY_STANDALONE_WIN Debug.Log(&amp;#34;Standalone Windows&amp;#34;); #endif } } 問題 那前置處理器指示詞有什麼問題呢? (參考日文那個 Ref 有比較明確的 Case)
編譯版本至少會是 2^(指示詞的分類數)種，持續的調試和測試變得非常困難。 Unit Test 中難以使用。 編譯檢查不起作用。 當巢狀結構出現時可讀性將大為降低。 上述這些狀況都會導致 延後發現問題的時間 !</description></item><item><title>Unity - Basic - iOS plug-in</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</link><pubDate>Wed, 05 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</guid><description>前述 這次的業務需求是
取得 ios 實機的 &amp;ldquo;地區&amp;rdquo;，並讓 C# 能拿到 Swift 所返回的字串
因為在 ios 的環境下 unity / C# 拿到的值並不正確。此外筆者對 Swift / Objective-C 幾乎零基礎，目前只針對一些教學文件做些修改，之後有機會更熟再回頭深究。
實作 SwiftDeviceInfoPlugin.swift 須放置於 Plugins\iOS 之下 import Foundation public class SwiftDeviceInfoPlugin { public static func getRegion() -&amp;gt; String { return Locale.current.regionCode ?? &amp;#34;Unknown&amp;#34; } } @_cdecl(&amp;#34;getRegion&amp;#34;) public func getRegion() -&amp;gt; UnsafePointer&amp;lt;CChar&amp;gt;? { let region = strdup(SwiftDeviceInfoPlugin.getRegion()) return UnsafePointer(region) } @_cdecl(&amp;ldquo;getRegion&amp;rdquo;)：這是一個 Swift 標記，表示下面的函數將使用cdecl樣式的名稱綁定。您只需知道此屬性向 C 公開了一個 Swift 函數 UnsafePointer&amp;lt;CChar&amp;gt;?，它是一個可為空的指向 C 風格字串（CChar）的指標。這使得 Swift 能夠以與 C 相容的方式提供訪問區域資訊的介面。 strdup() 用於創建預返回的字串的副本，並在堆上分配其記憶體。 public sealed class IOSDeviceInfoProvider : IDeviceInfoProvider { public string GetRegion() { return new System.</description></item><item><title>Unity - Package - xLua</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</link><pubDate>Sun, 28 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</guid><description>本次操作 xLua 主要是做熱更方案的評估測試，筆者目前還是偏好使用 HybridCLR。
Official Tencent/xLua 評估 使用 lua 仍是目前主流/穩定做法 (畢竟也行之有年了)。 邏輯操作可能要移師到 lua 側。 缺少 ide 支援如果要在 lua 側 進行 unity 相關操作時，維護/除錯成本極高。 Example 在 lua 側進行 unity 相關操作
local speed = 10 local lightCpnt = nil function start() print(&amp;#34;lua start...&amp;#34;) print(&amp;#34;injected object&amp;#34;, lightObject) lightCpnt= lightObject:GetComponent(typeof(CS.UnityEngine.Light)) end function update() local r = CS.UnityEngine.Vector3.up * CS.UnityEngine.Time.deltaTime * speed self.transform:Rotate(r) lightCpnt.color = CS.UnityEngine.Color(CS.UnityEngine.Mathf.Sin(CS.UnityEngine.Time.time) / 2 + 0.5, 0, 0, 1) end function ondestroy() print(&amp;#34;lua destroy&amp;#34;) end</description></item><item><title>Unity - Editor - ScriptedImporter</title><link>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</link><pubDate>Sat, 27 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</guid><description>用途 使用C# 為Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。 注意 Scripted Importer 無法處理已由 Unity 本身處理的文件擴展名。 Example 這裡將 .lua 以 TextAsset
using UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, &amp;#34;lua&amp;#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( &amp;#34;text&amp;#34;, subAsset ); ctx.SetMainObject( subAsset ); } } Ref Scripted Importers [Unity] 资源工作流程 - ScriptedImporter</description></item><item><title>Unity - Package Manager - Sample Workflow</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-sample-workflow/</link><pubDate>Sat, 22 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-sample-workflow/</guid><description>Package Samples 對應有些模組的操作比較複雜繁瑣，有時需要有一些 Sample 做參考。官方 Package Manager 有個 &amp;ldquo;半套&amp;rdquo; Sample 工作流，讓人不是很舒服。
官方文件
Sample 資料夾後面加了波浪號 (~) 告訴 Unity 忽略 Samples~ 文件夾中的內容，此類文件夾不使用.meta文件進行跟踪。忽略 Samples~ 對 Package 使用者是好的，畢竟不是每個人都需要。
但對 Package 開發者，畢竟 Samples 也是要進版控的，而這樣改名的作法會徒增一些重命名的提交也有點煩躁(除非在修改 Sample 的過程中完全不提交)。原先想說寫個 Samples ↔ Samples~ 切換的腳本就好，會一直有 meta 檔的警告(刪掉/改名都還是在)。
官方作法 論壇中的某篇討論才記載他們的做法(倒是加到文件中阿&amp;hellip;)
在內部確實使用了名為 Samples 的文件夾 (沒有 Samples~ ) 在推送新包版本之前通過腳本對其進行重命名(透過 CI ) OpenUPM 的作者也是使用類似的工作流，總之筆者也調整為上述的方式。
透過 GitHub Actions Workflow 調整目錄名 筆者不熟 GitHub Actions/ YAML/ 文件操作，但這種初階的操作就交由 chatgpt 代勞，幫我省去不少實驗成本。這裡的操作只是堪用，應該有更好的方式。
以下是筆者要求的條件
想透過 GitHub Actions 中的 workflow 完成 如果 forPackage 分支已存在則將其刪除 從 main 建立新的 forPackage 分支 Assets/Modules 的所有子目錄(同時有 &amp;ldquo;package.</description></item><item><title>Unity - Package - HybridCLR</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</link><pubDate>Tue, 11 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</guid><description>先備知識 Assembly Definition (Asmdef) Unity 2017.3 以上版本的提供功能，主要解決龐大的程序集編譯時效率問題。
具體內容建議閱讀 Doc - Assembly definitions
Assembly-CSharp.dll Unity 預設整合的 dll，專案內未被自定義 Asmdef 劃分的腳本都會被整合到 Assembly-CSharp.dll
簡述 HybridCLR focus-creative-games/hybridclr focus-creative-games/hybridclr_trial HybridCLR 筆者已經應用於工作環境好一陣子了(從 2.X 版本開始)，其最讓人驚豔的地方在於，過往的開發流幾乎不用更動(當然要好 Asmdef 的規劃)，僅在打包時調整一下工作流即可。
其極大簡化過往麻煩且效率不彰的熱更流程。xLua 和 ILRuntime 在筆者看來最難受的事是「侵入性」極強，搞得綁手綁腳。大家也都抱怨很久了，但也沒有其他可靠方案，直到 HybridCLR 出現。
快速上手 3.0 版本後流程優化得更順暢了，照著 文件 可以很快地感受到其威力。
注意 请问，Generate All、补充元数据的DLL更新的执行时机的最佳实践？ 怎么卸载热更dll CLI 規範中只能以 AppDomain 形式卸載所有 dll，不支持卸載單獨的 dll。而 il2cpp 是單例 AppDomain，因此這個要求是不符合規範的。要採用 HybridCLR DHE 的商業方案。不過筆者倒是不太擔心，畢竟 Unity client 通常不是需要常駐的應用，使用者也不太會把應用的每一個功能都點一遍，初估是還可以接受的。</description></item><item><title>Unity - Basic - DontDestroyOnLoad</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</link><pubDate>Mon, 20 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</guid><description>用例 被標記為 DontDestroyOnLoad 的物件場景更改時不會被破壞。
全域管理器：因為整個遊戲期間一直存在。例如，音效管理器、遊戲設定管理器或玩家數據管理器等物件可以在場景切換時保留，以確保它們的功能和數據在各個場景中持續存在。 持久性數據：如果你有需要在多個場景中共享的持久性數據，可以將存儲這些數據的物件標記為 DontDestroyOnLoad。例如，玩家的遊戲進度或全域的配置設置等數據可以在場景切換時保留，以便在不同場景中訪問和更新。 UI 元素：某些UI元素，如遊戲狀態面板、計時器或得分顯示，可能需要在多個場景中保留。通過將這些UI元素物件標記為 DontDestroyOnLoad，可以確保它們在場景切換時不會被銷毀，以便在不同場景中持續顯示和更新。 問題 記憶體管理問題：使用 DontDestroyOnLoad 將遊戲物件保留在多個場景中可能會導致記憶體洩漏。如果你的遊戲物件不再需要，但沒有被正確銷毀，它們將繼續存在於記憶體中，佔用系統資源，可能導致性能下降。 場景管理問題：DontDestroyOnLoad 會打破場景之間的清晰界限。場景是 Unity 中組織和管理遊戲邏輯的基本單位，每個場景都應該是相對獨立的。通過在多個場景之間保持物件，會增加場景之間的耦合性，導致代碼難以維護和測試。 Ref Object.DontDestroyOnLoad</description></item><item><title>Unity - WorkFlow - Build &amp; Publish</title><link>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</link><pubDate>Mon, 27 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</guid><description>Build repositories.cfg could not be loaded. Unable to find player assembly: XXXX\Temp\StagingArea\Data\Managed\UnityEngine.TestRunner.dll Cocoapodsの更新にハマった【Unity】 Device Quickly preview your game on Android device | Unity tutorial Publish Privacy policy for your game? No problem! (generate and publish) Publish your UNITY game on Google Play Store - 2023 guide Misc Library not loaded: @rpath/FBAEMKit.framework/FBAEMKit</description></item><item><title>Unity - Basic - Sprite and Atlas</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</guid><description>Sprite 【2Dゲームで必須】UnityのSprite（スプライト）の単位をわかりやすく解説 【間違えやすい】Unityの正しい画像サイズとは Atlas 【Unity】SpriteをパックするSpriteAtlasの使い方 目的 減少DrawCall 圖集將圖片打包為2的冪次方的素材大小，可以提升性能 減小包體大小 注意 Sprite Atlas V1 - Always Enabled 啟用圖集時 Edit Mode : reference the packed Textures Play Mode : reference the original unpacked Textures SpriteAtlas AssetBundle 來打包時，不要勾選 Include In Build</description></item><item><title>Unity - Basics</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basics/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basics/</guid><description>Set Up 【游戏开发环境】Unity使用Mac电脑开发，开发环境的搭建（Mac mini M1 | VSCode | Git | 好用工具） Analysis Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Animation Introduction to 3D Animation Systems Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity Build repositories.cfg could not be loaded. unity Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Canvas Designing UI for Multiple Resolutions Unity Canvas Scaler 组件的使用 Unity分辨率适配方案设置 Editor 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them?</description></item><item><title>Unity - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/unity-sites/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-sites/</guid><description>Blog Yucchiy&amp;rsquo;s Note コガネブログ 老刘@开发笔记 (:3[kanのメモ帳] Game Dev Beginner - Everyone Can Make Games LIGHT11 PG日誌 きゅぶろぐ やらなイカ？ はなちるのマイノート くものす ピクセルブログ ねこじゃらシティ YAMADA TAISHI’s diary L&amp;rsquo;s Blog Raspberlyのブログ 渋谷ほととぎす通信 LianBai Lightjiao的博客 unityでいってみよう！ 偵錯桐人 - unity Blog (Enterprise) CyberAgent Developers Blog | サイバーエージェント デベロッパーズブログ REALITY｜note Mirrativ Tech Blog QualiArtsエンジニアブログ Channel Code Monkey M Studio Coco Code Collection XINCGer/Unity3DTraining Forum Qiita|Unity Zenn|Unity Unity Learning Materials Unity3d - 幻想社区 「unity」の人気の記事一覧｜note Unityゲーム開発者ギルド Events Unity Meetup Unity Advent Calendar Unityユースクリエイターカップ Community unityroom</description></item></channel></rss>