<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Performance on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/performance/</link><description>Recent content in Performance on 識之箱庭</description><generator>Hugo</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Wed, 05 Feb 2025 21:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/performance/index.xml" rel="self" type="application/rss+xml"/><item><title>Unity - Performance - Render - Overdraw</title><link>https://HoshikawaRyuukou.github.io/posts/unity---performance---render---overdraw/</link><pubDate>Wed, 05 Feb 2025 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity---performance---render---overdraw/</guid><description>&lt;h2 id="quick-chat">Quick Chat&lt;/h2>
&lt;p>Overdraw 就是 &lt;strong>「同一個像素點被繪製多次」&lt;/strong>，當 Unity 把一個畫面繪製出來時，所有 Sprite 都是 &lt;strong>從後到前（Back to Front）&lt;/strong> 疊加上去。如果某個像素被重複繪製了很多次，GPU 的工作量就會變大，導致 &lt;strong>效能下降&lt;/strong>。&lt;/p>
&lt;h2 id="cases">Cases&lt;/h2>
&lt;h3 id="大量重疊的透明-sprite">大量重疊的透明 Sprite&lt;/h3>
&lt;ul>
&lt;li>2D 遊戲裡很多元素是有 &lt;strong>透明區域（Alpha 通道）&lt;/strong> 的，例如 UI、特效、光影效果。&lt;/li>
&lt;li>GPU 必須計算這些透明度，並且疊加不同圖層的顏色，這個過程很吃資源。&lt;/li>
&lt;/ul>
&lt;h3 id="過多的粒子--特效">過多的粒子 &amp;amp; 特效&lt;/h3>
&lt;ul>
&lt;li>如果妳的遊戲有超多粒子特效，特別是 &lt;strong>煙霧、火焰、閃光&lt;/strong> 這種會有大量透明像素的元素。&lt;/li>
&lt;/ul>
&lt;h3 id="大範圍透明圖">大範圍透明圖&lt;/h3>
&lt;ul>
&lt;li>例如 UI 設計時，一個按鈕可能只是中間一小塊有圖案，但它的整張貼圖是 512 x 512 的 PNG，外圍全是透明的區域，這樣就會讓 GPU 花額外的時間去計算透明像素，而不是有效渲染有內容的部分。&lt;/li>
&lt;/ul>
&lt;h3 id="畫面排序導致重複繪製">畫面排序導致重複繪製&lt;/h3>
&lt;ul>
&lt;li>Unity 會根據 &lt;code>Sorting Layer&lt;/code> 和 &lt;code>Order in Layer&lt;/code> 來決定渲染順序。&lt;/li>
&lt;li>如果物件排序不合理，可能會讓後面的 Sprite 被前面的遮住，但 GPU 還是得先畫出來，結果白白浪費效能。&lt;/li>
&lt;/ul>
&lt;h2 id="debug">Debug&lt;/h2>
&lt;h3 id="unity-內建了檢測工具">Unity 內建了檢測工具&lt;/h3>
&lt;ol>
&lt;li>打開 &lt;strong>Scene 視圖&lt;/strong>&lt;/li>
&lt;li>點擊 &lt;strong>Shading Mode&lt;/strong>&lt;/li>
&lt;li>選擇 &lt;strong>Overdraw Mode&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h3 id="overdraw-視覺化顯示方式">Overdraw 視覺化顯示方式&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>藍色 / 黑色&lt;/strong> → 幾乎沒問題&lt;/li>
&lt;li>&lt;strong>綠色 / 黃色&lt;/strong> → 有點 Overdraw，但還能接受&lt;/li>
&lt;li>&lt;strong>紅色 / 白色&lt;/strong> → 🚨 過度繪製嚴重，GPU 負擔大，要優化了！&lt;/li>
&lt;/ul>
&lt;h2 id="optimization">Optimization&lt;/h2>
&lt;h3 id="減少透明區域">減少透明區域&lt;/h3>
&lt;ul>
&lt;li>盡量 &lt;strong>縮小 Sprite 的實際範圍&lt;/strong>，不要讓透明區域過大。&lt;/li>
&lt;li>例如 UI 按鈕的 Sprite，最好裁剪成 &lt;strong>剛好包住可見部分&lt;/strong>，而不是整張 512x512 貼圖全都透明。&lt;/li>
&lt;/ul>
&lt;h3 id="善用-sprite-packing圖集">善用 Sprite Packing（圖集）&lt;/h3>
&lt;ul>
&lt;li>把小圖合併成 &lt;strong>Sprite Atlas&lt;/strong>，讓 GPU 少做一些不必要的切換，提高效率。&lt;/li>
&lt;/ul>
&lt;h3 id="減少畫面重疊的透明圖層">減少畫面重疊的透明圖層&lt;/h3>
&lt;ul>
&lt;li>UI 設計時，盡量讓按鈕、圖示等 &lt;strong>不要有過多重疊&lt;/strong>。&lt;/li>
&lt;li>如果 UI 有半透明背景，可以嘗試改用 &lt;strong>單一大圖片代替多個小圖片疊加&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="控制粒子數量">控制粒子數量&lt;/h3>
&lt;ul>
&lt;li>降低粒子數量&lt;/li>
&lt;li>縮小粒子範圍&lt;/li>
&lt;li>減少透明度計算（調整 Shader）&lt;/li>
&lt;/ul>
&lt;h3 id="改善-sorting-order">改善 Sorting Order&lt;/h3>
&lt;ul>
&lt;li>避免&lt;strong>不必要的遮擋運算&lt;/strong>，如果一個物件永遠會被其他東西蓋住，考慮 &lt;strong>改變它的 Sorting Layer&lt;/strong>，甚至在不必要時直接&lt;strong>不渲染它&lt;/strong>（SetActive(false)）。&lt;/li>
&lt;/ul>
&lt;h3 id="使用-shader-優化透明渲染">使用 Shader 優化透明渲染&lt;/h3>
&lt;ul>
&lt;li>如果 Sprite &lt;strong>不需要半透明效果&lt;/strong>，可以換成 &lt;strong>Opaque Shader（不透明著色器）&lt;/strong>，這樣 GPU 就不會計算透明度疊加。&lt;/li>
&lt;/ul>
&lt;h3 id="改用-tilemap">改用 Tilemap&lt;/h3>
&lt;ul>
&lt;li>如果遊戲是 2D 地圖類型（像素風格、平面地圖等），可以用 Unity &lt;strong>Tilemap&lt;/strong> 來減少 Overdraw，因為 Tilemap 會幫妳合併小區塊來優化繪製。&lt;/li>
&lt;/ul></description></item><item><title>Unity - Performance - Memory Profiler</title><link>https://HoshikawaRyuukou.github.io/posts/unity---performance---memory-profiler/</link><pubDate>Sun, 30 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity---performance---memory-profiler/</guid><description>&lt;h2 id="注意">注意&lt;/h2>
&lt;ul>
&lt;li>由於Unity 無法將性能分析器本身佔用的記憶體與運行模式的記憶體完全分開。要獲得應用程序的更精確數字和記憶體使用情況，應在要運行應用程序的目標設備和操作系統上分析應用程序。&lt;/li>
&lt;li>如果需要在記憶體受限的平台上運行應用程序，設備上的總駐留量對於檢查低記憶體警告和由於記憶體耗盡而強制關閉非常有用。作為一般規則，它不應超過設備上可用總物理內存的 70%。&lt;/li>
&lt;li>偵測 Leaked Managed Shell 的功能在 Memory Profiler 1.1.0-pre.1&lt;/li>
&lt;/ul>
&lt;h2 id="ref">Ref&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.0/manual/index.html">Memory Profiler&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/managed-shell-objects.html">Memory Profiler | 1.1.0-pre.1 - Unity - Manual&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UIwQmpQTtA4">Unity でメモリリーク？ Memory Profiler で Leaked Managed Shell をチェックしてみよう！&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.unity.com/engine-platform/inspecting-memory-with-the-new-memory-profiler-package">Inspecting memory with the new Memory Profiler package&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://unitysquare.co.kr/growwith/unityblog/webinarView?id=387&amp;amp;utm_source=facebook-page&amp;amp;utm_medium=social&amp;amp;utm_campaign=korea_memoryprofilerapp387">Memory Profiler로 애플리케이션의 물리적 메모리 사용량 분석&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/Nbin_Newby/article/details/131537227">Unity内存分析与优化实践(1.1版本前)&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>