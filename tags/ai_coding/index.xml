<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AI_Coding on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/ai_coding/</link><description>Recent content in AI_Coding on 識之箱庭</description><generator>Hugo</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Fri, 24 Oct 2025 11:41:40 +0800</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/ai_coding/index.xml" rel="self" type="application/rss+xml"/><item><title>AI Coding - Spec-Driven Development (SDD)</title><link>https://HoshikawaRyuukou.github.io/posts/ai-coding---spec-driven-development-sdd/</link><pubDate>Fri, 24 Oct 2025 11:41:40 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-coding---spec-driven-development-sdd/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;首先，&lt;strong&gt;規格驅動開發（SDD）並非在 AI 程式碼生成技術出現後才被提出&lt;/strong&gt;，它是一個早已存在的概念。&lt;/p&gt;
&lt;p&gt;然而，在當前環境下，SDD 重新受到關注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;成本驟降&lt;/strong&gt;：AI 的輔助極大地降低了編寫高品質規格文件的成本和時間。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解決困境&lt;/strong&gt;：業界普遍遭遇「Vibe Coding」（憑感覺、缺乏規範的開發）所帶來的維護性和協作性困境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回歸檯面&lt;/strong&gt;：市場開始追求更嚴謹、更有規範的寫作方式，使規格驅動開發重新成為主流討論。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我首次被這個概念震撼，是在 &lt;strong&gt;Kiro IDE&lt;/strong&gt; 的演示中。儘管 Kiro 以搶先體驗（Early Access）方式開放，許多開發者無法接觸（需要邀請碼），但這反而間接促成了開源社群的迅速響應。如今，相關工具如雨後春筍般出現，&lt;strong&gt;Kiro 似乎已丟失了先發優勢&lt;/strong&gt;。😂&lt;/p&gt;
&lt;h2 id="guide"&gt;Guide&lt;/h2&gt;
&lt;p&gt;⚠️ 建議讀者著重理解這些資源所闡述的&lt;strong&gt;核心設計思路&lt;/strong&gt;，而非具體的技術實現，因為相關的工具與生態系統正在快速變化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/github/spec-kit/blob/main/spec-driven.md"&gt;spec-kit/spec-driven.md at main · github/spec-kit · GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.blog/ai-and-ml/generative-ai/spec-driven-development-using-markdown-as-a-programming-language-when-building-with-ai/"&gt;Spec-driven development: Using Markdown as a programming language when building with AI - The GitHub Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://martinfowler.com/articles/exploring-gen-ai/sdd-3-tools.html"&gt;Understanding Spec-Driven-Development: Kiro, spec-kit, and Tessl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;SDD 的核心在於&lt;strong&gt;顛覆軟體開發的傳統權力結構&lt;/strong&gt;，並將 &lt;strong&gt;規格說明書（Specification）&lt;/strong&gt; 提升為開發過程的 &lt;strong&gt;核心真理來源 (Source of Truth)&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;權力翻轉&lt;/strong&gt;：規格說明書不再是服務程式碼的附屬文件，而是&lt;strong&gt;程式碼必須服務規格說明書&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真理來源&lt;/strong&gt;：產品需求文件（PRD）不再僅是實作的&lt;strong&gt;指南&lt;/strong&gt;，而是&lt;strong&gt;生成實作的源頭&lt;/strong&gt;。技術規格成為精確的定義，可以直接&lt;strong&gt;驅動程式碼的生成&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消除鴻溝&lt;/strong&gt;：SDD 透過使規格說明及其具體的實作計畫&lt;strong&gt;可執行化 (Executable)&lt;/strong&gt;，從而&lt;strong&gt;消除了規格說明與實際程式碼之間的鴻溝&lt;/strong&gt;。當規格說明直接生成程式碼時，這不再是手動實作，而是一個&lt;strong&gt;純粹的轉化 (Transformation) 過程&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="thinking"&gt;Thinking&lt;/h2&gt;
&lt;p&gt;在採用 SDD 之前，我們需要先自問：&lt;strong&gt;你是否希望在一個完全由 AI 主導的結構中工作，每次迭代都只透過修改文件來完成？&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>AI Coding - SDD - OpenSpec</title><link>https://HoshikawaRyuukou.github.io/posts/ai-coding---sdd---openspec/</link><pubDate>Fri, 17 Oct 2025 14:12:33 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-coding---sdd---openspec/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;在使用 OpenSpec 進行開發的體驗相當不錯，我認為原作者的設計理念解決了許多團隊在導入 AI 協作時的痛點。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OpenSpec 的核心優勢：&lt;/strong&gt; 它極其擅長管理&lt;strong&gt;既有功能的變更 (1→n)&lt;/strong&gt;。 OpenSpec 是一個&lt;strong&gt;輕量級&lt;/strong&gt;的框架，無需 API 金鑰即可輕鬆整合到現有專案中，不需從頭來過。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;現有工具的痛點：&lt;/strong&gt; 許多工具如 &lt;code&gt;spec-kit&lt;/code&gt; 或 &lt;code&gt;Kiro&lt;/code&gt; 在處理&lt;strong&gt;從零到一 (0→1) 的全新專案&lt;/strong&gt;時表現非常出色。 然而，當專案進入維護與迭代階段，需要持續更新和管理不斷演進的「規格文件」時，這些工具就顯得力不從心。它們的結構在追蹤「系統當前狀態」以及「即將發生的變更」時，往往不夠直觀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清晰的檔案結構：&lt;/strong&gt; OpenSpec 透過簡單的雙資料夾結構，讓規格與變更的管理一目了然，有效地將「事實的根源」與「進行中的提案」分開：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;specs/&lt;/code&gt; → &lt;strong&gt;系統的當前狀態&lt;/strong&gt;：存放目前系統的規格，是團隊與 AI 的共同認知基礎。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;changes/&lt;/code&gt; → &lt;strong&gt;進行中的變更&lt;/strong&gt;：所有新的功能需求或修改都會在這裡以獨立的資料夾進行，包含提案、任務列表與規格草案。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;archive/&lt;/code&gt; → &lt;strong&gt;已完成的變更歷史&lt;/strong&gt;：所有已合併的變更都會被移至此處，成為一份「活文件」，記錄系統的演進歷程。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="guide"&gt;Guide&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Fission-AI/OpenSpec"&gt;GitHub - Fission-AI/OpenSpec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=ANjiJQQIBo0"&gt;開發者福音！用 AI 迭代現有專案？OpenSpec 讓 AI 按規範寫程式碼，零失誤！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一位開發者的使用心得分享，原作者也在評論區參與了討論，提供了更多有趣的見解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=cQv3ocbsKHY"&gt;I Found the Simplest AI Dev Tool Ever&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="workflow"&gt;Workflow&lt;/h2&gt;
&lt;p&gt;這個流程確保了人類開發者與 AI 之間能夠進行順暢且可控的協作，在 AI 動手寫程式碼&lt;strong&gt;之前&lt;/strong&gt;，就先對齊目標。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;起草變更提案 (Draft Change Proposal)：&lt;/strong&gt; 開發者向 AI 提出一個新的功能需求或變更請求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;審查與對齊 (Review &amp;amp; Align)：&lt;/strong&gt; AI 會根據你的請求生成詳細的規格與任務列表。開發者此時可以審查、提出修改意見，AI 會再根據回饋更新，形成一個&lt;strong&gt;反覆回饋的循環&lt;/strong&gt;，直到雙方對「要做什麼」與「如何做」達成共識。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;執行任務 (Implement Tasks)：&lt;/strong&gt; AI 依據最終拍板定案的規格與任務列表，開始進行程式碼的編寫。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;套用變更 (Apply the Change)：&lt;/strong&gt; 開發者審查 AI 生成的程式碼，確認無誤後，執行指令將程式碼合併到專案中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封存與更新 (Archive &amp;amp; Update Specs)：&lt;/strong&gt; 變更完成後，該次的變更紀錄會被完整地「封存」到 &lt;code&gt;archive/&lt;/code&gt; 資料夾，同時更新 &lt;code&gt;specs/&lt;/code&gt; 中的主要規格文件，確保規格文件永遠處於最新狀態，為下一次的變更做好準備。&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Gemini - Google AI Studio</title><link>https://HoshikawaRyuukou.github.io/posts/gemini---google-ai-studio/</link><pubDate>Wed, 15 Oct 2025 15:17:27 +0800</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/gemini---google-ai-studio/</guid><description>&lt;h2 id="quick-chat"&gt;Quick Chat&lt;/h2&gt;
&lt;p&gt;Google AI Studio 是 Google 推出的線上平台，主要定位在協助開發者、學生與研究人員快速試用 &lt;strong&gt;Gemini 模型&lt;/strong&gt;，並透過 &lt;strong&gt;Gemini Developer API&lt;/strong&gt; 來建立原型或應用程式。&lt;/p&gt;
&lt;p&gt;與一般的 Gemini 應用（像 ChatGPT 類型的介面）相比，AI Studio 提供了更多的 &lt;strong&gt;免費額度&lt;/strong&gt;，對想要動手實驗 Gemini 功能的人來說相當友善。&lt;/p&gt;
&lt;h2 id="guide"&gt;Guide&lt;/h2&gt;
&lt;h3 id="chat"&gt;Chat&lt;/h3&gt;
&lt;p&gt;常用的控制項包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Grounding with Google Search&lt;/strong&gt;：可在回答前透過 Google 搜尋補強資訊，使回覆更準確。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL context&lt;/strong&gt;：可將指定連結內容作為上下文，讓回答更貼近指定網頁的資訊。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="build"&gt;Build&lt;/h3&gt;
&lt;p&gt;這個區域能將「文字提示」轉化為可執行的 Web 應用程式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Vibe Coding&lt;/strong&gt; 功能在開發簡單原型或概念驗證（PoC）時相當好用。&lt;/li&gt;
&lt;li&gt;不過在進行功能迭代時，有時會導致整個結構被重新生成 😂。&lt;/li&gt;
&lt;li&gt;若只是開發「自用型」應用程式（不綁 API Key），頂多遇到免費流量上限就無法繼續使用；&lt;/li&gt;
&lt;li&gt;若要分享或部署給他人，則需要考慮 &lt;strong&gt;API 使用費用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前開發了幾個小應用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gemini 圖片翻譯器：使用 Gemini 翻譯圖片而不是 Google Translate。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="notice"&gt;Notice&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;若開啟歷史紀錄功能，AI Studio 的紀錄會自動儲存在 &lt;strong&gt;Google Drive&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;由於目前平台 &lt;strong&gt;未提供批次刪除功能&lt;/strong&gt;，若想清空紀錄，必須手動至 Google Drive 操作。&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>