<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Monorepo on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/tags/monorepo/</link><description>Recent content in Monorepo on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Sun, 06 Oct 2024 20:31:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/tags/monorepo/index.xml" rel="self" type="application/rss+xml"/><item><title>Workflow - Create a monorepo with pnpm workspace</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-create-a-monorepo-with-pnpm-workspace/</link><pubDate>Sun, 06 Oct 2024 20:31:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-create-a-monorepo-with-pnpm-workspace/</guid><description>Guide Monorepo与pnpm：前端项目管理的完美搭档 为什么 pnpm+monorepo 是组件库项目的最佳实践 Monorepo？來聊聊另一種專案管理架構吧！ 从npm版本依赖到Monorepo大仓项目 MonoRepo实战：pnpm+nx搭建MonoRepo项目 Create a monorepo using PNPM workspace 从构建到发布：Monorepo 的最佳实践 TSTemplateMonorepo 專案基本結構 project-root/ # 專案根目錄 ├── pnpm-workspace.yaml # pnpm 的工作區配置文件，用來定義哪些資料夾屬於工作區範圍 ├── package.json # 專案的全局配置文件，通常包括依賴、腳本和項目元數據 └── packages/ # 所有子包的資料夾，存放具體的子項目 ├── pkg01/ # 子包01，包含它自己的 package.json 文件和代碼 └── pkg02/ # 子包02，與 pkg01 結構相似，也擁有自己的 package.json 和代碼 新增 專案內全局配置 ./package.json # 產生一個基本的 package.json pnpm init monorepo 的全局 package.json 設置 &amp;quot;private&amp;quot;: true { &amp;#34;private&amp;#34;: true, } 新增 工作區配置文件 ./pnpm-workspace.yaml 該檔案聲明這是一個 Monorepo 專案。 pnpm install 自動安裝所有 package 的相依套件。 packages 字段列出了工作區包含的 package 位置。 工作區下的 package 會有各自的 package.</description></item><item><title>Software Development - Repository Structure</title><link>https://HoshikawaRyuukou.github.io/posts/software-development-repository-structure/</link><pubDate>Mon, 12 Aug 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-development-repository-structure/</guid><description>Quick Chat 最近筆者在開發公司的共用套件時，踩了不少坑，尤其是在儲存庫結構方面。
最初選擇了 polyrepo 的結構，但隨著開發的進展，碰到了一些問題：
要確保這些獨立的 repo 配置能夠同步。 每次發佈都需要逐一更新每個套件，尤其是那些有兩三層依賴的，讓發佈變得非常繁瑣。 進行 code review 時，還要不停地在不同 repo 之間切換。 為了改善這些問題，開始研究 monorepo 的結構：
使用 pnpm workspace 來構建。 雖然 monorepo 有一些權限控管的隱憂，但因為共用套件的開發人數不多，所以目前還不用太擔心協作上的衝突。 Guide monorepo-vs-polyrepo 你很常聽到 monorepo，但為什麼要用 monorepo? Monorepo Managing a full-stack, multipackage monorepo using pnpm Live types in a TypeScript monorepo Building a Typescript + NodeJS Monorepo in 2024 特色 👍 package 使用相同版本 依賴/設定檔/風格。 ⚠️ package 權限控管需仰賴其他工作流。</description></item></channel></rss>