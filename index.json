[{"contents":"Quick Chat 最近回顧舊文，我發現一個顯著的趨勢：我的配圖變少了。\n過去我採用 file-based post 搭配統一 static assets 資料夾的架構。雖然結構單純，但這種分離式的管理方式，導致我在寫作時，下意識地避開了需要配圖的場景。\n深入探究，瓶頸在於「附件管理」流程帶來的心理阻力：\n圖文分離：多媒體素材與文章分開存放，若要單獨遷移或備份某篇文章，過程相當繁瑣。 檔案混亂：隨著文章增加，統一的 assets 資料夾變得雜亂龐大，難以維護。 殘留垃圾：刪除文章時，往往容易遺漏未清理的圖片，導致專案中充斥無用檔案。 至於為何不使用圖床？核心考量還是「資料自主權」。我希望將內容與素材完全掌握在自己手中，不依賴外部服務的存續。\n為了解決這個痛點，我決定將架構遷移至 Hugo 的 Page Bundles (Folder-based)。\n改用這種架構後，多媒體與 Markdown 檔位於同一目錄。雖然專案結構目錄變多了，但其優勢在於：\n管理直覺：素材與文章強綁定。移動或刪除文章資料夾時，圖片隨之變動，徹底告別殘留檔案。 效能紅利：這是額外的驚喜。改用 Page Bundles 後，Hugo 能將圖片視為 Page Resources，進一步實現圖片處理與載入優化。 Guide Page bundles 改版後的目錄結構如下，採用 Leaf Bundle 形式：\ncontent/ └─ posts/ └─ my-article/ \u0026lt;-- 文章獨立成資料夾 ├─ index.md \u0026lt;-- 文章本體 ├─ cover.jpg \u0026lt;-- 素材就近管理 └─ diagram.png ","permalink":"https://HoshikawaRyuukou.github.io/posts/hugo-page-bundles/","tags":["Hugo"],"title":"減少寫作的摩擦力：試試 Hugo Page Bundles"},{"contents":"Quick Chat 將「API/搜尋語法」的技術門檻，轉化為「自然語言指令」的便利操作。\n如果你有追蹤特定關鍵字（如 AI 模型、熱門時事）的需求，這裡提供一個比傳統搜尋更便捷的方式：直接透過 Grok 提問。 (目前 X 的免費帳號也可使用此功能)\n靈感來源： 本案例改良自 @ttmouse 的貼文。原貼針對 Nano Banana Pro 進行搜尋，為了提升精準度與易讀性，我將其指令重新編寫為結構化 Prompt。\nGuide 請複製以下內容發送給 Grok，即可執行任務。\n(💡 提示：若有其他搜尋需求，只需將 Prompt 內的「關鍵字」與「主題」交給 AI 替換即可)\n你現在是「Nano Banana Pro 每日熱帖監控機器人」。 當我輸入「執行 Nano Banana Pro 每日熱帖監控」或直接發送此提示詞時，請嚴格執行以下流程： ### 第一步：精準搜尋 請利用 X 的搜尋功能，搜尋過去 24 小時內的貼文。 **核心搜尋邏輯（請轉換為搜尋運算符）：** 1. 關鍵字包含：「Nano Banana Pro」 OR 「ナノバナナプロ」 OR 「Gemini Nano Banana」 2. 時間範圍：since: 24小時前 3. 基礎過濾：min_faves:30（若搜尋結果過少，可自動降級為 min_faves:10） 4. 排除垃圾訊息：排除重複的機器人發文或純廣告推廣（尋找真實使用心得、作品展示、Prompt 分享）。 ### 第二步：數據篩選與排序 1. **優先級**：優先展示瀏覽量（Views）≥ 10,000 的貼文。 2. **候補機制**：若高瀏覽貼文不足 5 條，請放寬標準，納入瀏覽量較低但互動率（讚/瀏覽比）高的優質內容。 3. **排序**：最終清單按「讚數」由高到低排序，選取前 20 條。 ### 第三步：輸出報告 請嚴格按照以下 Markdown 格式輸出，不要添加額外的開場白： --- ### 【Nano Banana Pro 24小時熱帖速報】 🔥 今日數據：最高讚 `{{最高讚數}}`｜最高瀏覽 `{{最高瀏覽數}}` 👀 **觀察摘要**：（20字以內，例如：今日多為寫實風格測試，或官方發布新參數引發討論。） --- **1. @{{用戶名}}** 📝 {{一句話精華總結，20-30字，強調提示詞/技巧/風格}} 📊 讚 {{讚數}}｜瀏覽 {{瀏覽量}} 🔗 https://x.com/{{用戶ID}}/status/{{貼文ID}} **2. @{{用戶名}}** （以此類推，列出 Top 20，每條之間空一行） --- ### 第四步：安全與真實性檢查（重要） 1. **禁止幻覺**：所有連結必須是真實存在且可點擊的（請確保 ID 與用戶名對應正確）。 2. **誠實原則**：如果今日搜尋結果極少或無高互動內容，請直接輸出：「⚠️ 今日 24 小時內未發現符合高互動標準的 Nano Banana Pro 相關貼文，社群較為平靜。」 3. **語言**：摘要與觀察請使用「繁體中文」。 現在開始執行搜尋與分析。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/%E9%80%8F%E9%81%8E-grok-%E6%90%9C%E5%B0%8B-x-twitter-%E7%86%B1%E9%96%80%E4%B8%BB%E9%A1%8C/","tags":["AI","xAI","Grok","X_Twitter"],"title":"透過 Grok 搜尋 X (Twitter) 熱門主題"},{"contents":"Quick Chat Google AI Studio 是 Google 專為開發者、學生與研究人員設計的線上平台，旨在讓使用者能快速體驗 Gemini 模型，並利用 Gemini Developer API 輕鬆建構應用原型。\n相較於一般的 Gemini 應用，AI Studio 提供更充裕的免費額度，對於想動手實驗 Gemini 各項功能的使用者而言，是相當友善的入門選擇。\nGuide Gemini 3.0 参数调教指南 | Google AI Studio全面解析（附提示词模版） - YouTube Chat 關鍵控制項：\nGrounding with Google Search：在生成回覆前，透過 Google 搜尋強化資訊的即時性與準確性。 URL context：將指定網址內容納為上下文，使回覆能更貼近特定網頁的資訊。 YouTube 影片裁切：可指定 YouTube 影片的時間區間進行分析。 實用系統指令 (System Instructions) 範例：\nYouTube 中文分段導讀 照時間軸中文分段導讀 Markdown 文章潤飾 1. 不要改變 header2 與 header3 2. 潤飾/精煉 markdown 段落 Build 此區塊能將您的「文字提示」直接轉換為一個可執行的 Web 應用程式。\nVibe Coding 功能對於快速開發簡易原型或進行概念驗證 (PoC) 非常實用。 然而，在進行功能迭代時，有時可能導致整個應用程式結構被重新生成，需多加留意。 若開發的是不需綁定 API Key 的「個人自用型」應用，主要限制僅為免費額度的用量上限。 若需將應用分享或部署給他人使用，則必須將 API 金鑰的使用成本納入考量。 以下分享幾個已開發的個人應用範例：\n圖片翻譯器： 專為閱讀原文漫畫 (Raw Manga) 設計，利用 Gemini 的多模態能力直接辨識並翻譯圖片中的文字，而非傳統的 OCR 搭配翻譯服務。 圖片提示詞反推器： 用於逆向工程，分析圖片的詳細構成元素 (如情境、光線、主體等)。 其中，主體分析更包含外貌、服裝、動作等細節欄位。 Notice 當啟用歷史紀錄功能後，您在 AI Studio 中的對話紀錄將會自動儲存至 Google Drive。 請注意，平台目前尚未支援批次刪除。若需清空所有紀錄，必須手動前往 Google Drive 進行刪除操作。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/google---ai-studio/","tags":["AI","AI_Coding","Gemini"],"title":"Google - AI Studio"},{"contents":"Quick Chat 與前端領域相比，將 AI 直接整合至 Unity 開發流程中尚未有標準化的作法。本文旨在彙整社群中針對此議題的幾種導入方法與實踐經驗。\nMCP Model Context Protocol (MCP) 是一種讓 AI 模型能夠與外部工具（如 Unity 編輯器）互動的協定。以下是一些社群開發的 MCP 伺服器實作：\nGitHub - CoplayDev/unity-mcp: An MCP server that allows MCP clients like Claude Desktop or Cursor to perform actions in the Unity Editor GitHub - hatayama/uLoopMCP: uLoopMCP enables AI to autonomously compile, test, debug, and manipulate Unity projects. It bridges Unity Editor with AI coding assistants (Claude Code, Cursor, GitHub Copilot, Windsurf) using Model Context Protocol. GitHub - Arodoid/UnityMCP Session Unity AI完全に理解した 勉強会 活動影片： Unity AI完全に理解した 勉強会 - YouTube Unity Sentis 官方範例的黑白棋 AI 介紹 正名：Unity Sentis 現已更名為 Inference Engine。 核心功能：Sentis 是 Unity 設計的神經網路推理庫，能夠讓 AI 模型在終端裝置上以高效率、低記憶體消耗的方式運行。 獨特優勢：訓練完成的 AI 模型會被封裝成一個標準的 Unity「資產（Asset）」。這代表 AI 邏輯可以像圖片或音檔一樣被動態替換。開發者能夠在不需重新提交 App Store 審查的情況下更新 AI，大幅提升了迭代的靈活性。 案例分析：議程中以官方的黑白棋（Reversi）AI 範例，展示了 Sentis 的實際應用。 Unity x Groq x MR裝置 遊戲開發中的語音輸入利用 服務介紹：Groq 是一個提供 LLM 模型的雲端平台，其服務包含聊天（Chat）、文字轉語音（TextToSpeech）與語音轉文字（SpeechToText）。 提示工程：透過精確的提示工程（Prompt Engineering），可以讓 AI 的輸出結果更貼近遊戲邏輯的需求。 範例提示：「請將輸入的音訊轉為文字。你是 NPC，請根據文字內容，從指令列表 [Reply, GoAway, Sleep, Smile] 中選擇一個指令，並以 CSV 格式回傳。」 效能體驗：Groq 的高效能與極低延遲提供了流暢的互動體驗，為遊戲互動設計帶來了新的可能性。 使用 Agent Client Protocol 的 AI 代理編輯器整合實踐 核心觀點：講者認為，在 Unity 編輯器中整合 AI 的真正潛力，並非僅是輔助編寫程式碼（這在 VS Code 等外部編輯器中已相當成熟），而應是利用 AI 對整個專案進行深度分析。目標是將整個專案作為 AI 的上下文（Context），讓開發者能以自然語言查詢專案內容，如同為專案建立一個「DeepWiki」。 UnityAgentClient： 功能：這是一款 Unity 編輯器擴充，允許在編輯器內部執行任意的 AI 代理。 後端支援：具備高度靈活性，可對接 Gemini CLI、Claude Code、Codex CLI 等多種不同的 AI 代理作為後端。 編輯器互動：透過內建的 MCP（Message Channel Protocol）伺服器，AI 代理能夠獲取編輯器內的即時資訊並執行相對應的操作。 開発現場で試行錯誤した、Unityでのゲーム開発におけるAIエージェント活用術 活動影片： 開発現場で試行錯誤した、Unityでのゲーム開発におけるAIエージェント活用術 - YouTube 相關資源： GitHub - rarudo/UnityAIAgentWorkflowSample GitHub - Unity-Technologies/UnityCsReference AI 在遊戲產業的應用正迅速發展，涵蓋自動填寫 Bug 單、推算台詞與動作、利用影像與聲音進行自動化測試、自動生成規格書等領域。\n講者分享，當他嘗試讓 AI 生成一個簡單的 Web 小遊戲時，AI 能迅速產出可運作的 HTML 與 JavaScript。然而，當他用相同的指令要求 AI 製作 Unity 版的打磚塊遊戲時，結果卻是徹底失敗。\nUnity 開發的複雜性：\n資產管理：圖片、音效、3D 模型之間存在複雜的依賴關係。 Prefab 製作：無法單純生成文本檔案，必須透過 Unity API 進行操作。 場景建構：涉及 3D 空間配置，AI 難以僅憑文本理解與操作。 序列化：Unity 使用獨特的 YAML 格式，對標準 LLM 而言難以處理。 函式庫：需要深刻理解各種函式庫（如 UI Toolkit、UniTask）的用法。 講者提出了幾個讓 AI Agent 在 Unity 中有效運作的關鍵策略：\n善用 UnityCsReference 作為知識庫\nUnityCsReference 是 Unity 官方公開的 C# 原始碼儲存庫。 將此儲存庫以 Git Submodule 形式加入專案中，AI Agent 就能在本地直接存取完整的 Unity 原始碼，並將其作為核心知識庫（Context）。 在執行任務的「調查」階段，AI Agent 能直接讀取原始碼檔案，以確認 API 是否存在、參數為何，以及 Unity 內部的實際用法。這能有效避免 AI「幻想」出不存在的 API 或用錯誤的方式呼叫 API。 縮小任務範圍，務實應用\nAI 的回應速度是目前的一大瓶頸。即使能提供大量資料，若生成一份規格書需要等待 30 分鐘，在實務上並不可行。 與其讓 AI 從零開始建構大型複雜系統，不如專注於較小且獨立的任務。 具體範例：一個極佳的應用場景是製作 Unity 編輯器擴充功能。這類工作通常是獨立的，不太需要龐大的專案上下文，非常適合讓 AI 完成「從 0 到 1」的初始開發，大幅節省開發者時間。 動態擴展上下文（Context）\n講者正在嘗試使用 Roslyn Analyzer（C# 編譯器平台）來解析專案程式碼，讓 AI 能夠理解類別之間的依賴關係與參照，從而提供更精確、更具相關性的上下文。 總結：人機協作\n現階段最實際的作法並非「將工作完全交給 AI」，而是利用 AI 來處理初始草稿或部分較困難的邏輯，再由人類開發者接手進行審查、修改與整合，達到人機協作的最佳效益。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---with-ai/","tags":["AI","AI_Coding","Unity"],"title":"Unity - With AI"},{"contents":"Quick Chat Canva 宣布，將旗下的 Affinity 套件（包含 Designer、Photo、Publisher）整合成一個全新的應用程式（v3），並將其永久免費。\nAffinity 套件的功能對應 Adobe 產品如下：\nAffinity 產品 對應 Adobe 產品 Affinity Photo Adobe Photoshop Affinity Designer Adobe Illustrator Affinity Publisher Adobe InDesign 不過，進階的 AI 驅動功能將整合至 Canva 的付費訂閱服務中。\n想想蠻合理的：基本功能其實都開發得差不多了，開發上的邊際效益遞減，因此搭上 AI 浪潮，是尋找新收益模式的策略。\n過去，輕量修改我會在 Photopea 完成，比較操作性的任務則轉向 GIMP。但必須說實話，GIMP 的操作體驗一直讓我不太適應（總覺得操作不順）。\n趁這次變動換掉 GIMP。畢竟 Affinity 是能長期與 Adobe 打對臺的產品。\nGuide 雖然有些教學是舊版，但核心操作大致相同。\nAffinity Photo 快速上手！全網公認 CP 值最高的影像處理軟體！ - YouTube ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/affinity/","tags":["Art"],"title":"Affinity"},{"contents":"Quick Chat ⚠️ Nano Banana Pro 已經於 2025-11-21 推出。\nNano Banana 是一款由 Google DeepMind 開發的 AI 圖像生成與編輯模型，其正式名稱是 Gemini 2.5 Flash Image。\n✨ 核心特色： 多輪對話式自然語言圖像編輯：允許使用者以對話方式逐步精修圖像。 角色一致性 (Character Consistency)：在不同生成圖像中，能保持特定角色的外觀與特徵一致。 我通常在 Google AI Studio 中操作，因為它能提供更豐富的上下文和操作控制。如果需要大量「抽卡」後進行精修，我則會轉到 Google Whisk 進行。\n⚠️ 解析度限制： 橫向：21:9 (1536x672), 16:9 (1344x768), 4:3 (1184x864), 3:2 (1248x832), 5:4 (1152x896) 正方形：1:1 (1024x1024) 縱向：9:16 (768x1344), 3:4 (864x1184), 2:3 (832x1248), 4:5 (896x1152) 儘管 Nano Banana 功能強大，但在某些進階應用中，如框選、遮罩、圖層修改等，專業影像處理工具（如 PhotoShop）的整合度仍然更高。\nGuide Behind the scenes of Google\u0026rsquo;s state-of-the-art \u0026ldquo;nano-banana\u0026rdquo; image model - YouTube Samples GitHub - PicoTrex/Awesome-Nano-Banana-images: A curated collection of fun and creative examples generated with Nano Banana🍌 GitHub - ZHO-ZHO-ZHO/ZHO-nano-banana-Creation: 我的 nano-banana 创意玩法大合集！ 持续更新中！ 🍌Nano Banana - nanobanana, gpt4o, chatgpt 提示词案例库 nano-bananaでモバイルアプリUIモックアップを作る Character sheet 任意の領域をアウトペイント Tips 1. 使用英文及專業術語 由於模型允許自然語言進行圖像編輯，口語化的描述詞彙可能會影響輸出結果。建議盡量使用英文和專業術語來確保指令的精確度。\n2. 多圖融合技巧 在進行多圖融合時，明確描述每張圖片的主體有助於模型精確辨識。\n❌ 不推薦： 結合所有物件，(指定情境)，產生新的圖\u0026hellip;. ⭕️ 推薦： 將 OO、OX、XX (明確指出主體)，(指定情境)，產生新的圖\u0026hellip; 3. 圖像前處理策略 處理難以定位的物件： 有時替換物件失敗，可能是因為目標物件紋理過於複雜難以定位。可先透過修圖將複雜物件的紋理簡化成純色，再進行替換。 替換背景： 當替換背景不成功時，可先將圖像輸出為純白背景，然後再指定新的背景。 4. 遮蔽與填補思維 當簡單的文字指令（如「扣上襯衫的最後兩顆扣子」）無法精確執行時，可以轉而採用「遮蔽與重繪」的策略。\n操作思路：\n遮蔽目標區域： 使用指令將無法修改的區域（例如，需要扣上的扣子處）直接覆蓋上一個單色色塊（如紅色或藍色）。 引導模型重繪： 接著使用「修復被 [單色] 色塊遮擋的區域」或類似指令。 這一步是讓模型認知到該區域是「需要修補的空白」，從而強制模型忽略原有的複雜結構，直接根據上下文（襯衫）重新生成並填補細節。\n5. 細節重建 主要應用於提升小尺寸或模糊圖片的細節表現。請注意，直接對模糊的大尺寸圖片進行高清化效果可能不佳，此時可嘗試先將圖片縮小後再進行重建。\n以臉部細節重建為例：\n高清化(super-resolution), 24歲女性，臉部線條瘦長， generate a new image: 重建臉部細節 (black hair, thin eyebrows, long face, very slender face, v-line jawline) 關鍵策略：\n使用專業術語（super-resolution）： 確保模型理解操作的類型是提升解析度。 強調生成新圖（generate a new image）： 提示模型進行深度重建而非簡單優化。 精確細節描述： 在括號中（或透過逗號）提供大量關於目標細節的描述，引導模型在重建時填充更豐富的紋理和特徵。 6. 結構化 Prompt (針對生成，非編輯) 對於圖像生成（非修圖）需求，使用結構化或規格化的描述 Prompt 能實現更細緻的控制。\n規格化範例： Create collage of 6 Vintage Photos 赛博美学未来社交软件界面 JSON 結構範例： mirror_selfie_otaku_pc_corner_blue raw_photoreal_high_fidelity Effortless Chic Pose 7. 黑暗兵法 事實上，Nano Banana 的內容審核機制相當嚴格，即使是非情色內容，有時也會拒絕操作（例如某些更衣指令）。此時需要搭配 AI Studio 使用一些進階技巧來規避限制。由於我希望避免這些技巧被濫用導致 Google 最終禁止或加強限制，因此將不在此公開說明 😂。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/google---nano-banana/","tags":["Google","AI"],"title":"Google - Nano Banana"},{"contents":"Quick Chat 此處主要整理了數個積極維護，或是在文檔中詳述其設計思路的開源專案，作為個人觀摩與學習之用。\nResources GitHub - michael811125/OxGFrame GitHub - gmhevinci/UniFramework GitHub - 404Lcc/Lcc GitHub - Alex-Rachel/TEngine GitHub - SaiTingHu/HTFramework GitHub - yimengfan/BDFramework.Core GitHub - winddyhe/knight GitHub - liangxiegame/QFramework System [GitHub - m969/EGamePlay] ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---frameworks/","tags":["Unity"],"title":"Unity - Frameworks"},{"contents":"Quick Chat 是一款強大的 AI 驅動型筆記工具與智慧助理，專為幫助使用者整理、分析和理解上傳的內容而設計，適用於學術研究、內容寫作、沉浸式學習等多元情境。\n核心特色： 完全基於您的資料來源：NotebookLM 堅守原則，所有生成的摘要、問題解答、註解或相關資訊，都嚴格且僅依據您上傳的資料。 可信賴的來源標註：為確保資訊透明度與可信度，在每次回答中，AI 都會明確標註其引用的原始資料來源。 支援輸入格式： 文件：PDF 文件、Google 文件/簡報 網路資源：網站連結、YouTube 影片 (音訊與內容皆可處理) 多媒體：音訊檔案 其他：純文字 智慧輸出功能： 核心提煉：深度摘要與即時問答 音訊轉化：Podcast/音訊摘要 視覺組織：自動生成心智圖 高效學習：學習卡片/測驗題庫 Guide NotebookLM 完整教學！93%的人還不知道的8個隱藏用法，完勝ChatGPT| 分析報告 | 會議記錄 | 自動生成Podcast、教學影片 - YouTube NotebookLM 又進化了！自訂人格、影片支援80種語言、除了摘要還能生成更多創作內容 - YouTube ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/google---notebooklm/","tags":["Google","AI"],"title":"Google - NotebookLM"},{"contents":"以下是為您潤飾後的版本，著重於更流暢、專業且吸引人的表達：\nQuick Chat 一個展示 Google 正在測試階段的新專案和產品的示範網站。它同時也是新開發服務的實驗與試驗場域。\nGuide Opal 設計初衷是協助非工程背景的使用者，以自然語言創建互動式的原型工具。它順應「無程式碼開發」（No-Code）的浪潮，旨在降低創作門檻，並加速概念驗證（PoC）的流程。\n目前主要開放美國地區使用，台灣尚未開放。\n【無料で簡単】GoogleのAIアプリ構築ツール「Opal」の活用例と使い方を徹底解説します - YouTube ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/google---google-labs/","tags":["AI","Google","Prototype"],"title":"Google - Google Labs"},{"contents":"Quick Chat 首先，規格驅動開發（SDD）並非在 AI 程式碼生成技術出現後才被提出，它是一個早已存在的概念。\n然而，在當前環境下，SDD 重新受到關注：\n成本驟降：AI 的輔助極大地降低了編寫高品質規格文件的成本和時間。 解決困境：業界普遍遭遇「Vibe Coding」（憑感覺、缺乏規範的開發）所帶來的維護性和協作性困境。 回歸檯面：市場開始追求更嚴謹、更有規範的寫作方式，使規格驅動開發重新成為主流討論。 我首次被這個概念震撼，是在 Kiro IDE 的演示中。儘管 Kiro 以搶先體驗（Early Access）方式開放，許多開發者無法接觸（需要邀請碼），但這反而間接促成了開源社群的迅速響應。如今，相關工具如雨後春筍般出現，Kiro 似乎已丟失了先發優勢。😂\nGuide ⚠️ 建議讀者著重理解這些資源所闡述的核心設計思路，而非具體的技術實現，因為相關的工具與生態系統正在快速變化。\nspec-kit/spec-driven.md at main · github/spec-kit · GitHub Spec-driven development: Using Markdown as a programming language when building with AI - The GitHub Blog Understanding Spec-Driven-Development: Kiro, spec-kit, and Tessl Concept SDD 的核心在於顛覆軟體開發的傳統權力結構，並將 規格說明書（Specification） 提升為開發過程的 核心真理來源 (Source of Truth)。\n權力翻轉：規格說明書不再是服務程式碼的附屬文件，而是程式碼必須服務規格說明書。 真理來源：產品需求文件（PRD）不再僅是實作的指南，而是生成實作的源頭。技術規格成為精確的定義，可以直接驅動程式碼的生成。 消除鴻溝：SDD 透過使規格說明及其具體的實作計畫可執行化 (Executable)，從而消除了規格說明與實際程式碼之間的鴻溝。當規格說明直接生成程式碼時，這不再是手動實作，而是一個純粹的轉化 (Transformation) 過程。 Thinking 在採用 SDD 之前，我們需要先自問：你是否希望在一個完全由 AI 主導的結構中工作，每次迭代都只透過修改文件來完成？\n如果是實驗性或原型項目，這種模式是完全可行的。\n然而，在複雜的專案中：\nPRD 的局限性：PRD 通常定義產品目標、受眾和成功標準，但其範圍過於寬泛。如果直接交由 AI 進行整體規劃，由於缺乏「如何實踐」的規範，結果往往不盡理想。 我更傾向於將 AI 參與度集中在 Feature 層面。 我的理想合作模式是：\n架構設計：大型架構與核心技術選型傾向於由人類主導設計。 上下文感知：確保 AI 了解我當前開發的整體狀況和慣例。 協作規格：我向 AI 闡述意圖，並與其討論 Feature 設計，共同產出嚴謹的規格文件。 流程實施：規格文件 → 產生細項任務 → 實作程式碼。 文件精煉：完成實作後，我會將規格文件進行精煉，而不是原封不動地保留。將其轉化為更高層級、更易於維護的交接文件。 夥伴定位：我預設將 AI 視為一次性的、高效的合作夥伴（這也符合大型語言模型 (LLM) 的隨機性的特性）。 認知負荷管理：交接文件不宜過於簡單或複雜。我認為認知負荷是關鍵考量——文件應保留核心設計思路、使用說明和注意事項，以便後續協作夥伴或未來的自己能快速上手。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/ai-coding---spec-driven-development-sdd/","tags":["AI","AI_Coding","Specification-Driven_Development"],"title":"AI Coding - Spec-Driven Development (SDD)"},{"contents":"Quick Chat 🚀 目前仍處於 EXPERIMENT 階段。\nGoogle Whisk 採用 雙引擎系統 進行圖像創作：\nImagen 4： 負責初始圖像的生成。 Nano Banana： 扮演後續的精修與編輯角色。 💡 小撇步：當 AI Studio 的 Nano Banana 額度用罄時，Whisk 也能作為一個備用選項。\nGuide Whisk - labs.google/fx Google Whisk 主要透過三種輸入類型的搭配來進行創作：\n主體物件 (Subject) 場景環境 (Scene/Setting) 藝術風格 (Style) 此外，可以上傳圖片作為輸入。系統會自動分析並產生提示詞（Prompt），用戶可以針對這些提示詞進行多次修改，以產生新的創作。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/google---whisk/","tags":["Google"],"title":"Google - Whisk"},{"contents":"Quick Chat 直到最近因應多帳號註冊需求，才發現並開始使用 Gmail 的「信箱別名」功能 😅\nGuide 如何利用谷歌邮箱别名功能获取无限 Gmail 邮箱-CSDN博客 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/google---gmail/","tags":["Google"],"title":"Google - Gmail"},{"contents":"Quick Chat 在使用 OpenSpec 進行開發的體驗相當不錯，我認為原作者的設計理念解決了許多團隊在導入 AI 協作時的痛點。\nOpenSpec 的核心優勢： 它極其擅長管理既有功能的變更 (1→n)。 OpenSpec 是一個輕量級的框架，無需 API 金鑰即可輕鬆整合到現有專案中，不需從頭來過。\n現有工具的痛點： 許多工具如 spec-kit 或 Kiro 在處理從零到一 (0→1) 的全新專案時表現非常出色。 然而，當專案進入維護與迭代階段，需要持續更新和管理不斷演進的「規格文件」時，這些工具就顯得力不從心。它們的結構在追蹤「系統當前狀態」以及「即將發生的變更」時，往往不夠直觀。\n清晰的檔案結構： OpenSpec 透過簡單的雙資料夾結構，讓規格與變更的管理一目了然，有效地將「事實的根源」與「進行中的提案」分開：\nspecs/ → 系統的當前狀態：存放目前系統的規格，是團隊與 AI 的共同認知基礎。 changes/ → 進行中的變更：所有新的功能需求或修改都會在這裡以獨立的資料夾進行，包含提案、任務列表與規格草案。 archive/ → 已完成的變更歷史：所有已合併的變更都會被移至此處，成為一份「活文件」，記錄系統的演進歷程。 Guide GitHub - Fission-AI/OpenSpec 開發者福音！用 AI 迭代現有專案？OpenSpec 讓 AI 按規範寫程式碼，零失誤！ 一位開發者的使用心得分享，原作者也在評論區參與了討論，提供了更多有趣的見解。\nI Found the Simplest AI Dev Tool Ever Workflow 這個流程確保了人類開發者與 AI 之間能夠進行順暢且可控的協作，在 AI 動手寫程式碼之前，就先對齊目標。\n起草變更提案 (Draft Change Proposal)： 開發者向 AI 提出一個新的功能需求或變更請求。 審查與對齊 (Review \u0026amp; Align)： AI 會根據你的請求生成詳細的規格與任務列表。開發者此時可以審查、提出修改意見，AI 會再根據回饋更新，形成一個反覆回饋的循環，直到雙方對「要做什麼」與「如何做」達成共識。 執行任務 (Implement Tasks)： AI 依據最終拍板定案的規格與任務列表，開始進行程式碼的編寫。 套用變更 (Apply the Change)： 開發者審查 AI 生成的程式碼，確認無誤後，執行指令將程式碼合併到專案中。 封存與更新 (Archive \u0026amp; Update Specs)： 變更完成後，該次的變更紀錄會被完整地「封存」到 archive/ 資料夾，同時更新 specs/ 中的主要規格文件，確保規格文件永遠處於最新狀態，為下一次的變更做好準備。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/ai-coding---sdd---openspec/","tags":["AI","AI_Coding","Specification-Driven_Development"],"title":"AI Coding - SDD - OpenSpec"},{"contents":"Quick Chat 稍微調查了一下現存的 Web 視覺小說方案。\n不意外地，大部分是用 React 寫的。\n目前的階段主要是先循過一輪，看看主流生態是用什麼技術堆出來的，順便了解一下有哪些常備功能是必須要有的。\n但話說回來，之前看人家調侃說「做文字遊戲的，到最後一定都會自己自幹一個引擎出來」。\n在看完這一圈之後，我忽然有種強烈的預感，這個 Flag 好像快插到我頭上了\u0026hellip; 😶\nGuide Engine：理論上只要編輯資源便能產生遊戲。 Framework：基於某些技術底層，需要一定程度的腳本編寫能力。 Prototype：一些樣本或是還在 WIP 的半成品，適合參考。 Editor：純粹的資源/對話編輯器。 Project GitHub - ba-archive/blue-archive: 碧蓝档案的档案。我们期待着更多老师的加入，欢迎通过邮件、B站私信或 discussion 联系我们 Engine GitHub - OpenWebGAL/WebGAL: A brand new web Visual Novel engine | 全新的网页端视觉小说引擎 GitHub - ahzvenol/StarNight-Engine: Web-based Visual Novel Engine | 基于Web技术的视觉小说引擎 GitHub - yhdgms1/novely: Create interactive stories with ease Framework GitHub - NarraLeaf/narraleaf-react: Make your own visual novel using a lightweight front-end react visual novel framework. GitHub - Monogatari/Monogatari: Monogatari is a simple web visual novel engine, created to bring Visual Novels to the web. Prototype GitHub - YunYouJun/advjs: 🎮 ADV.JS Web AVG Engine 面向未来与前端的文字冒险游戏引擎（WIP） GitHub - DRincs-Productions/pixi-vn-react-template: This is a template for creating visual novels in React. It uses the Pixi\u0026rsquo;VN library and ViteJS as a build tool. GitHub - Duke486/Galgamer_WebPlayer: A vision novel player for web. Uses Vue3 framework and material design. GitHub - EndoHizumi/webTaleKit: JavaScript(TypeScript)製のビジュアルノベルゲームエンジン GitHub - mikedev64/JavaScriptNovel: Visual Novel Game Engine For TypeScript Editor GitHub - MangoButtermilch/dialogue-editor: Web based tool to generate non linear dialogues. ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/side-project---web-visual-novel---fieldwork/","tags":["Side_Project","Fieldwork"],"title":"Side Project - Web Visual Novel - Fieldwork"},{"contents":"Guide 如何找出好配色？照著這個步驟做，讓你的設計更具吸引力！！ 什么是更好的渐变？ Tools Stocksy Adobe Color Canva VIVID GRADIENT GENERATOR TOOL Scheme x.com/n_seitan ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/art---color/","tags":["Art"],"title":"Art - Color"},{"contents":"Quick Chat 在設計一個真正符合自身需求的架構過程中，我查閱了許多開發者與企業的設計分享。 不同規模、不同組織背景下，策略與取捨自然各不相同。\n這些實作未必人人適用，但往往能從中擷取值得借鑑的部分。 許多案例都是針對 Unity 實務場景所 特化（Customized） 過的 Clean Architecture，例如省略部分介面或簡化層級結構。\n這樣的做法完全合理——能貼近實際生產需求的架構，才是真正的好設計。\n以下整理幾篇值得參考的文章，並附上簡要導讀。\nGuide Unityを利用した大規模なゲーム開発にクリーンアーキテクチャを採用した話\n手遊系專案 較為標準的 Clean Architecture 實作 Unityを利用したスマホゲーム開発のアプリ内課金システムに単体テストを導入した話｜G2 Studios株式会社\n手遊系專案 精簡化版本的 Clean Architecture 實作 バーチャルキャストの舞台裏 : メタバースの長期運用を実現する技術と戦略 | ドクセル\n特化過的 Clean Architecture 實作 Unityと協調するためのアーキテクチャ『MVP4U』 - yotiky Tech Blog\n採用 MVP + Orchestrator 的子模組串接架構 clusterのUnity UI周りの開発紹介 #Cluster - Qiita\n採用 MVP + 單向依賴的輕量化設計 「本日クラスターに入社したUnity Engineerが読む記事」の紹介 - Cluster Tech Blog\nClean Architecture 實作 表現層最初使用 MVP，後續因內製 UI Framework 的開發逐步轉向 MVVM 延伸閱讀：内製のUnity UI Frameworkの開発から導入・運用 - Cluster Tech Blog ENDROLL の Unity アーキテクチャとかの話 | 株式会社ENDROLL\n特化過的 Clean Architecture 實作 弊社Unityアーキテクチャの凄いところを語る\n採用垂直與水平分層、單向依賴的設計 GitHub - jinhosung96/Unity-VContainer-UniRx-MVP-Example\n使用主流 Packages 構建小型遊戲 對 MVP 與 DI（多 Scope）的應用理解相當深入 Learning Architecture, MessagePipe, and VContainer by Creating a Game Requested by My Own Daughter | Kadinche Engineering\n使用主流 Packages 構建小型遊戲 對 MVP 與 DI（單 Scope）的應用理解到位 較為標準的 Clean Architecture 實作 Unity でのゲーム開発: アーキテクチャを組織するアプローチの検討 | HackerNoon\n經典的 Unity 架構演進案例 從單例模式逐步過渡到 DI，再到複合式 MVP Unity製アプリを作る時のアーキテクチャをどこまで区切るか、あるいはレイヤードアーキテクチャの一指針\n討論 Unity 架構設計的分層考量與實務界線 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---architecture---client-research/","tags":["Unity","Architecture"],"title":"Unity - Architecture - Client Research"},{"contents":"Quick Chat 因應 AI 輔助開發的浪潮，我將個人最熟悉的輕量級應用開發模式進行了系統化的整理與規範。\n這個架構的核心理念是讓 AI 扮演「填空者」的角色。開發者預先定義好應用的骨架與規範，而 AI 則專注於填充細部的實作邏輯。如此一來，開發者便能在自己熟悉的框架下，快速理解並整合 AI 的產出，有效降低驗證與重構的認知成本。\n關於這個架構的詳細構成請參考以下文檔\nGitHub - hoshikawaryuukou/MGSU_DesignGuide_Fundamental_Client Develop Flow (Inside-Out) ⚠️請確保閱讀過上述連結。\n我的開發順序，是從最純粹的業務邏輯開始，一層層往外擴展到具體的框架與畫面。這個流程確保我能先專注在真正重要的核心功能上。\n第一步：先專注打造可獨立運作的邏輯核心 (Core) 在動手寫任何 Unity 相關程式碼之前，我會先完成這一層。\n框出功能邊界 (UseCase) 我會先問自己：「這個 App 到底能做什麼？」然後把這些功能點，例如「建立遊戲」、「移動棋子」，直接定義成一個個的 UseCase 類別。這能讓我快速建立起整個應用的功能藍圖。\n定義依賴與產出 (Port, Store, Event) 接著，我會思考每個 UseCase 的「輸入與輸出」是什麼：\n輸入 (依賴)：這個功能需要哪些「外部能力」？例如存檔。我會定義一個 ISaveGamePort 介面，但先不管誰來實作它。 產出 (結果)：功能執行完後，會改變哪些「狀態」或觸發什麼「事件」？我會定義出對應的 Store 和 Event。 完成核心邏輯 最後，把上面定義好的零件組裝起來，完成 UseCase 的內部流程。如果邏輯很複雜（如棋盤規則），我會再把這部分抽成更純粹的 Domain 物件。到這裡，核心功能就完成了，而且完全不依賴 Unity，可以獨立測試。\n第二步：實作與外部世界溝通的適配器 (Adapter) 核心邏輯建好後，我才開始處理與 Unity 框架的互動。\n實作外部能力 (Infrastructure) 我會開始實作之前在 Core 層定義的 Port 介面。例如，用 PlayerPrefs 來實作 ISaveGamePort。因為 Core 只依賴介面，未來要換成雲端存檔也很容易。\n建立溝通橋樑 (Presenter) 然後，我會建立 Presenter 作為橋樑，處理兩件事：\n從 View 到 Core：讓 Presenter 監聽 Unity UI 的點擊事件，並呼叫對應的 UseCase。 從 Core 到 View：讓 Presenter 訂閱 Store 的狀態變化或 Event。當核心邏輯改變時，由 Presenter 把新資料格式化後，更新到 Unity 的畫面上。 第三步：在最外層組裝一切 (Context) 最後一步是把所有東西串起來。\n我會建立一個 Context (或稱 Composition Root) 的角色。它的工作很單純：把前面建立的所有物件實例化，並把它們正確地「插」在一起。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---architecture---fundamental-client/","tags":["Unity","Architecture"],"title":"Unity - Architecture - Fundamental Client"},{"contents":"Quick Chat 最近為了更新履歷需要一張專業大頭照，但我手邊只有生活照。於是我使用 Google AI Studio 上的 Gemini 2.5 Flash Image (Nano Banana)，效果相當不錯。\nPractice 服裝：深色西裝 光線：側光，額頭去除油光 構圖：半身照，臉部佔 70%~80% 尺寸：4.5 公分 × 3.5 公分 表情：微笑但自然，嘴巴合閉不露齒 背景：白色，光源均勻，無陰影或反光 品質：清晰對焦，高品質無摺痕 角度：眼睛正視鏡頭\n⚠️ 關於尺寸的指令（如 4.5cm × 3.5cm），目前的 AI 模型通常無法直接生成精確的實體尺寸。 加入這項指令主要是為了讓 AI 更理解「這是一張證件照」的脈絡，從而優化構圖與臉部比例。最終，你仍需要將生成圖片匯入影像編輯軟體進行手動裁切，以符合最終需求。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/ai---prompt---headshot/","tags":["AI","Prompt"],"title":"AI - Prompt - Headshot"},{"contents":"Quick Chat MessagePipe 是一個實現了「發布/訂閱」模式（Pub/Sub）的訊息中介函式庫。\nPub/Sub 的核心價值在於實現最大化的鬆散耦合 (Loose Coupling)。\n想像一個場景：\n發布者 (Publisher)，例如遊戲邏輯模組，需要發送一個「玩家死亡」事件。它無需知道誰會對這個事件感興趣，只需將事件發布出去。 訂閱者 (Subscriber)，例如 UI 模組和音效模組，各自訂閱「玩家死亡」事件。 當事件發生時，它們會自動收到通知並執行相應的處理。在這個模型中，發布者與訂閱者之間沒有直接引用關係。MessagePipe 扮演了中介的角色，讓各模組可以獨立演進與測試，從而大幅提升專案的架構彈性。\n⚠️ 在 Unity 中，MessagePipe 需要與 UniTask（用於非同步處理）和依賴注入（DI） 函式庫（如 VContainer 或 Zenject）搭配使用。\nGuide 官方 GitHub 文件提供了非常詳盡的說明與範例，是學習 MessagePipe 的最佳起點：\nCysharp/MessagePipe Extras 搭配 VContainer v1.14.0 之後可以簡化配置 using MessagePipe; using UnityEngine; using VContainer; using VContainer.Unity; public sealed class GameLifetimeScope : LifetimeScope { protected override void Configure(IContainerBuilder builder) { // 只需這行即可 builder.RegisterMessagePipe(); } } Notice 利用 MessagePipe 實現低耦合是個優秀的架構實踐，它能讓專案更具彈性，易於維護與擴展。然而，任何工具都應避免濫用。\n過度的解耦，例如將所有事件都透過 Pub/Sub 傳遞，會導致程式碼的流程變得隱晦、難以追蹤。當你無法輕易地從一個事件的發布點找到所有訂閱者時，專案的整體邏輯就會變得支離破碎，這反而會增加除錯與維護的難度。\n建議當模組之間確實沒有直接關聯，且需要「一對多」的廣播通知時，才是 MessagePipe 的最佳使用時機。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---package---messagepipe/","tags":["Unity"],"title":"Unity - Package - MessagePipe"},{"contents":"Quick Chat 第一站：朱O數位科技 (Unity 數位內容開發) 我的第一份正職工作，是大學產學合作的延伸。對於剛畢業的我來說，薪資條件相當不錯，當時的想法很單純，就是希望能邊做邊學，持續精進技術。\n主要的工作內容是開發 Unity 數位教材和 VR 應用。然而，經過一年的實踐，我開始感覺到一絲不安。團隊的開發模式比較接近大學時期的專案，缺乏業界標準化的流程。加上我是公司唯一的 Unity 開發者，雖然獨立完成了許多專案，卻也少了程式碼審查 (Code Review) 和技術交流的機會，讓我擔心自己會逐漸與業界主流脫節。\n在某次合作案中，我深刻體會到，一個專案若缺乏專業的企劃或產品經理 (PM)，會對產品方向和開發效率造成多大的衝擊。這段經歷讓我第一次意識到，軟體開發不僅僅是寫程式而已。\n不久後，公司業務受到中國「雙減政策」的影響，我也在這波變動中，以半資遣、半主動的方式離開，踏上了尋找下一站的旅程。\n轉職沉澱期：系統化地重塑技術根基 離開第一份工作後，我沒有急著投入下一間公司，而是決定給自己一段時間，系統性地打好技術基礎。\n為什麼不直接在工作中學習呢？我詢問了身邊的朋友，發現許多公司的開發環境，更要求你快速融入既有的工作流，反而學習新技術的機會相對有限。這給我一種「你可能會成為資深員工，卻不一定是資深工程師」的感覺。\n因此，我開始有計劃地深入學習 Design Pattern、軟體架構 (Architecture)，並大量閱讀國外開發者的經驗分享。我不是空想，而是將這些理論在 Unity 中反覆實踐、驗證，逐步建立起屬於自己的設計思維體系。這段時期的每一次練習，都成為了我日後解決問題的基石。\n第二站：青O遊戲 (遊戲客戶端開發) 在面試時，老闆提及他曾是工程師出身，並且非常認同我的設計理念。這讓我燃起了熱情，希望能到第一線的開發戰場，實際驗證我所學的知識，並深入了解如何與美術、企劃、PM 等不同角色進行高效的協同開發。\n進入公司後，我觀察到核心團隊成員大多是跟隨老闆從學校時期一路打拼至今的夥伴，這使得公司的技術棧相對傳統。我所參與的客戶端專案，不僅累積了大量的技術債，架構也比較混亂。在無法進行大規模重構的前提下，我的首要任務是為專案「續命」，成功導入了熱更新機制和資源管理系統，以維持產品的穩定運作。\n此外，公司也賦予我「為團隊注入技術新血」的任務，我開始負責新技術的研究與分享，希望能帶動團隊的技術氛圍。然而，當時公司正處於現金流不穩的階段，我時常需要支援不同單位的緊急任務，導致工作體驗變得相當破碎。\n我曾提出一些關於改善開發流程的建議，雖然得到了認同，但受限於資源，最終無力執行。技術單位的角色，逐漸淪為專案需求的附庸。在這次經歷後，我意識到，一個體制完善、流程清晰的工作環境，對於工程師的長期發展至關重要，也因此萌生了尋找更成熟團隊的想法。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/chat---career---work-milestones/","tags":["Chat","Career"],"title":"Chat - Career - Work Milestones"},{"contents":"Quick Chat 此專案已開源，完整設計思路請參見 repo。 GitHub - hoshikawaryuukou/MGSP_PhotoPuzzle 🎮 遊戲介紹 遊戲目標 將所有被打亂順序的拼圖碎片，透過交換位置的方式，在固定的盤面上還原成一幅完整的原始圖像。\n🎯 遊戲特色 多種難度：支援 3×3 到 7×7 的盤面大小選擇 隨機圖片：整合 Lorem Picsum API，提供豐富的圖片資源 即時預覽：隨時查看原圖提示，幫助完成挑戰 🕹️ 遊戲玩法 設定挑戰：選擇盤面大小，系統自動載入隨機圖片 交換碎片：點選第一塊拼圖碎片，再點選第二塊，兩者位置即會交換 完成挑戰：持續交換直到所有碎片歸位，還原完整圖像即獲勝！ ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/side-project---photo-puzzle/","tags":["Side_Project"],"title":"Side Project - Photo Puzzle"},{"contents":"Quick Chat 當初想學 Python，卻常常卡在版本跟依賴的混亂。現在再回來，生態整合好多了，總算可以專心在「學」這件事上。\nGuide Env 用uv管理Python的一切！ - YouTube 从pip到uv：一口气梳理现代Python项目管理全流程！ - YouTube build + hatchling 15分钟搞懂Python项目结构和打包 - YouTube ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/python/","tags":["Python"],"title":"Python"},{"contents":"Antivirus DefenderUI - Unlocks the full power of Windows Defender with an intuitive, streamlined interface. Automation taojy123/KeymouseGo Batch Save All Resources Context BluePointLilac/ContextMenuManager Diagram 只會用 Office 畫流程圖？許多人試用過這個後直呼回不去了 👍 | Draw.io 教學 postspark Disk WizTree - The Fastest Disk Space Analyzer Everything Document HackMD：協作 Markdown 文件，分享知識的平台 Media - Image Spritesheet Cutter texture packer Atlased Texture Atlas Generator Web App by Umesh KC iLoveIMG | 影像文檔線上編輯工具 waifu2x Media - Speech jianchang512/stt Media - Video 如何安裝FFmpeg ScreenToGif Twitter 影片下載器 VLC media player Tyrrrz/YoutubeDownloader mifi/lossless-cut CapCut Andrews54757/FastStream GitHub - alyssaxuu/screenity: The free and privacy-friendly screen recorder with no limits 🎥 Message Emojipedia Network rejetto/hfs terreng/simple-web-server emanuele-f/PCAPdroid Package Manager marticliment/UniGetUI Translation 沙拉翻譯：聚合字典 、劃詞翻譯 \u0026amp; 查詞 - Chrome 線上應用程式商店 dmMaze/BallonsTranslator Search Felo - 您的免費 AI 搜尋引擎 Site 史上最簡單「一頁式網站」建置工具！ | Google Sites 協作平台快速上手 Misc 網路資源列表| DeTools ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/tools/","tags":["Tools"],"title":"Tools"},{"contents":"Quick Chat 記錄些目前使用率很高的 AI 工具 🤓。\nCollections Chat Google AI Studio ChatGPT Google Gemini Grok Search Felo - 您的免費 AI 搜尋引擎 All-in-One Genspark - 一站式 AI 工作空間 Design Lovart | 全球首個設計智能體 🔥Google Stitch颠覆传统UI设计！10秒生成专业级UI！快速生成产品原型！小白也能开发精美UI。 支持无缝导入Figma！ Stitch保姆级教程：从想法到APP大师级界面效果堪比专业团队 - YouTube ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/ai---favorites/","tags":["AI","Tools"],"title":"AI - Favorites"},{"contents":"Quick Chat 此專案已開源，完整設計思路請參見 repo。 GitHub - hoshikawaryuukou/MGSP_TrackPiece 遊戲介紹 遊戲目標 率先將自己的棋子連成一線（橫線、直線或對角線）的玩家獲勝。\n遊戲設置 玩家人數：2人 遊戲配件：一個 4x4 或 6x6 的棋盤、足量的黑子與白子。 初始狀態：棋盤清空，一名玩家持黑子，另一名玩家持白子。 遊戲流程 遊戲由黑方玩家先手，雙方輪流進行回合。在你的回合中，必須依序完成以下兩個步驟：\n放置棋子 (Place a Piece) 在棋盤上選擇一個空格，放上自己的一枚棋子。\n旋轉棋盤 (Rotate the Board) 放置棋子後，棋盤上所有的棋子會立即逆時針移動一格。\n完成以上步驟後，進行勝負判定。若無人獲勝，則換下一位玩家進行他的回合。\n勝利條件 在「旋轉棋盤」的步驟完成後，檢查棋盤。 若有任何一方的棋子連成一條線（橫線、直線或對角線），該玩家立即獲勝，遊戲結束。 若棋盤所有格子皆已下滿，仍未分出勝負，則為平局。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/side-project---track-piece/","tags":["Side_Project"],"title":"Side Project - Track Piece"},{"contents":"News AIbase基地 - 让更多人看到未来 通往AGI之路 Audio AI声音建模：MiniMax Audio 一键声音克隆 Coding GitHub项目理解神器：DeepWiki AsyncFuncAI/deepwiki-open Design 【Lovart】設計師偷偷在用的AI 工具🫢 3分鐘搞定 Logo＋海報＋網站🔥 Laichu - YouTube Translation SakuraLLM/SakuraLLM zyddnys/manga-image-translator dmMaze/BallonsTranslator ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/ai---tools/","tags":["AI"],"title":"AI - Tools"},{"contents":"Issues 中文顯示問題 在腳本第一行再加上這行 [Console]::OutputEncoding = [System.Text.Encoding]::UTF8 把 .ps1 檔案存成 UTF-8 with BOM。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/os---windows---powershell/","tags":["OS","Windows","PowerShell"],"title":"OS - Window - PowerShell"},{"contents":"Quick 我總習慣在中英文之間加個空格，讓排版看起來更舒服。今天才知道，原來這個習慣性的空格有個詩意的名字，叫做「盤古之白」，而它在英文裡則被稱為 Pangu spacing。\nGuide 定義：Pangu spacing 指的是在中文和英文（或數字）之間插入的空格，旨在劈開全形字和半形字之間的混沌，使得文本更易於閱讀。\n排版規範：在中英文混排的情況下，通常建議在中文和半形英文字母之間加入空格，例如「當你凝視著 bug，bug 也凝視著你」而不是「當你凝視著bug，bug也凝視著你」。\nExtra GitHub - vinta/pangu.js ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/chat---misc---pangu-spacing/","tags":["Chat","Misc"],"title":"Chat - Misc - Pangu Spacing"},{"contents":"Quick Chat ⚠️ 建議使用 Unity 2021 以上開發，我目前使用 Unity 6。 Guide Unity - Manual: Web development Getting started with Unity Web WebAssembly WebGL适配方案概述_抖音开放平台 Template (Unity) Better Minimal WebGL Template Build Export tips - CrazyGames Documentation 小游戏资源部署与缓存_小游戏_抖音开放平台 Host terreng/simple-web-server terreng/sws-unity-plugin Optimization Crazy Web Game Jam 24: Masterclass #1 - Web Optimization - YouTube 性能优化总览_抖音开放平台 提升Unity WebGL游戏启动速度_抖音开放平台 优化普通小游戏内存_抖音开放平台 Unity WebGL 运行时优化建议_抖音开放平台 Unity - Manual: Texture compression in Web Unity WebGL包体压缩_unity webgl 压缩-CSDN博客 Package Manager 停用 不使用的 Built-in 模組 Unity WebGL の起動高速化技術まとめ #Unity - Qiita Others Unity发布webgl获取浏览器的URL GitHub - Marinerer/unity-webg Possibly Outdated Unity WebGLビルドメモ - フレームシンセシス Unity 製 WebGL ゲームを AWS でお手軽公開 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---platform---web/","tags":["Unity","Web"],"title":"Unity - Platform - Web - Build"},{"contents":"Quick Chat 紀錄目前在使用的外掛。\nGuide Auto Link Title 自動取得貼上連結的網頁標題，並將其轉換成Markdown格式的鏈接。 Open vault in VSCode 在 VSCode 直接開啟整個 Obsidian Vault。 對於有時要做一些程序性的處理比較方便。 Image Converter 批量處理圖片。 支援剪貼簿直接貼上圖片，並將圖片放置指定位置。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/obsidian---plugins/","tags":["Obsidian"],"title":"Obsidian - Plugins"},{"contents":"Quick Chat ⚠️ 在 Unity 中需啟用 Decompression Fallback（因 GitHub Pages 不支援壓縮檔案）。 ⚠️ 僅 Public Repository 可免費使用 GitHub Pages。 以下提供兩種簡單的部署方式（此處不討論 CI 自動化）：\n方法一：建立獨立的 Public Repository 建立一個新的 Public Repository。 將 Unity WebGL 的建置輸出檔案上傳至該 Repository。 在 GitHub 設定中，指定包含 index.html 的資料夾，即可完成部署。 方法二：孤兒分支 (Orphan Branch) 我已封裝好一個 PowerShell 工具，能快速完成部署：\n👉 MGST-PowerShell-Toolkit/GH-Pages-Deploy\n此工具能將指定 Git 倉庫中的建置成果部署到 GitHub Pages 的 gh-pages 分支。\n它透過 Git worktree 與 孤兒分支（orphan branch） 技術，能在不影響主分支開發的情況下，獨立維護部署內容。\n請先確認目標目錄符合以下結構：\nproject-root/ ├── .git └── Builds/ ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/workflow--host-unity-web-game-on-github-pages/","tags":["Workflow","Unity","Github"],"title":"Workflow – Host Unity Web Game on GitHub Pages"},{"contents":"News Yucchiy\u0026rsquo;s Note Community unityroom Qiita|Unity Zenn|Unity Zenn_Unity Unity Learning Materials 「unity」の人気の記事一覧｜note Blog (Enterprise) CyberAgent Developers Blog | サイバーエージェント デベロッパーズブログ QualiArtsエンジニアブログ REALITY｜note Mirrativ Tech Blog Blog (Active) コガネブログ LIGHT11 PG日誌 きゅぶろぐ はなちるのマイノート (:3[kanのメモ帳] やらなイカ？ ねこじゃらシティ 原カバンは鞄のお店ではありません。 Raspberlyのブログ unityでいってみよう！ Blog Game Dev Beginner - Everyone Can Make Games YAMADA TAISHI’s diary 渋谷ほととぎす通信 くものす Real-Man 偵錯桐人 - unity 老刘@开发笔记 L\u0026rsquo;s Blog LianBai Lightjiao的博客 ピクセルブログ Channel Code Monkey M Studio Coco Code Events Unity Meetup Unity Advent Calendar Unityユースクリエイターカップ ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---sites/","tags":["Unity"],"title":"Unity - Sites"},{"contents":"Quick Chat 試過幾款主題，但沒有特別喜歡的，感覺還是用預設主題就好。\n不過，Markdown 的顯示樣式還是想稍微調整一下。\nGuide CSS snippets - Obsidian Help Configuration 開啟 設定。 在 外觀 → CSS 片段 中，點選 開啟片段資料夾。 在該資料夾中建立一個 .css 檔，並寫入自訂的程式碼片段。 回到 Obsidian，於 外觀 → CSS 片段 中，點選 重新載入片段，即可在清單中看到新片段。 開啟對應的切換按鈕以啟用程式碼片段。 Modification H2 與 H3 字體大小太接近 H2 標題下方加一條淡色分隔線 清單項目之間的間距稍微拉開 custom.css .markdown-preview-view h2 { font-size: 1.6em; font-weight: bold; border-bottom: 2px solid var(--background-modifier-border); padding-bottom: 0.2em; margin-bottom: 0.5em; } .markdown-preview-view h3 { font-size: 1.3em; font-weight: bold; } .markdown-preview-view li { margin-bottom: 0.25em; } .markdown-preview-view ul, .markdown-preview-view ol { margin-bottom: 0.5em; } ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/obsidian---css-snippets/","tags":["Obsidian","CSS"],"title":"Obsidian - CSS Snippets"},{"contents":"Quick Chat 透過移除未使用的 子模組（Submodules），你可以在不刪除整個功能套件的情況下，有效縮減遊戲的最終建置大小。\n這款套件可說是 Unity 6 推出至今，我個人認為最有價值的工具之一。然而，它卻只在 Unity Korea 的 YouTube 頻道上發布介紹，而且幾乎沒有任何宣傳，這點實在令人費解 😂。\n⚠️ 詳細的具體操作步驟，請務必參考官方文件與影片說明。此處僅列出幾個關鍵要點。\nGuide Web Stripping Tool package | Web Stripping Tool | 1.1.0 [꼬꼬유] Web Stripping 툴 패키지를 활용한 빌드 크기 및 로드 시간 최적화 Unity Web Stripping Tool - 초보자용 정리 가이드 Notice 適用於 Unity 6.1 及以上版本。 用於移除 Submodules 而不是整個 Modules。 若使用 2D Rendering 但未使用到 2D Rendering Sorting，則可以僅刪除指定子模組。 剝離過程是在遊戲完成初步建構後進行的，屬於建構管線的 後處理 步驟。 建議將設置文件納入版本控制。 該工具將持續改進，並計劃支持更多子模組。 Question about Original wasm size behavior with Strip Automatically After Build - Unity Engine - Unity Discussions Workflow 安裝與設置：\n在 Unity 的 Package Manager 中安裝該工具。 啟用「子模組剝離相容性」選項，並設置調試符號為外部。 剖析（Profiling）：\n進行初次建構並運行遊戲，完整測試遊戲的所有功能。 生成 JSON 格式的剖析報告，列出未使用的子模組。 子模組剝離：\n將剖析數據導入工具，選擇需要剝離的子模組。 執行剝離後，生成完整的報告，包括文件變更對比和剝離的子模組清單。 驗證與調整：\n測試遊戲是否正常運行，若發現錯誤，調整剝離清單。 整合到建構流程：\n可啟用「建構後自動剝離」選項，或使用剝離 API 進一步整合至自定義建構流程。 Workflow（Practice） 先 Build 一個 Dev 環境的版本\n不必做最佳化輸出，以快速輸出為目標。 這個版本指示是為了用來測試有什麼 子模組 可以被剝離。 使用這個版本導出可剝離的子模組清單。 我會將壓縮算法的子模組重新納入\n約 0.1 MB 還可以接受。 壓縮算法到導出的階段都可能在調整。 如果真的要保持極限乾淨的包體，之後應該會寫 BuildPipeline。 輸出 Release 版本\n於 Submodules Stripping 面板勾選 Strip Automatically After Build ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity-packages-web-stripping-tool/","tags":["Unity"],"title":"Unity - Packages - Web Stripping Tool"},{"contents":"Quick Chat 使用 robocopy 以鏡像方式，將 obsidian-notes 中的 posts 與 images 資料夾，同步到 Hugo 專案的對應目錄。\nOperation 詢問使用者是否要執行同步任務。 設定並驗證路徑，確保來源與目標皆存在。 執行 robocopy 鏡像同步，將來源內容完整覆蓋至 Hugo 專案目標位置。 mirror.bat @echo off setlocal :: Ask if the sync task should be run echo Do you want to run the sync task? (Y/N): set /p RUN_SYNC= if /I not \u0026#34;%RUN_SYNC%\u0026#34;==\u0026#34;Y\u0026#34; ( echo Sync task cancelled. pause goto :EOF ) :: Get the directory of the current script set \u0026#34;SCRIPT_DIR=%~dp0\u0026#34; :: Set relative paths set \u0026#34;SRC_POSTS=%SCRIPT_DIR%..\\obsidian-notes\\blog\\posts\u0026#34; set \u0026#34;SRC_IMGS=%SCRIPT_DIR%..\\obsidian-notes\\blog\\images\u0026#34; set \u0026#34;DST_POSTS=%SCRIPT_DIR%content\\posts\u0026#34; set \u0026#34;DST_IMGS=%SCRIPT_DIR%static\\images\u0026#34; :: Check if source paths exist echo Checking source paths... if not exist \u0026#34;%SRC_POSTS%\u0026#34; ( echo ERROR: Source posts directory not found: %SRC_POSTS% echo Please confirm that the blog-obsidian project location is correct. pause goto :EOF ) if not exist \u0026#34;%SRC_IMGS%\u0026#34; ( echo ERROR: Source images directory not found: %SRC_IMGS% echo Please confirm that the blog-obsidian project location is correct. pause goto :EOF ) echo Source path check passed. echo. echo Starting synchronization... :: Run synchronization echo Syncing posts directory... robocopy \u0026#34;%SRC_POSTS%\u0026#34; \u0026#34;%DST_POSTS%\u0026#34; /MIR echo. echo Syncing images directory... robocopy \u0026#34;%SRC_IMGS%\u0026#34; \u0026#34;%DST_IMGS%\u0026#34; /MIR echo. echo Synchronization complete! pause endlocal ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/workflow--mirror-obsidian-notes-to-hugo/","tags":["Workflow","Obsidian","Hugo","PowerShell"],"title":"Workflow – Mirroring Obsidian Notes to Hugo"},{"contents":"robocopy 全名是 Robust File Copy。 是 Windows 作業系統內建的命令列檔案複製工具。 支援多執行緒、差異複製、恢復中斷等功能。 robocopy source destination /MIR source : 來源資料夾路徑 destination : 目標資料夾路徑 /MIR : 鏡像同步 新增來源有但目標沒有的檔案 覆蓋來源較新的檔案 刪除目標有但來源已刪除的檔案（⚠️注意不可逆） ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/os---windows---tools/","tags":["OS","Windows","Tools"],"title":"OS - Windows - Tools"},{"contents":"Guide Development tips - CrazyGames Documentation Profiler Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Project Auditor Project Auditor package | Project Auditor | 1.0.1 Unity Project analysis with the Project Auditor - DEV Community ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---optimization/","tags":["Unity","Optimization"],"title":"Unity - Optimization"},{"contents":"Quick Chat 我對理想的筆記工具有四個核心要求：\n資料掌控權： 必須支援 Markdown 格式 並能 本地儲存。我不喜歡將個人資料完全託管在雲端，希望能完全掌控自己的知識資產。\n開放與分享： 具備與 GitHub 輕鬆整合 的能力，並能直接 輸出為靜態網頁。這讓我的知識不僅限於個人使用，更能方便地公開分享。\n高效檢索： 需要強大的 標籤（Tags）與搜尋功能，以便在海量筆記中快速找到所需內容。\n智慧輔助： 期待能整合 AI 輔助功能，例如自動製圖、格式化與大綱提取，讓知識工作流程更有效率。\n轉向 Obsidian 過去，我習慣用 VS Code 撰寫 Markdown 筆記，再透過 GitHub Actions 將筆記部署成 Hugo 靜態網站。這套流程行之有年，我也曾以為可以用它一直寫下去。\n然而，當我開始思考如何管理**「私人筆記」**時，這套流程的局限性逐漸浮現。我的 Hugo 網站是公開的，這意味著所有內容都必須部署到 GitHub Pages 上，完全不具備隱私性。這讓我意識到，我需要一個能同時處理公開與私人知識的工具。\n我曾想過嘗試 Obsidian，但當時它的生態系和功能還不夠成熟，所以沒有深入嘗試。如今，Obsidian 的基礎設施已相當完善，尤其是社群中如雨後春筍般湧現的 「Obsidian + AI」工作流，更是讓我的社群動態被這類分享佔據，這強烈地吸引了我，讓我萌生了重新嘗試的念頭。\n此外，作為一個專門的 Markdown 編輯器，Obsidian 自然比 VS Code 擁有更強大的文章編輯體驗，尤其在豐富的外掛生態系方面，大幅提升了我的寫作效率。這些外掛不僅能滿足基本的筆記需求，還能提供自動製圖、格式化與大綱提取等進階功能，完美契合了我對智慧輔助的期待，也成為我決定轉向 Obsidian 的關鍵因素。\n重新規劃架構 轉向 Obsidian 後，我的理想工作流有了以下調整：\n資料源分離：\n舊流程： 筆記內容與 Hugo 專案深度耦合。\n新流程： 將筆記視為一個獨立的專案，作為唯一的數據源（Single Source of Truth）。Hugo 僅作為靜態網站的生成工具，不再直接編輯文章，而是接收 Obsidian 匯出的結果。\n更謹慎的部署流程：\n為了確保發布品質，未來在將筆記發布到 Hugo 網站前，會增加一個 本地預覽步驟，讓發布流程更加嚴謹。 以下是我對這個新工作流的幾點考量，如果你也有同樣的想法，或許這篇文章會對你有幫助：\nObsidian 作為知識核心： 它將成為我個人知識管理的唯一入口與核心。\nHugo 擔任發布角色： 僅用於將 Obsidian 的內容發布為靜態網站，不進行任何內容編輯。\n行動端使用考量： 目前不考慮在手機上使用 Obsidian，主要原因為螢幕過小，不適合進行深度筆記。我會採用其他方式快速記錄，之後再整合進 Obsidian。\n雙向連結的潛力： 雖然目前尚未完全感受到雙向連結（Backlinks）的魅力 😅。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/chat---personal-knowledge-management/","tags":["Obsidian","Hugo","VScode","Github"],"title":"Chat - Personal Knowledge Management"},{"contents":"Quick Chat 這是我近年於職場上的心態轉變，也算是告別曾經的那份天真👀。\n不再自我感動：職場沒有默契，只有溝通 以前常會想：「我都做到這樣了，應該會被看見吧？」\n但現實往往是——大家都在忙，沒人會有空觀察你、理解你努力背後的細節。\n有額外做，就清楚地說。這不是邀功，是讓資訊透明、讓決策更有依據。\n不再腦補結論：有問題就問，不猜測別人怎麼想 很多時候一句主管的語氣、一個同事的反應，可能讓人開始內心小劇場：\n「是不是我表現不好？他是不是在暗示我？」\n但其實根本沒這麼複雜，有問題就說、想知道就問。\n不確定的事先標註是猜測，別拿來當決策依據。\n不再只看自己的工具箱：用對資源比技術更重要 這是最近一個明顯體悟。某次 server 誤刪資料，技術面很難復原，大家都在討論備份或 rollback 的可能性。但以營運部門的觀點：\n其實有個方式可以救到 70% 關鍵資料，而且成本很低。\n因為他們知道哪些資料「真有價值」。技術不該只解「怎麼做」，更該問「為什麼做、為什麼這樣做比較值得」。\n不要急著找最強的技術解，要先找到對的人問對的問題。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/chat---career---mindset/","tags":["Chat","Career"],"title":"Chat - Career - Mindset"},{"contents":"Quick Chat 「Code Smells（程式碼異味）」是一個軟體工程的術語，指的是程式碼中潛在問題的「警訊」。雖然這些寫法不一定會直接造成錯誤，但它們通常代表設計不良、可讀性差、難以維護或擴充的風險。\n⚠️ 不過在實務上\n**Code Smells 重要，但是否需要處理，要考量 專案體量、維護週期、團隊規模 等因素。 小專案或短期原型，可以容忍一些 Code Smells；而長期、大型專案，則需要更嚴謹地處理。 Guide Code Smells Code Smells Catalog ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---code-smell/","tags":["Software_Design","Code_Smell"],"title":"Software Design - Code Smell"},{"contents":"Quick Chat 副作用（Side Effect）指的是一段程式在執行後，除了回傳值之外還影響了外部狀態。\n在錯誤的位置或缺乏揭露的情況下使用副作用，會造成：\n函式不可預測 測試困難 程式閱讀成本上升 Bug 躲藏不易察覺 Bad Examples function getUserName(user) { saveLog(user); // 副作用：寫入外部 log notifyOthers(user.name); // 副作用：發送通知 return user.name; } Extras 很多時候副作用可能是無法規避的，因此重點不在「禁止副作用」，而是「把副作用設計得可控、可觀測、可預期」。\n較健康的副作用處理策略：\n明確命名：像 updateState, notifyUser, logError 設計邊界：像 useEffect、controller 層 專職處理副作用 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---code-smell---side-effect/","tags":["Software_Design","Code_Smell"],"title":"Software Design - Code Smell - Side Effect"},{"contents":"Quick Chat 協調者模式，主要用於管理多個獨立服務或元件之間錯綜複雜的互動。\n其核心理念是在系統中引入一個專責的「協調者」（Orchestrator）或「控制器」（Controller）元件，作為整體業務流程的指揮者。\n協調者本身並不執行具體的業務邏輯，而是像導演一樣，負責調度各個「參與者」（Participants）或「服務」（Services）來完成任務。每個參與者專注於自己擅長的部分（例如資料查詢、驗證、計算等），執行完後將結果回傳給協調者。\n協調者則根據這些結果，決定後續該呼叫哪個參與者、是否中斷流程，或如何彙整輸出，以推進整體流程邏輯。如此一來，流程控制與業務邏輯得以明確分離，讓系統更具彈性與可維護性。\nExamples class BaseGame { play() { console.log(\u0026#34;Playing base game...\u0026#34;); const result = this.spin(); return result; } spin() { return { symbols: [\u0026#34;Free\u0026#34;, \u0026#34;Free\u0026#34;, \u0026#34;Free\u0026#34;], freeSpinCount: 3, win: 100, }; } } class FreeGame { play() { console.log(\u0026#34;Playing free game...\u0026#34;); return { win: 200, spins: 6, }; } } class GameFlowController { constructor() { this.baseGame = new BaseGame(); this.freeGame = new FreeGame(); } run() { const baseResult = this.baseGame.play(); let finalResult = { from: \u0026#34;base only\u0026#34;, baseResult, }; if (baseResult.freeSpinCount \u0026gt;= 3) { const freeResult = this.freeGame.play(); finalResult = { from: \u0026#34;base + free\u0026#34;, baseResult, freeResult, }; } return finalResult; } } const controller = new GameFlowController(); const result = controller.run(); console.log(result); ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---pattern---orchestrator-pattern/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Orchestrator Pattern"},{"contents":"Quick Chat 前端開發時，「狀態管理」一直是個大哉問。\n本次的應用是 Slot Game，這類應用強調「表現層細節」，所以對於狀態的控制不像一般資料應用一樣單純，需要處理許多細部和即時的變化。\n狀態管理挑戰 響應式 data-binding 限制 :\n若完全依賴響應式 data-binding，容易產生太多「中間態」(例如動畫進行中、結果待顯示、部分組件已經觸發\u0026hellip;等)。 這樣會造成 state 爆炸、難以追蹤維護。 命令式流程控制的必要性 :\n部分場景下，直接用命令式（imperative）流程更有效率。 多組件聯動時的「動畫序列控制」。 一連串的 user action/遊戲事件，需明確依序觸發。 ⚙️ 技術棧一覽 UniTask (異步) R3 (Rx，UniRx 後繼者) VContainer (依賴注入) LitMotion (Tween) YooAsset (資源管理) Newtonsoft Json (Json 解析) Alchemy (編輯器擴充) 專案結構 Modules 主架構 project-root/ ├── _Debug/ # 測試或實驗用模組 ├── App/ # 啟動點與業務邏輯總控 ├── GameAPI/ # 遊戲 API 定義 ├── GameRunner/ # 遊戲平台通用組件 (純 UIComponent) ├── GameStage/ # 遊戲表演組件 (純 UIComponent) └── Shared/ # 共用模組 App：負責組合、調度各個模組，等於是專案的大腦。 GameAPI：只放介面定義，跨模組通訊與擴充。 GameRunner / GameStage：都是純 UIComponent (基本都是 Mono)。 Shared：共用邏輯、工具類、資料結構都放這裡。 _Debug：僅用於測試、debug，正式版本不打包。 Module 模組（以單一模組為例） module-root/ ├── Res/ # 模組獨立資源 └── Scripts/ # 腳本程式碼 ├── Editor/ # 編輯器相關 └── Runtime/ # 執行時相關 Res：模組內專屬資源包。 Scripts/Editor：編輯器工具。 Scripts/Runtime：模組實際邏輯，遊戲執行時會用到的部分。 App-Runtime（運行時架構） App-Runtime-root/ ├── Configs/ # 配置與定義 ├── Services/ # 封裝各種業務操作 ├── Presenters/ # 控制流程、狀態綁定 └── Stores/ # 狀態管理 Configs：所有定義類、配置文件，便於集中管理。 Services：將業務操作進行封裝，利於重用及維護。 Presenters：類似 MVP Pattern 的 Presenter，專注於流程控制和資料流。 Stores：專責狀態儲存，確保資料一致性。 實作體悟 1：實務上的狀態變化 一個操作觸發多處改變（One-to-Many Updates）\n例如：用戶點擊「開始」後，同時啟動動畫、鎖定按鈕、重置分數、播放音效。\n一個改變能被多處觸發（Many-to-One Triggers）\n例如：分數變化可能來自多種事件（贏分、補分、特殊獎勵），這些事件又同時影響相同的分數狀態。\n響應式的場合：狀態需要被多處觀測時 有些狀態會被多個元件同時觀察，並且常常需要被組合運用來驅動畫面邏輯。針對這類情境，我會選擇將相關的狀態邏輯獨立封裝到 Store 內，並採取「單向資料流」設計，結合 RX（Reactive Extensions）等觀察者模式來統一管理狀態變化。\n這種做法有幾個優點：\n狀態變動能集中管理，避免多個來源同時修改導致混亂。 Presenter（或 UI 層）只需要訂閱自己關心的狀態，無需額外管理彼此之間的監聽。 透過 RX 的 stream、pipe、merge、combine 等操作，可以很直覺地將複雜流程串接起來。 // 當 (GameState 變為 Idle) or (舞台表演結束) // SpinButton 變成可互動的 Observable .Merge( appStore.GameStateRP.Select(state =\u0026gt; state == GameState.Idle), gameStageDisplayer.EndStageTrigged.Select(_ =\u0026gt; true)) .Subscribe(gameRunnerSheet.SpinButton.SetInteractable) .AddTo(disposables); // 監聽每個 Update // 當玩家有互動或舞台正在表演，則重置 inactivity 時間 // 超過時間則觸發 inactivity 事件 Observable.EveryUpdate() .Where(_ =\u0026gt; IsUserActive() || IsDisplaying()) .Debounce(TimeSpan.FromSeconds(appConfig.InactivityThresholdSeconds)) .Subscribe(_ =\u0026gt; { confirmDialogScreen.SetActive(true); confirmDialogScreen.SetMessage(APIGameMessagesConstants.MSG_DEMO_TIMEOUT); Observable.Merge(confirmDialogScreen.ConfirmRequested, confirmDialogScreen.CloseRequested) .Take(1) .Subscribe(_ =\u0026gt; { Debug.Log(\u0026#34;User confirmed inactivity timeout, closing application.\u0026#34;); appCloser.CloseApp(); }); }) .AddTo(disposables); 命令式的場合：狀態封閉於單一流程時 有些狀態其實不會到處被訂閱或修改，像是遊戲中的「表演流程」這種緊密耦合、步驟明確的處理，我會直接用命令式的寫法，流程步驟一目了然，也比較方便 Debug 跟維護。\npublic async UniTask RunStep(StateStore stateStore, CancellationToken ct) { // 依據類型分流 if (StateType.IsSpecial(stateStore.Type)) await specialEffectDirector.Run(stateStore.Prev, stateStore.Current, ct); else if (stateStore.Bonus == null) await normalEffectDirector.Run(stateStore.Current, ct); else await bonusEffectDirector.Run(stateStore.Current, stateStore.Bonus.Count, ct); // 執行額外演出 if (stateStore.Prev.Count \u0026gt; 0) await extraEffectDirector.Run(stateStore.Prev, stateStore.Current, ct); // 處理連擊狀態 if (stateStore.Chain != null) { totalScore += stateStore.Chain.Score; scoreSync.OnNext(totalScore); await chainEffectDirector.Run(stateStore.Prev, stateStore.Current, stateStore.Chain, ct); } // 其他事件 if (stateStore.IsBonusTriggered) await bonusTriggerDirector.Run(ct); if (stateStore.Bonus?.ExtraCount \u0026gt; 0) await bonusExtraDirector.Run(stateStore.Bonus.ExtraCount, ct); // 判斷流程結束 if (StateType.IsFinished(stateStore.NextType)) { endEvent.OnNext(Unit.Default); if (stateStore.TotalScore \u0026gt; 0) { await finishDirector.Run(stateStore.TotalScore, ct); resetScore.OnNext(Unit.Default); totalScore = 0; } } } 實作體悟 2：封裝操作 有時候會遇到一種情境：某個 API response 回來的資料，可能同時需要更新多個 store。這時候我會寫一個 service 來專門處理這類「跨多個 store」的初始化或同步邏輯。\n像下面這個例子，就是把 app 初始化時需要設定的東西包成一個 service，讓每個 store 的狀態更新都集中在一起處理，維護起來比較有條理，也比較不容易出錯：\npublic sealed class InitializeApp { //... public void Execute() { //... authStore.SetJwt(jwt, jwtExpiration); gameInfoStore.SetBaseUrl(baseUrl); gameInfoStore.SetGameCode(gameCode); } } 這樣一來，初始化流程不會散落在各個地方，邏輯也比較集中。如果之後有需要擴充或調整，也只要改這個 service 就好，維護起來比較方便。\n實作體悟 3：GameStage 設計成純的 Displayer Displayer 本身完全不負責狀態邏輯、資料處理、流程判斷，它唯一的責任就是「接收訊號，把該演的動畫、音效、特效確實表現出來」。\n這次的設計有幾個核心前提：\n可獨立運作：Displayer 必須能單獨執行，且可以輕鬆指定測試資料進行驗證。 低耦合、高復用性：配置門檻要夠低，能夠在不同場景（正式/測試）下快速被複用，不需額外負擔。 資料格式彈性：資料來源會先轉換成內部專用的表演模型，再交由流程控制模組解讀。這樣一來，就算資料來源或格式有變動，只要維護轉換邏輯即可，大幅減少對後續表現層的影響。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---architecture---unity-slot-game-client/","tags":["Software_Design","Architecture","Unity"],"title":"Software Design - Architecture - Unity Slot Game Client"},{"contents":"Quick Chat 目前並未特別使用進階修圖技巧。若圖片瑕疵可透過簡單塗色與描邊處理，即會嘗試修復。\n若瑕疵較嚴重，則多半直接放棄並重新生成 —— 通常下一張會更好。\nModification 圖片先送入 img2img。 簡單處理：使用 Inpaint sketch（注意不要在 sketch 模式下直接生成）。 複雜處理：使用 photopea-embed 進行手動遮罩或編輯。 完成後再送回 Inpaint 重新生成。 Generation 採樣方法（Sampling method）：DPM++ 2M 時間表類型（Schedule type）：Karras 去雜強度（Denoising strength）建議範圍： 0.2 ~ 0.3：保留原圖整體色彩結構，僅微調瑕疵與過渡區域。 0.3 ~ 0.5：適度改變結構與細節，適合嘗試新的構圖或調整 seed 取得更好結果。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/stable-diffusion---inpainting/","tags":["AI","Art","Stable_Diffusion"],"title":"Stable Diffusion - Inpainting"},{"contents":"Package Collection XINCGer/Unity3DTraining killop/anything_about_game baba-s/awesome-unity-open-source-on-github Animation - Tween AnnulusGames/LitMotion Async Cysharp/UniTask Debug yasirkula/UnityIngameDebugConsole Dependency Injection hadashiA/VContainer Dialogue YarnSpinnerTool/YarnSpinner-Unity Editor AnnulusGames/Alchemy Hot Update focus-creative-games/hybridclr IO Cysharp/ZString Newtonsoft.Json git - com.unity.nuget.newtonsoft-json Language phanphantz/ThaiTextCare-for-Unity Logging JoanStinson/UnityLoggerExtended Media yasirkula/UnityNativeCamera Messaging Cysharp/MessagePipe Persistence sabresaurus/PlayerPrefsEditor Resource Management tuyoogame/YooAsset Rx (Reactive Extensions) Cysharp/R3 Social Unity Native Share Plugin Sprite elringus/sprite-dicing State Machine Inspiaaa/UnityHFSM UI mob-sakai/UIEffect mob-sakai/ParticleEffectForUGUI qiankanglai/LoopScrollRect Web psygames/UnityWebSocket gree/unity-webview t-34400/SimpleUnity3DWebView TLabAltoh/TLabWebView ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---packages/","tags":["Unity"],"title":"Unity - Packages"},{"contents":"Quick Chat 在Unity這幾年的發展中，無疑經歷了不少波折\nUnity Runtime Fee 事件 CEO 的騷操作 中國的「團結引擎」，壓縮中國 Unity 原生社群，導致部分獨立開發者出走 Godot Godot 社群越來越活躍 不過我關注的幾個 出走到 Unreal/Godot 的開發者最近似乎都歸隊了，畢竟短期內這塊蛋糕還是有一定份量的😏。\n我覺得 Unity 在 AI 方面的發展稍顯落後，但這或許與整體的開發流程有關。畢竟遊戲畫面的呈現，並不像純前端那樣能完全依靠腳本來開發。\nReleases Unity 版本大致分為 LTS 與 Supported 兩種。\nLTS（Long Term Support）版本\n提供 2 年 的支援期。 適合專案已進入穩定運營，或即將鎖定版本（例如長期營運的線上遊戲）。 重點是穩定性，減少升級成本與風險。 Supported（Update releases）版本\n約一年內會推出多個更新版本。 適合新專案或開發中的專案，追求 最新功能、平台支援 與 效能優化 的團隊。 ⚠️ 只會維護最新版本（例如 6.2 發布後，6.1 將停止維護）。 更多細節可參考 官方說明。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity/","tags":["Unity"],"title":"Unity"},{"contents":"Quick Chat 紀錄常用的配置\nConfig services-config.json で使えるカラム情報のお話 Configuration 避免執行期間變動導致不可預料的問題 Edit \u0026gt; Preferences \u0026gt; General \u0026gt; Script Changes While Playing (Stop Playing and Recompile) IDE 配置出現問題可以嘗試重新生成 Edit \u0026gt; Preferences \u0026gt; External Tools Generate .csproj files for Embedded packages Local packages ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---env---preferences/","tags":["Unity"],"title":"Unity - Env - Preferences"},{"contents":"Quick Chat 有持續關注的遊戲劇情與遊戲設定。\nSeries ブルーアーカイブ (Blue Archive) 威威字幕君的个人空间-威威字幕君个人主页-哔哩哔哩视频 鳴潮 (Wuthering Waves) 鸣学|鸣潮剧情深度解读 モンスターハンター (Monster Hunter) 艾森巴赫 - YouTube ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/acg---game---story/","tags":["ACG"],"title":"ACG - Game - Story"},{"contents":"Quick Chat ScriptableObjects 的主要用例是：\n在編輯器會話期間儲存和儲存資料。 將資料保存為專案中的資產以便在運行時使用。 Guide Unity - Manual: ScriptableObject Notice Editor Play Mode Persistence 在編輯器中進入「播放模式」(Play Mode) 時對 ScriptableObject 實例（.asset 文件對應的記憶體物件）所做的修改，在退出播放模式後會被保留下來。 如果需要在 Play Mode 中臨時修改數據進行測試，考慮使用 Instantiate() 創建 ScriptableObject 的副本來操作，這樣修改就不會影響原始的 .asset 文件。 Runtime Changes in Builds 在建構出的遊戲版本 (Build) 中，於執行期間對 ScriptableObject 實例所做的修改不會被保存回原始的資產文件。當遊戲關閉並重新啟動後，ScriptableObject 會恢復到建構時的初始狀態。 對於需要持久化的數據，應使用其他儲存機制，例如 PlayerPrefs、儲存為 JSON/XML/二進位檔案，或使用資料庫。 ScriptableObject 可以在執行期被修改，用作**單次遊戲會話（Session）**內的共享狀態容器，但要知道這些變更不會自動存檔。 Asset vs. Instance Confusion 多個地方直接引用同一個 ScriptableObject .asset，它們實際上都指向記憶體中的同一個共享實例。 對於實現全局配置或共享狀態非常有用。 如果每個使用者擁有獨立的數據副本，則需要在執行期 Instantiate() 這個 ScriptableObject 來創建副本。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---scriptableobject/","tags":["Unity"],"title":"Unity - Basic - ScriptableObject"},{"contents":"Quick Chat 我目前在 Windows 環境下，會依需求在 Visual Studio 與 VS Code 之間切換：\nVisual Studio\n專案初期建置 需要進行檔案或命名重構 (renaming) VS Code\n需要使用 GitHub Copilot 時 Configuration - VS Code .NET SDK 安裝 前往 .NET 官方下載頁面 下載對應版本 選擇對應平台的 SDK： Mac M 系列 (M1/M2) ➔ 安裝 Arm64 版本 其他 Mac 型號 ➔ 安裝 x64 版本 Windows ➔ 安裝 x64 版本 安裝完成後 重新啟動電腦，以讓環境變數生效 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---env---ide/","tags":["Unity","VScode","Visual_Studio","Mac","Windows"],"title":"Unity - Env - IDE"},{"contents":"UNT0023 Coalescing assignment on Unity objects 合併賦值運算子 ??= 是 C# 8.0 引入的運算子，其功能是：如果左側運算元為 null，則將右側運算元的值賦給左側運算元。\n然而，在 Unity 中直接對 Unity 物件 (如 GameObject、Component 等) 使用這個運算子可能會導致問題，因為：\nUnity 物件的特殊生命週期：Unity 物件即使被銷毀，在 C# 層面的變數可能不會自動設為 null，而是成為\u0026quot;偽 null\u0026quot;物件。\n自訂的 null 檢查行為：Unity 覆寫了 == 運算子，使得對已銷毀的 Unity 物件進行 null 檢查時會返回 true，但 `?? 運算子使用的是底層的 null 檢查機制。\n使用明確的 null 檢查 private Rigidbody rb; void Start() { if (rb == null) { rb = GetComponent\u0026lt;Rigidbody\u0026gt;(); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---coding---warnings/","tags":["Unity"],"title":"Unity - Coding - Warnings"},{"contents":"Quick Chat Unity Package Manager (UPM) 的設計理念，是向現代軟體開發的 「套件管理系統」 看齊，最主要的借鏡對象就是網頁開發領域的 NPM (Node Package Manager)。\n模組化：不同功能（像是 2D 工具、Timeline、Addressables）都能獨立存在，更新或安裝時不會牽動整個專案。 可控版本：可以指定版本，就像你在 npm 裡選擇某個 library 的版本，確保團隊成員與 CI 環境一致。 遠端來源：除了 Unity 官方 registry，也可以掛上私有 registry，甚至用 Git URL 或本地資料夾引入。 幾個重要觀念：\n所有透過 UPM 安裝的套件都會被存放在 Packages 資料夾。 Packages 是唯讀的，不過仍有方式能夠修改。 UPM 的主要使用情境是管理可重用的「功能模組」，這些通常以程式碼為核心。而遊戲專案中獨特的、需頻繁修改的藝術素材 （如模型、貼圖、音效），其歸宿依然是傳統的 Assets 資料夾。 Guide 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM 【Unity】Package Manager活用術 使用OpenUPM发布自己的Unity项目 Installing Packages using UPM Package manager -\u0026gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -\u0026gt; Packages: My Registries -\u0026gt; Install Package Template GitHub - IvanMurzak/Unity-Package-Template: Template Unity Package for OpenUPM and NPMJS. Supports UPM (Unity Package Manager) with versioning. ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---package-manager/","tags":["Unity","Package_Manager"],"title":"Unity - Package Manager"},{"contents":"Guide Organizing Your Unity Project — Content vs Feature Folders Organizing Project Folder Structure: Function-Based vs Feature-Based Content-Based（依內容分類） 特點 以「資源類型」來劃分資料夾，例如腳本、材質、模型等。 缺點 同一個功能可能分散在多個資料夾中。\n例如你想找「商店系統」的 prefab、script 和 UI，可能得在三、四個資料夾中翻找。 範例 Assets/ ├── Materials/ ├── Models/ ├── Textures/ ├── Scripts/ ├── Animations/ ├── Prefabs/ ├── Audio/ Feature-Based（依功能分類） 特點 以功能模組為單位集中管理相關資源。 適合模組化開發，有助於封裝、重用與搬移。 找特定功能時，所有相關資源都集中在一起，不需東找西找。 缺點 相同類型的資源（例如所有動畫或音效）會分散各處，不利統一管理。\n（不過透過 Editor 的搜尋功能，其實影響不大。） 若模組間耦合度高，可能導致功能邊界模糊。 範例 Assets/ ├── Shop/ │ ├── Scripts/ │ ├── Prefabs/ │ ├── UI/ ├── Player/ │ ├── Scripts/ │ ├── Animations/ │ ├── Prefabs/ ├── Inventory/ │ ├── Scripts/ │ ├── UI/ Hybrid（混合式） 特點 以 Feature-Based 為主體。 共用資源集中放置於 Common 或 Shared 資料夾中，避免重複。 範例 Assets/ ├── Common/ │ ├── Materials/ │ ├── Fonts/ │ ├── Audio/ ├── Player/ │ ├── Scripts/ │ ├── Prefabs/ ├── Shop/ │ ├── Scripts/ │ ├── UI/ 實踐建議 小型專案或原型（Prototype）建議先採用 Content-Based 結構，快速上手。 專案逐漸擴大後，可以逐步轉向 Feature-Based，以利管理與維護。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---project-structure/","tags":["Unity"],"title":"Unity - Project Structure"},{"contents":"Description 85. 最大矩形 Sample input matrix = [ [1,0,1,0,0], [1,0,1,1,1], [1,1,1,1,1], [1,0,0,1,0] ] output 6 Key points Solution 1 - 暴力解 檢查矩陣中所有可能的矩形，並計算每個矩形是否符合條件。 對每個可能的矩形進行迴圈遍歷。 計算該矩形內的元素是否符合條件。 複雜度 m 為 row 的長度 ，n 是 column 的長度 時間複雜度：O(m^2 x n^2) 空間複雜度：O(m x n) Solution 2 - 單調棧 將原矩陣根據各 row 提取出數個高度(連續的1)陣列。 便可將問題拆解成數個 84 題。 推導 Step Matrix Row heights[] result by No.84 1 [1,0,1,0,0] [1, 0, 1, 0, 0] 1 2 [1,0,1,1,1] [2, 0, 2, 1, 1] 2 3 [1,1,1,1,1] [3, 1, 3, 2, 2] 6 4 [1,0,0,1,0] [4, 0, 0, 3, 0] 4 最大矩形面積 = 6\n複雜度 m 為 row 的長度，n 是 column 的長度 時間複雜度：O(m x n) 空間複雜度：O(m) ","permalink":"https://HoshikawaRyuukou.github.io/posts/leetcode-85-maximal-rectangle/","tags":["LeetCode","Algorithm"],"title":"LeetCode 85 - Maximal Rectangle"},{"contents":"Description 84. 柱状图中最大的矩形 Sample input heights = [2,1,5,6,2,3] output 10 Key points 目標是 找到每個柱子能擴展的最大寬度，然後計算以該柱子為高度的最大矩形面積。 Solution 1 - 暴力解 對於每個 heights[i]，向 左、右 擴展，直到遇到比它矮的柱子。 左邊界 (left)：找第一個小於 heights[i] 的索引 右邊界 (right)：找第一個小於 heights[i] 的索引 寬度 (width)：width = right - left - 1 面積 (area)：area = heights[i] * (right - left - 1) 推導 i heights[i] left right width area 0 2 -1 1 1 2 1 1 -1 6 6 6 2 5 1 4 2 10 3 6 2 4 1 6 4 2 1 6 4 8 5 3 4 6 1 3 最大矩形面積 = 10\n複雜度 時間複雜度：O(n^2) 空間複雜度：O(n) Solution 2 - 單調棧 單調棧 : 棧內元素 會按照 遞增/減順序 存放\n使用 單調遞增棧（Monotonic Increasing Stack） 當 遇到一個比棧頂元素小的數，意味著 棧頂柱子找到了右邊界 右邊界確定時，順便出棧，並計算面積 推導 設定 stack = [] 為了確保最後能計算所有矩形，在 heights 末尾補 0，確保最後所有柱子都會出棧。 i heights[i] Stack (i) action area 0 2 [0] 入棧 1 1 [] 出棧 (2 找到右邊界) 2 * (1 - 0) = 2 1 1 [1] 入棧 2 5 [1,2] 入棧 3 6 [1,2,3] 入棧 4 2 [1,2] 出棧 (6 找到右邊界) 6 * (4 - 3) = 6 4 2 [1] 出棧 (5 找到右邊界) 5 * (4 - 2) = 10 4 2 [1,4] 入棧 5 3 [1,4,5] 入棧 6 0 [1,4] 出棧 (3 找到右邊界) 3 * (6 - 5) = 3 6 0 [1] 出棧 (2 找到右邊界) 2 * (6 - 1) = 8 6 0 [] 出棧 (1 找到右邊界) 1 * (6 - 0) = 6 最大矩形面積 = 10\n複雜度 時間複雜度：O(n) 空間複雜度：O(n) ","permalink":"https://HoshikawaRyuukou.github.io/posts/leetcode-84-largest-rectangle-in-histogram/","tags":["LeetCode","Algorithm"],"title":"LeetCode 84 - Largest Rectangle in Histogram"},{"contents":"Search Gelbooru image search Danbooru image search キャラ誕 アニメ漫画ラノベ キャラクター誕生日カレンダー Translation Fast manga translator \u0026amp; Translations in Multiple Languages ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/acg/","tags":["ACG"],"title":"ACG"},{"contents":"Quick Chat ⚠️ 這是一篇新手導引，目的不在於精準解釋。 ⚠️ Checkpoint 一般會提供推薦的參數設置，建議依據模型的特性調整，以獲得最佳效果。 Resources Civitai: The Home of Open-Source Generative AI Checkpoint 決定生成圖片的基礎風格。\n寫實風格 (Photorealistic) 動漫風 (Anime) 油畫風格 (Painting) 科幻賽博龐克 (Cyberpunk) 像素風格 (Pixel Art) LoRA 輕量化微調模型可額外載入來增強特定風格或角色。\n簡單的比喻來形容 LoRA 模型，那就是「濾鏡」 Embedding 增強對某些 Prompt 的理解。\nVAE 提高圖片細節與顏色準確度。\n📝 部分 Checkpoints 會內建（Baked）VAE，如使用外部 VAE，請確認是否需要覆蓋內建版本。 ⚠️ 如果發現圖片的型都對，但只有顏色壞掉，通常都是 VAE 的問題。 Resolutions 不同種類的 Checkpoints 建議的解析度會有所不同\nSD 1.5 512 x 512 : 1:1 512 X 768 : 2:3 SDXL 640 x 1536 = 5:12 768 x 1344 = 4:7 832 x 1216 = 13:19 896 x 1152 = 7:9 1024 x 1024 = 1:1 1024 x 1536 = 2:3 Sampler + Schedule Sampler 是從雜訊圖到成品的去噪算法。\n快速收斂 – 能迅速找到解答，適合驗證創意和想法。 高品質收斂 – 需較長時間，但能提供更精確結果。 無固定收斂 – 無明確收斂條件，為創新提供更大空間。 Schedule 是從雜訊圖到成品的去噪程度。\n📝 常用組合\nEuler A Automatic DPM++ 2M Karras DPM++ SDE Karras Steps 從雜訊圖到成品的迭代次數。\n⚠️ 步數過少可能導致產生的影像品質不佳。 ⚠️ 步數過多可能使影像產生過程變得冗長，但未必能提升品質。 📝 建議從較低的步數開始，例如 15 或 20。 CFG Scale 遵循 Prompt 的程度。數值越大，產生的影像與文字提示的相關性越高。\n⚠️ 但當數值過大時可能會出現過度飽和或不自然的情況。 📝 建議從較低的 CFG 比例值開始並增加它，直到對結果滿意為止。 📝 沒有最佳值，要根據模型的不同來設定不同的值。 📝 常用區間：3 ~ 7 Seed 用於生成雜訊圖。\n⚠️ 當圖片大小改變時所生成的雜訊圖也會有差異(即使比例一樣)。 📝 使用相同的 Seed 可重現相同圖片(前提是設備/環境需一致)。 📝 設為 -1 為隨機。 📝 固定 Seed 進行實驗：在進行圖像生成時，建議固定一個 Seed，然後調整提示詞或其他參數，以便觀察這些變化對最終圖像的影響。 Clip Skip 調整生成圖像過程中對提示詞的處理方式。\n📝 現實系建議設為 1。 📝 動畫風建議設為 2。 Prompt 不同的 Checkpoints 對提示詞的理解會有所不同，選對模型才能產生最好的效果。 從左到右的順序來解析提示詞，越前面的詞影響越大，越後面的詞影響越小。 正向 Prompt：描述想要的內容。 負向 Prompt：描述不想要的內容。 BREAK：可用來分隔不同場景或主題。 數值控制權重：調整提示詞的影響力，數值越高影響越強。例如： (beautiful:1.5)：增強 \u0026ldquo;beautiful\u0026rdquo; (dark:0.8)：減弱 \u0026ldquo;dark\u0026rdquo; 提示詞應該從少量開始，逐步增加，這樣才能確保： 確定哪些詞有效 避免無效詞 確保 Prompt 保持清晰，容易控制風格 Illustrious XL 提示 (+ 更新！) NOOBAI XL快速指南 NAIv3 Style Codex: Single Artist NAIv3 Style Codex: Mixed Artists Settings Saving images \u0026gt; Saving images/grids Images filename pattern : [datetime]-[seed] Add number to filename when saving : 反選 這樣避免整合圖片時發生亂序。 Extras img2img - inpaint ControlNet ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/stable-diffusion---quick-start/","tags":["AI","Art","Stable_Diffusion"],"title":"Stable Diffusion - Quick Start"},{"contents":"Quick Chat ⚠️ 以下皆須安裝指定版本不可貿然升級。\n目前產圖只使用到 Forge + SDXL 。\nLocal deployment nvidia 驅動更新至最新 檢查顯卡支援的最高 cuda 支援: nvidia-smi 安裝 CUDA 12.1 顯示 cuda 編譯工具的版本信息: nvcc --version 安裝 [stable-diffusion-webui-forge] Google Colab gutris1/segsmaker 配置 Civitai API Key Civitai 網站 Menu \u0026gt; Account Settings(齒輪 icon) \u0026gt; API Keys Extensions DominikDoom/a1111-sd-webui-tagcomplete Physton/sd-webui-prompt-all-in-one Bing-su/adetailer yankooliveira/sd-webui-photopea-embed ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/stable-diffusion---env/","tags":["AI","Art","Stable_Diffusion"],"title":"Stable Diffusion - Env"},{"contents":"Quick Chat 目前 Stable Diffusion 只拿來自娛自樂 😃。\nCore Working Principles Stable Diffusion 主要包含三個核心技術：\n前向擴散（Forward Diffusion） 先從大量圖片資料集中學習圖片特徵。 然後，系統會逐步加入高斯雜訊（Gaussian Noise），使圖片變得模糊、無法辨識。 最後，這個過程會讓圖片變成完全的純雜訊（random noise）。 反向去噪（Reverse Denoising / U-Net） Stable Diffusion 學習如何逆向去噪，一步步從雜訊還原出清晰的圖片。 這部分的關鍵是 U-Net 神經網路架構，它可以在多層次的細節中，捕捉圖片的各種特徵。 文本引導（Text Conditioning / CLIP） Stable Diffusion 之所以能生成符合指令的圖片，是因為它使用了CLIP（Contrastive Language-Image Pretraining）。 CLIP 會將文字轉換成向量表示（latent embeddings），這些向量再指導模型生成符合描述的圖像。 Diagram Improving Diffusion Models as an Alternative To GANs, Part 1 Extras Re: [問題] AI 風格怎麼了嗎？為什麼容易膩？ - 看板C_Chat - PTT網頁版 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/stable-diffusion---illustrious-xl/","tags":["AI","Art","Stable_Diffusion"],"title":"Stable Diffusion - Illustrious XL"},{"contents":"Configuration 在 GitHub 上設定 SSH Key 主要有兩個情境：\n1. 新增至個人帳戶 適用情境：您需要透過 SSH 存取您個人帳戶下所有具備權限的儲存庫 (Repository)。 設定位置：GitHub \u0026gt; Settings \u0026gt; SSH and GPG keys 2. 新增至組織的 Deploy Key 適用情境：您的 SSH Key 僅需存取組織下某個特定的儲存庫，而非整個帳戶。 設定位置：GitHub 組織 \u0026gt; 目標 Repository \u0026gt; Settings \u0026gt; Deploy keys ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/github---ssh-key/","tags":["GitHub"],"title":"GitHub - SSH Key"},{"contents":"Quick Chat 當 main 分支有 push，或有 pull request 時，會自動用 Hugo 生成靜態網站，並將 public 目錄的內容部署到 GitHub Pages。\nOperation 檢出程式碼（含 submodules，全歷史） 安裝 Hugo（最新版、Extended 版） 建置網站（hugo --minify 壓縮輸出） 部署到 GitHub Pages（僅 main 分支才執行部署） gh-pages.yml name: github pages on: push: branches: - main pull_request: jobs: deploy: runs-on: ubuntu-22.04 steps: - uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v4 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/workflow--build-and-deploy-hugo-site/","tags":["Workflow","Hugo","Github"],"title":"Workflow – Build and Deploy Hugo Site"},{"contents":"Quick Chat Hugo 是一款以 Go 語言編寫的 靜態網站生成器（Static Site Generator, SSG），特色是 速度極快、部署簡單，且不依賴後端伺服器程式。\n對於非前端專業的我來說，Hugo 最大的優勢在於：能專注於以 Markdown 撰寫內容，不必過度投入在前端細節。當然，若有需要，也能自製或改造主題。\n建議新手可以先嘗試以下功能完整且持續維護的主題：\nadityatelange/hugo-PaperMod nunocoracao/blowfish Guide The world’s fastest framework for building websites | Hugo Hugo 從零開始：環境安裝（Windows） Environment 從 Hugo GitHub Release 下載執行檔（建議選擇 hugo_extended 版本） 設置環境變數 常用指令： hugo version：檢視 Hugo 版本 hugo server：本地預覽網站 Theme ⚠️ 安裝主題前，請先閱讀該主題作者的安裝與配置文件（不同主題的流程可能略有差異）。 主題資源：Hugo Themes 本 blog 主題：hoshikawaryuukou/hugo-theme-cactus 是基於以下 repository 修改： monkeyWzr/hugo-theme-cactus OmeletWithoutEgg/hugo-theme-cactus 小幅修改主題 ⚠️ 不要直接修改主題原始檔案。\n若需要修改，請將要編輯的文件 依相同資料夾結構 複製到專案根目錄，Hugo 會依模板查找優先順序載入你修改的版本。\nExtras Rendering Images in Markdown Preview of Hugo Site ","permalink":"https://HoshikawaRyuukou.github.io/posts/hugo-overview/","tags":["Hugo"],"title":"淺談 Hugo：簡單好用的靜態網站生成器"},{"contents":"Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---media/","tags":["Unity"],"title":"Unity - Basic - Media"},{"contents":"Guide 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them? EditorBuildSettings Example ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---editor/","tags":["Unity"],"title":"Unity - Basic - Editor"},{"contents":"Guide 【Unity】3つだけでいい!?覚えるべきUIアンカー 【Unity基礎】スマホ向けゲームUIの作り方！基本的なUI配置から複数解像度対応まで解説 Master your Unity UI Buttons! - Unity UI tutorial How to scale Unity UI objects for every screen - Unity UI tutorial Canvas Designing UI for Multiple Resolutions Unity Canvas Scaler 组件的使用 Unity分辨率适配方案设置 Unity教程：如何让UI自适应分辨率_哔哩哔哩_bilibili Material Unity中，UI反向Mask效果（图片挖洞） Text 【Unity编辑器扩展】艺术字/自定义图片字体生成工具 【Unity】自作フォントを作成してTextで表示する方法 Unity中自制UGUI艺术字体（位图字体）（Bitmap Font Generator） TextMeshPro TextMeshPro Anatomy [Unity干货]使用TextMeshPro动态字体节省时间 【Unity】TextMesh Proで数字をスプライト表示する ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---ui/","tags":["Unity"],"title":"Unity - Basic - UI"},{"contents":"Error Error : Failed to parse binary data file Build/xxx.data.br\u0026hellip; Failed to parse binary data file Build/web.data.br (with \u0026ldquo;Content-Type: null\u0026rdquo;), because it is still brotli-compressed. It should have been uncompressed by the browser, but it was unable to do so since the web server provided the compressed content without specifying the HTTP Response Header \u0026ldquo;Content-Encoding: br\u0026rdquo; that would have informed the browser that decompression is needed. Please verify your web server hosting configuration to add the missing \u0026ldquo;Content-Encoding: br\u0026rdquo; HTTP Response Header.\n📝 需要配置 Content-Encoding 參考 terreng/sws-unity-plugin\nError : Unable to load file Build/xxx.framework.js.br\u0026hellip; Unable to load file Build/xxx.framework.js.br! Check that the file exists on the remote server. (also check browser Console and Devtools Network tab to debug)\n📝 這是因為 Brotli 壓縮算法僅在 HTTPS 連接中被啟用\nOptional Optional : autoSyncPersistentDataPath 修復了 Application.persistentDataPath 持久化的問題\n📝 通過於 index.html 添加新的 JS 配置選項 autoSyncPersistentDataPath： true 來啟用 Application.persistentDataPath 到 IndexedDB 的自動同步。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---platform---web---issue/","tags":["Unity","Web"],"title":"Unity - Platform - Web - Issue"},{"contents":"Quick Chat 「控制反轉（Inversion of Control, IoC）」這個詞常常讓人一頭霧水──到底反轉了什麼？\n更麻煩的是，它還很容易和「依賴倒置（Dependency Inversion）」混淆 😅\n如果你在開發時有出現以下這些疑惑，那麼你其實已經在思考 IoC 要解決的問題了：\n為什麼到處都要 new？ 建構子的參數要怎麼安排？初始化邏輯怎麼整理？ 物件能不能被共享？生命週期誰來管理？何時該釋放？ 是否需要一個「專門管理依賴」的角色？ 這個類別既要處理業務邏輯，又要負責 new 物件，職責是不是太混亂了？ IoC 正是為了解決這些問題而提出的，它帶來一個核心理念：\n依賴的「使用者」不再自己主動去建立和配置依賴，而是把這個「控制權」交給外部機制（通常是 IoC 容器）。\n換句話說：\n依賴的「使用者」只需要「接收」或「查詢」它所需的依賴，然後專心「使用」它們。這樣它就能專注在核心邏輯上，而不必分心處理依賴管理，進而提升模組化與可維護性。\nAdvantages 降低耦合度： 需求方與具體實現之間不再直接關聯，每個模組都可以獨立開發、測試與替換，互不影響。\n集中管理依賴： 容器統一管理所有物件的建立和生命週期。當您需要替換某個服務的實作時，只需要修改容器的配置，而不需要動到多處程式碼。\n避免重複建構： 容器可以管理共享的物件實例，有效避免重複建立，提高資源利用率。\n提升測試便利性： 透過 IoC 容器，在進行單元測試時，可以輕鬆地將真實的服務替換為模擬物件（mock） 或 測試替身（stub）。\nPractice 實現 IoC 有兩種常見方式：依賴注入（Dependency Injection, DI） 和 依賴尋找（Dependency Lookup）。\n依賴注入（DI） 這是目前最主流且推薦的實踐方式，核心概念是由容器「被動地」將依賴項傳遞給需求方。\n實作原理： 容器會主動將所需的依賴（如服務物件）透過以下方式注入到您的類別中：\n建構子注入（Constructor Injection）： 在物件建構時，透過建構子的參數傳入依賴。這是最推薦的方式，因為它可以確保物件在建立時就擁有所有必要的依賴，讓依賴關係更清晰。\n屬性注入（Property Injection）： 透過公開的屬性（Setter）來傳入依賴。\n方法注入（Method Injection）： 透過特定的方法來傳入依賴。\n優點： 這種方式讓您的程式碼無需知道容器的存在（理想狀態），因為依賴是「被動」傳入的，大大降低了耦合度。\n依賴尋找（Dependency Lookup） 這種方式的核心是由需求方「主動地」向容器請求所需的依賴。\n實作原理： 需求方會直接呼叫容器的方法（例如 container.resolve()），來取得所需的服務。\n優點： 簡單直觀。\n缺點： 這種方式存在爭議，被視為一種反模式（anti-pattern），因為它讓需求方直接與容器耦合，失去了 IoC 應有的解耦優勢。最典型的實作就是 服務定位器（Service Locator）。\nTrade-off 儘管 IoC 容器提供了強大的功能，但它也需要權衡：\n框架依賴性： 大多數 IoC 容器需要依賴特定的框架來管理依賴關係，這會增加專案的複雜性。\n學習曲線： 導入 IoC 容器框架通常需要額外的學習成本，特別是對於小型或簡單的專案而言，可能過於複雜。\n組合根（Composition Root）：「窮人的 DI」 組合根指的是應用程式中集中管理所有依賴的建立與組裝的地方，通常位於應用程式的進入點（如 main 方法或 Web 應用程式的啟動類別）。這裡就是您定義依賴注入規則並初始化所有服務的地方。\n在許多簡單的專案或情境下，您不需要引入龐大的框架。只需要在組合根手動建構和組裝所有依賴，就能實現 DI 的核心精神。這種做法就是常說的**「窮人的 DI」**，它依然能有效解耦，同時避免了框架帶來的額外負擔。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---principle---inversion-of-control-ioc/","tags":["Software_Design","Principle"],"title":"Software Design - Principle - Inversion of Control (IoC)"},{"contents":"Quick Chat 物件生命週期管理（Object Lifecycle Management）是程式設計中的一個重要概念，它指的是有效控制和管理一個物件從建立、使用到銷毀的整個過程。良好的生命週期管理不僅能提升應用程式的效能，還能提高程式碼的可維護性，並有效地利用系統資源。\nStage 建立（Creation）\n物件被初始化並在記憶體中生成。在這個階段，程式碼通常會執行建構函式，完成必要的設定，或注入所需的依賴項。\n使用（Usage）\n物件處於活躍狀態，執行其核心功能。這段期間，應用程式會不斷地呼叫物件的方法，讀取或修改其屬性，處理各項業務邏輯。\n銷毀（Destruction）\n當物件不再被需要時，系統會回收其所佔用的資源。這個過程通常涉及垃圾回收機制（Garbage Collection），並釋放如檔案連線、資料庫連線等外部資源，避免資源洩漏。\nLifetime 瞬時（Transient）\n這種模式下的物件是一次性的。每次需要時，系統都會建立一個全新的實例。它特別適合那些不帶有狀態（Stateless）或只在短期內使用的物件，確保每次呼叫都是一個獨立乾淨的實體。\n單例（Singleton）\n顧名思義，在整個應用程式的執行期間，只會建立一個單一的實例。所有對該物件的請求都會共用同一個實體。這種模式常用於管理全域性資源，例如設定檔、日誌記錄器或資料庫連線池等。\n範圍（Scoped）\n這是一種介於瞬時和單例之間的模式。物件的生命週期被限制在一個特定的作用範圍內，例如一次 HTTP 請求或一個獨立的執行單元。在該範圍內，該物件都是唯一的；但當範圍結束時，該物件就會被銷毀。這種模式非常適合在單次請求中共享狀態，同時又確保不同請求之間不會互相干擾。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---concept---object-lifecycle-management/","tags":["Software_Design","Concept"],"title":"Software Design - Concept - Object Lifecycle Management"},{"contents":"Quick Chat 透過 GitHub CLI (gh) 刪除一個儲存庫中最舊的部署（deployment）記錄，保留最新的 10 筆。\nOperation 登入 gh auth login Clean-Up-Old-GitHub-Deployments.ps1 取得指定儲存庫的所有部署記錄 ID。\n跳過最新的 10 個 ID。\n對剩下的（最舊的）每一個 ID：\n顯示一條刪除提示訊息。 發送一個 DELETE API 請求，將其從 GitHub 移除。 $Owner = \u0026#34;Owner Name\u0026#34; $Repo = \u0026#34;Repo Name\u0026#34; gh api repos/$Owner/$Repo/deployments --paginate --jq \u0026#39;.[].id\u0026#39; | Select-Object -Skip 10 | ForEach-Object { Write-Host \u0026#34;Deleting deployment $_\u0026#34; gh api --method DELETE repos/$Owner/$Repo/deployments/$_ } 這段程式碼可以拆解為幾個部分來理解：\n$Owner 和 $Repo 是 PowerShell 的變數，用來存放你的 GitHub 儲存庫的擁有者和名稱。\ngh api repos/$Owner/$Repo/deployments --paginate --jq '.[].id'\n$Owner 和 $Repo 會被替換成你設定的值。 這段指令會透過 GitHub CLI 取得你指定儲存庫的所有部署記錄，並只列出它們的 ID。 | Select-Object -Skip 10\n這段指令會跳過清單中最前面的 10 個 ID。 因為 GitHub API 預設是把最新的記錄放在最前面，所以這個步驟等於是保留了最新的 10 筆部署，並選取了剩下的、最舊的部署。 | ForEach-Object { ... }\n對每一個被選中的舊部署 ID，執行大括號 {} 裡面的指令。 Write-Host \u0026quot;Deleting deployment $_\u0026quot;\n顯示一條提示訊息，讓你知道目前正在刪除哪一個部署。 gh api --method DELETE repos/$Owner/$Repo/deployments/$_\n這行指令會發送一個 DELETE 請求，把這個舊的部署從 GitHub 上永久刪除。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/workflow--clean-up-old-github-deployments/","tags":["Workflow","GitHub","PowerShell"],"title":"Workflow – Clean Up Old GitHub Deployments"},{"contents":"Quick Chat GitHub 網頁面板上沒辦法執行刪除 deployment，得用 GitHub CLI 來操作😂。\nGuide GitHub CLI | Take GitHub to the command line Operation 登入 gh auth login ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/github---github-cli/","tags":["GitHub"],"title":"GitHub - GitHub CLI"},{"contents":"Quick Chat 在軟體工程中，設計模式（Design Pattern）是解決常見問題的一套可重複使用的最佳實踐方案。它們就像是經驗豐富的工程師為特定情境寫下的「操作手冊」，能幫助我們寫出更具彈性、易於維護且可擴展的程式碼。\nGuide Factory 工厂模式？错！是工厂模式群！ Observer vs Pub-Sub (Publisher-Subscriber) Observer vs Pub-Sub pattern Pub sub system pros and cons ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---pattern/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern"},{"contents":"Quick Chat UniTask 是一個專為 Unity 設計的高效能非同步程式設計函式庫，它以 C# 的 async/await 語法為基礎，旨在提供一個比 Unity 原生 Coroutine (協程) 和內建 Task 更高效能、更低記憶體消耗的非同步解決方案。\n雖然 Unity 2023.1 版本已正式引入 UnityEngine.Awaitable，為 async/await 提供了官方支援，但目前 UniTask 的生態系（例如與其他常用函式庫的整合）依然更加成熟和廣泛，因此在專案中導入 UniTask 仍是主流且可靠的選擇。\nUnity - Manual: Await support 【Unity 2023.1】 C# async/await 正式サポート？ Awaitable を使ってみよう！ Guide UniTask 官方文件對其核心功能有非常清晰的說明，是最好的入門起點：\nCysharp/UniTask (Official GitHub) 若想參考更多教學資源，以下文章也提供了詳盡的介紹與範例：\nUniTask | ScenarioFlow Lab UniTask機能紹介 (Qiita) UniTaskを使おう！ (HackMD) vs. Coroutine Coroutine 是 Unity 原生支援的非同步處理方式。雖然堪用，但在複雜度、性能與可讀性上，UniTask 提供了更現代且強大的解決方案。\n以下我們從幾個關鍵面向進行比較：\n可讀性：從非線性結構到線性邏輯\nCoroutine: 透過 yield return 語法來暫停與恢復。當非同步操作需要串接時（如下載完檔案再解析），程式碼的邏輯會被分割在不同的 yield 點之間，導致結構上的非線性，可讀性隨複雜度下降。 UniTask: async/await 語法將複雜的狀態機轉換隱藏在編譯層面，讓開發者能以從上到下的同步風格編寫非同步程式碼，邏輯始終保持清晰。 回傳值：從迂迴的 Callback 到直接 await\nCoroutine: 無法直接回傳值，需透過 Callback 或外部變數等繁瑣方式取得結果。 UniTask: 使用 async UniTask\u0026lt;T\u0026gt; 可直接 await 非同步函式的回傳結果，語法乾淨俐落。 錯誤處理：從靜默失敗到穩固的 try-catch\nCoroutine: 內部例外 (Exception) 無法被外部 try-catch 捕捉，導致錯誤難以追蹤。 UniTask: 與標準 try-catch 完美整合，任何非同步錯誤都能被穩定捕捉，程式碼更健壯。 功能性：從基礎等待到強大的組合 API\nCoroutine: 僅提供基礎等待功能，應對複雜流程需手動實現。 UniTask: 內建 WhenAll (等待全部)、WhenAny (等待任一)、超時控制等豐富 API，輕鬆應對複雜場景。 生命週期：從強制綁定到靈活可控\nCoroutine: 強制綁定 MonoBehaviour，限制了使用場景。 UniTask: 預設獨立運行，同時提供 CancellationToken 機制，可選擇性地與 GameObject 生命週期綁定，兼具彈性與便利。 性能：從 GC 壓力到零記憶體分配\nCoroutine: StartCoroutine 及部分 yield 指令會產生記憶體垃圾 (GC)。 UniTask: 核心設計目標之一就是「零 GC」，透過 struct 和池化技術大幅降低記憶體開銷，對性能至關重要。 vs. Task 雖然 C# 的 async/await 語法原生支援 System.Threading.Tasks.Task，但在 Unity 開發環境中，直接使用它會帶來幾個關鍵問題。\n不必要的記憶體分配 (GC Allocation) Task 在執行過程中會產生 GC，對於需要穩定幀率的遊戲而言，這會增加效能負擔並可能引發卡頓。\n與 Unity 執行緒模型不相容 Task 被設計在多執行緒環境中執行，它不了解 Unity 只能在「主執行緒」上存取絕大多數 API 的限制。如果 Task 的 await 後續操作被排程到背景執行緒，任何試圖操作 GameObject 或呼叫 Unity API 的行為都會導致例外錯誤。\n非同步取消 (Cancellation) 在 Task-based 的非同步模型中，「取消」是一個至關重要的概念。一個 UniTask 一旦被取消，await 後續的程式碼將不會被執行。因此，最佳實踐是盡可能將 CancellationToken 傳遞給所有非同步方法。如果目標 API 不支援傳遞 CancellationToken，則應在關鍵執行點手動檢查。\n若要將取消時機與 MonoBehaviour 的生命週期掛鉤，可使用 this.GetCancellationTokenOnDestroy() 來取得對應的 CancellationToken。\n特別注意，在 WebGL 這類對性能敏感的平台，建議使用 SuppressCancellationThrow 來避免因取消而拋出 OperationCanceledException，進一步減少效能開銷。\n更多關於取消機制的深入探討與實作模式，可參考此文：\n【C#】async/awaitのキャンセル処理まとめ 手動控制任務完成 (CompletionSource) 有時，我們需要手動控制一個 UniTask 何時完成、成功或失敗，這時 UniTaskCompletionSource 就派上用場了。它可以用來將基於事件或回呼的舊版 API 包裝成現代的 async/await 模式。\n【UniTask】UniTaskCompletionSourceを使って好きなタイミングで結果を確定させるUniTaskを生成する Cancel a CompletionSource with a cancellation 超時處理 (Timeout) 為非同步操作設定超時限制是一個常見需求。\n建議使用 TimeoutController 來管理一組或複雜的超時邏輯。 盡量避免使用 AttachExternalCancellation，除非你非常清楚其底層行為。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---package---unitask/","tags":["Unity"],"title":"Unity - Package - UniTask"},{"contents":"Quick Chat 從 DOTween 轉換到 LitMotion 的過程很順利，特別是看中它「零記憶體配置」（Zero Allocation）的特性。加上它對 UniTask 和 R3 的良好支援。\nGuide GitHub - annulusgames/LitMotion LitMotion Overview | LitMotion DOTweenのイージング一覧を世界一詳しく\u0026amp;分かりやすく説明する | ゲームUIネット Practice 【Unity】2次ベジェ曲線を使ってLitMotionでジャンプ機能を実装する - 原カバンは鞄のお店ではありません。 【Unity】Splineを利用してLitMotionでパス移動を実現する - 原カバンは鞄のお店ではありません。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---package---litmotion/","tags":["Unity"],"title":"Unity - Package - LitMotion"},{"contents":"箱庭工作室 (Miniature Garden Studio) 這是我的工作室名，其核心思想是\n每個創作都是一個精心構築的 箱庭/微型世界，在有限的環境中創造豐富且深度的體驗，讓使用者能夠沉浸其中。\n現實中的箱庭 箱庭（はこにわ，Hakoniwa），它是一種縮小版的庭園或景觀模型。這個概念源於日本，最早用來指代傳統日式庭園的迷你模型，但後來這個詞的應用範圍擴展到了各種縮小版的自然景觀創作。\n遊戲中的箱庭 箱庭設計在遊戲中已成為一種經典理念。\nIGN小课堂#49：箱庭 从沙盒和开放世界谈起，说说日本的箱庭设计理念 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/chat---profile---studio/","tags":["Chat","Profile"],"title":"Chat - Profile - Studio"},{"contents":"Quick Chat 別名方法是一種眾所周知的演算法，用於從任意離散機率分佈中進行恆定時間採樣，該演算法依賴於簡單的預先計算的查找表。\nGuide Alias Method: 非均匀随机抽样算法 Darts, Dice, and Coins: Sampling from a Discrete Distribution Weighted Random: algorithms for sampling from discrete probability distributions mackysoft/Choice jgrapht-core/src/main/java/org/jgrapht/alg/util/AliasMethodSampler.java 務必先觀看\n第一篇文章的漸進思考與核心精神 第二篇文章最後的 Vose\u0026rsquo;s Alias Method 圖解 Example 給定的權重 [0.1, 0.2, 0.3, 0.4]。\n按均值縮放權重： 均值為 : 0.25 縮放後的權重：[0.4, 0.8, 1.2, 1.6] 分類權重到 large 和 small 隊列： 初始狀態：small = [], large = [] 權重 0.4 小於 1，放入 small：small = [0] 權重 0.8 小於 1，放入 small：small = [0, 1] 權重 1.2 大於 1，放入 large：large = [2] 權重 1.6 大於 1，放入 large：large = [2, 3] 構建別名表： 初始狀態：\nprobs = [0.4, 0.8, 1.2, 1.6] aliases = [null, null, null, null] small = [0, 1] large = [2, 3] 處理 small[0] = 0, large[0] = 2：\naliases[0] = 2 probs[2] = 1.2 + 0.4 - 1 = 0.6 small.shift() -\u0026gt; small = [1] 再次分類 probs[2] \u0026lt; 1 放入 small 更新狀態：\nprobs = [0.4, 0.8, 0.6, 1.6] aliases = [2, null, null, null] small = [1, 2] large = [3] 處理 small[0] = 1, large[0] = 3：\naliases[1] = 3 probs[3] = 1.6 + 0.8 - 1 = 1.4 small.shift() -\u0026gt; small = [2] 再次分類，probs[3] \u0026gt; 1 放回 large 更新狀態：\nprobs = [0.4, 0.8, 0.6, 1.4] aliases = [2, 3, null, null] small = [2] large = [3] 處理 small[0] = 2, large[0] = 3：\naliases[2] = 3 probs[3] = 1.4 + 0.6 - 1 = 1.0 small.shift() -\u0026gt; small = [] large.shift() -\u0026gt; large = [] 現在所有 small, large 隊列均已空，構建完成。\n結果： 最終權重：probs = [0.4, 0.8, 0.6, 1.0] 最終別名：aliases = [2, 3, 3, null] 操作： 第一個隨機值 i 用於選擇權重索引。 第二個隨機值 r 用於決定是否使用別名。 case ( i = 3 ) : aliases[3] 為 null，採樣結果為 3 case ( i = 1, r = 0.6 ) : aliases[1] 非 null，且 r \u0026lt; probs[1]，採樣結果為 1 case ( i = 1, r = 0.9 ) : aliases[1] 非 null，且 r \u0026gt; probs[1]，採樣結果為 3 (aliases[1]) Summary probs alias small large [0.4, 0.8, 1.2, 1.6] [null, null, null, null] [0, 1] [2, 3] [0.4, 0.8, 0.6, 1.6] [2, null, null, null] [2] [1, 3] [0.4, 0.8, 0.6, 1.4] [2, 3, null, null] [2] [3] [0.4, 0.8, 0.6, 1.0] [2, 3, 3, null] - - ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/algorithm---sampling---alias-method/","tags":["Algorithm"],"title":"Algorithm - Sampling - Alias Method"},{"contents":"Quick Chat 符號連結本身只是一個檔案，但它的內容指向另一個檔案或資料夾的路徑。當你存取這個符號連結時，作業系統會自動將你導向到它所指向的目標。\n⚠️ 符號連結它只是一個指標，不包含實際的檔案內容。如果你刪除原始檔案，符號連結就會失效。\nWindows ⚠️ Windows 建立符號連結需要 管理員權限\n使用 cmd（需管理員權限）：mklink 使用 PowerShell（需管理員權限）：Create a symbolic link to a file or folder ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/os---file-system---symbolic-link/","tags":["OS","Windows"],"title":"OS - File System - Symbolic Link"},{"contents":"Quick Chat 最近我從 Unity 轉向了 Node.js，因此花了不少時間在 npm 上尋找合適的套件。大部分的 README 寫得很清晰，但也有少數讓人摸不著頭緒。這讓我意識到，README 就是專案的門面。\nGuide 你知道對專案來說，README.md 有多麼重要嗎？ ── 工程師血淚史 README 的藝術 Template README-Template.md GitHub README Templates ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-development---document---readme/","tags":["Software_Development"],"title":"Software Development - Document - README"},{"contents":"Quick Chat 後端：深入且穩定 前端：廣泛且彈性 Roadmap Developer Roadmaps - roadmap.sh GitHub - kamranahmedse/developer-roadmap: Interactive roadmaps, guides and other educational content to help developers grow in their careers. Algorithm fucking-algorithm hello-algo The Algorithms ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/chat---career---software-engineer/","tags":["Chat","Career","Software_Engineer"],"title":"Chat - Career - Software Engineer"},{"contents":"Guide Unity Animation | 動畫 | 15分鐘介紹 Animation Clip、Animator Controller 以及 State Machines Unity Blend Trees | 10分鐘介紹混合樹 1D 和 2D Freeform Directional ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---animation/","tags":["Unity"],"title":"Unity - Basic - Animation"},{"contents":"Quick Chat Rider 能更好處理 Unity 開發環境的大小事，但你知道的費用\u0026hellip; 👀 處理 Renaming 事務一律切到 Visual Studio，因為 VS Code 的支援很不到位。 Field Unity - Scripting API: FormerlySerializedAsAttribute MonoBehaviour Class 現在 Unity 裡對 Class 重新命名（這時 .cs 檔會與 class name 不一致） 到 Visual Studio 裡重新命名 ⚠️ 順序錯誤可能會導致引用噴掉 ⚠️ 步驟 2 先執行會導致 Unity 的 class 檔名會一起變動（有概率會出錯）\nNamespace 有兩個情境\n真的想重新命名 namespace （對著 namespace 直接右鍵重新命名即可） 想把某 Type 歸屬到指定 namespace 情境 2 要使用 Visual Studio 的重構工具\n對著 Type 右鍵 - 快速動作與重構 選擇 移到命名空間（這樣所有的參考都會連動修改） ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---coding---renaming/","tags":["Unity","Visual_Studio"],"title":"Unity - Coding - Renaming"},{"contents":"Quick Chat 在構建過程中，Unity 通過稱為託管代碼剝離的過程刪除未使用或無法訪問的代碼，這可以顯著減小應用程式的最終大小。\nFile -\u0026gt; Build Settings -\u0026gt; Player Settings -\u0026gt; Optimization -\u0026gt; Managed Stripping Level\n⚠️ Managed Stripping Level 等級越高裁剪掉的代碼越多，包體也就越小，但是對應的風險也就更大。 藉由屬性或特殊 XML 配置檔的形式提供註釋，以指示 Unity 連結器要保留代碼庫的哪些部分。 Guide Unity - Manual: Managed code stripping KuraiAndras/LinkerGenerator IUnityLinkerProcessorでCodeStrippingからコードを守る Preserving Preserve attribute ⚠️ [Preserve] 屬性屬於“侵入式”的解決方案，不建議 class Foo { [Preserve] public void PreservedMethod(){} } link.xml 在專案的 Assets 目錄下創建個 link.xml \u0026lt;linker\u0026gt; \u0026lt;assembly fullname=\u0026#34;DOTween\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;Newtonsoft.Json\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;Assembly-CSharp\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;UnityEngine\u0026#34;\u0026gt; \u0026lt;type fullname=\u0026#34;UnityEngine.SpriteRenderer\u0026#34; preserve=\u0026#34;all\u0026#34;/\u0026gt; \u0026lt;type fullname=\u0026#34;UnityEngine.Rigidbody2D\u0026#34; preserve=\u0026#34;all\u0026#34;/\u0026gt; \u0026lt;/assembly\u0026gt; \u0026lt;/linker\u0026gt; ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---coding---managed-code-stripping/","tags":["Unity"],"title":"Unity - Coding - Managed code stripping"},{"contents":"Extracting AssetRipper/AssetRipper Games 28598519a/TSK_AssetDL ZM-Kimu/Blue-Archive-Asset-Downloader Deathemonic/BA-AD ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/assets---game/","tags":["Assets"],"title":"Assets - Game"},{"contents":"Quick Chat 客製化 Unity 官方 / git 直接導入 的 Package\nGuide How can I modify built-in packages? Unity - 如何修改一个 Package 或是如何将 Package Local化 Steps 至 ProjrctRoot\\Library\\PackageCache 找到目標的 Package 剪下貼上至 ProjrctRoot\\Packages 即可 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---package-manager---modify-a-package/","tags":["Unity","Package_Manager"],"title":"Unity - Package Manager - Modify a Package"},{"contents":"Quick Chat Google 停止維護 Game Package Registry (GPR) 導致不能直接使用 Package Manager 導入包。必須到封存檔網站下載「.tgz」手動導入。\nGoogle Unity 套件 Install a package from a local tarball file 其他的相關的 Google Service 依賴(AR/Firebase/Google Play等)也可以用此方法導入。\nConfiguration Assets \u0026gt; External Dependency Manager \u0026gt; Android Resolver \u0026gt; Settings 啟用這三個 Patch\n並至 Player Settings \u0026gt; Publishing Settings 啟用以下選項\nAuto Resolution Assets \u0026gt; External Dependency Manager \u0026gt; Android Resolver \u0026gt; Force Resolve 後會去收集專案所有 Editor 資料夾下的 *Dependencies.xml 加到 mainTemplate 中\n","permalink":"https://HoshikawaRyuukou.github.io/posts/unity-packages-external-dependency-manager-for-unity/","tags":["Unity","Google_Service"],"title":"Unity - Packages - External Dependency Manager for Unity (EDM4U)"},{"contents":"Quick Chat 過去常以為 rebase 是像「剪下貼上」的操作，但實際上更像是「複製貼上」，它會將一系列的 Commit 複製一份，並重新套用在新的基底上，因此會產生新的 SHA-1 值。\n主要情境與特性 歷史紀錄更簡潔：rebase 不會像 merge 那樣產生額外的合併節點（Merge Commit），讓 Commit 歷史紀錄更為線性、乾淨。\n適用於未推送的 Commit：當你想要整理、合併或修改本地端「還沒推送到遠端」的 Commit 時，rebase 是非常實用的工具。\n避免修改已推送的歷史：由於 rebase 會改寫 Commit 歷史，因此 絕對不要 對已經推送到遠端（與他人協作中）的分支進行 rebase 操作，以免造成他人的困擾。\nGuide 另一種合併方式（使用 rebase） git rebase 用法 Extras 如何取消 Rebase 操作 如果你在進行 rebase 時後悔了，可以透過以下兩種方式安全地回溯到操作之前的狀態：\n使用 git reflog 尋找歷史紀錄\n輸入 git reflog，這會列出你所有的 Git 操作紀錄。 找到 rebase 執行前的 Commit ID。 輸入 git reset XXXXXXX --hard 來回溯（其中 XXXXXXX 為該 Commit ID）。 使用 ORIG_HEAD 快速回溯 由於 Git 在執行 reset 等具風險的操作時，會額外將上一個 HEAD 的位置記錄在 ORIG_HEAD 中。因此，你也可以直接執行以下指令來快速達到相同的效果：\ngit reset ORIG_HEAD --hard ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/git---rebase/","tags":["Git"],"title":"Git - Rebase"},{"contents":"Quick Chat 有些環境也稱為合併請求（Merge Request）。\n產品開發中，通常會指定一個分支作為可發布的正式版本分支（例如 master 或 main）。在多人協作時，讓每位開發者都能直接提交（Commit）至這個正式分支並非最佳實踐。\n為了有效管理，可以採用 Pull Request (PR) 的方式來控制權限。當其他開發者完成工作後，他們會發起一個 PR。專案管理者在審核並確認無誤後，即可將其合併，這能確保產品分支始終處於隨時可發布的狀態。\n若您參與開源專案，在建立 PR 前，建議先在本地分支上執行 git rebase 指令，將您的變更建立在最新的程式碼進度之上，這有助於降低審核者的理解與合併難度。\nGuide 與其它開發者的互動 - 使用 Pull Request（PR） ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/github---pull-request/","tags":["GitHub"],"title":"GitHub - Pull Request"},{"contents":"Quick Chat 當你一開始沒 ignore 到某些檔案，後來補上 .gitignore，卻發現 Git 還是繼續追蹤那些檔案。\nSolution # 先清掉 Git 的快取（不會刪檔，只是取消追蹤） git rm -r --cached . # 再重新加入所有檔案（讓 .gitignore 這次能正確發揮作用） git add . # 然後提交變更 git commit -m \u0026#34;Reapply .gitignore rules\u0026#34; ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/git---reapply-.gitignore/","tags":["Git"],"title":"Git - Reapply .gitignore"},{"contents":"Quick Chat 在口語交流中，我們常用 Define 來稱呼，但正式名稱其實是 前置處理器指示詞（Preprocessor Directives）。\n我最近接手一個舊專案時，發現裡面大量使用了 條件式編譯。例如：\n#if DEBUG Console.WriteLine(\u0026#34;Debug version\u0026#34;); #endif 在 Unity 中，這類寫法也經常出現在處理不同平台或環境時：\npublic class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(\u0026#34;Unity Editor\u0026#34;); #endif #if UNITY_IOS Debug.Log(\u0026#34;iOS\u0026#34;); #endif #if UNITY_STANDALONE_OSX Debug.Log(\u0026#34;Standalone OSX\u0026#34;); #endif #if UNITY_STANDALONE_WIN Debug.Log(\u0026#34;Standalone Windows\u0026#34;); #endif } } 前置處理器指示詞並非沒有代價，過度使用會帶來以下困擾：\n編譯版本數量容易爆炸（至少是 2^(指示詞分類數) 種），使得除錯與測試難度上升。 在 Unit Test 中幾乎無法有效使用。 無法透過一般的編譯檢查來捕捉錯誤。 巢狀結構一旦出現，可讀性大幅降低。 最直接的影響就是：問題會被延後發現！\nQuide C# 前置處理器指示詞 macroのカジュアル多用は危険 Conditional Compilation Practice 原則上能避免就避免使用，通常可以透過 條件分支、策略模式 或 依賴注入 來更清楚地表達邏輯，並提升程式的可維護性。\n✅ 允許 — 少量使用 UNITY_EDITOR 在 MonoBehaviour 某些情境下需要針對編輯器做額外處理(客製編輯器)，這算是合理的使用方式：\n#if UNITY_EDITOR ... #endif ✅ 建議 — 降低指示詞的影響範圍 若條件允許，可以透過 介面定義 將影響控制在實例化階段，避免在業務邏輯中直接出現。\n#if UNITY_EDITOR var runner = new EditorRunner(); #elif UNITY_IOS var runner = new IOSRunner(); #elif UNITY_ANDROID var runner = new AndroidRunner(); #endif ✅ 建議 — 善用 ConditionalAttribute 官方文件也建議使用 ConditionalAttribute，可在不污染邏輯的情況下控制程式是否執行。\n[Conditional(\u0026#34;DEBUG\u0026#34;)] private void DebugLog(string message) { Debug.Log(message); } ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---preprocessor-directives/","tags":["Unity","CSharp"],"title":"Unity - Basic - Preprocessor Directives"},{"contents":"Quick Chat Service Locator 是一種 依賴尋找（Dependency Lookup） 的實作方式，它確實屬於控制反轉（IoC）的一種。\n過去我曾頻繁使用這個模式，當時對於 DI（依賴注入）與 IoC 的概念還不熟悉，只覺得它讓依賴的取用變得非常方便，因為你可以在任何地方直接這樣取得所需物件：\nvar target = ServiceLocator.Resovle\u0026lt;Target\u0026gt;(); 然而，這種作法存在幾個顯著問題：\n隱性依賴：由於依賴的取得過程被隱藏起來，程式碼的真實依賴關係難以被一眼識別，增加了閱讀與維護的難度。 打破分層原則：任何元件都可以隨意取得服務，這可能會導致 View 層級的物件存取到不屬於其範疇的業務邏輯，破壞了應用程式的架構分層。 因此，當我對 DI 與 IoC 的概念更加熟悉，並開始使用 DI/IoC Container 後，就逐漸棄用了 Service Locator 這個模式。\nSituation 這次的專案讓我重新思考了 Service Locator 的價值。我發現它非常適合做為從 Singleton 過渡到 DI/IoC Container 的中間階段。\n我們目前專案嚴重依賴 Singleton 模式，團隊成員也已經習慣了這種寫法。若要直接切換到 DI/IoC Container，勢必會引發不小的陣痛期。\n在這種情況下，Service Locator 成了理想的過渡方案，理由如下：\n寫法近似 Singleton：它的使用方式與靜態的 Singleton 模式極為相似，能讓團隊成員無痛轉換，降低學習成本。 快速感受 IoC 好處：儘管只是過渡，但它能讓團隊成員立即感受到集中管理依賴所帶來的便利性，為後續全面採用 DI/IoC Container 鋪路。 集中管理依賴：它提供一個中央註冊點，讓所有依賴關係被統一看管。 Practice 這種模式使用一個中央註冊表（Service Locator）來根據請求返回執行特定任務所需的物件。\n以下是一個簡化版的實作範例，它有別於一般的 IoC Container，具有以下特色：\n不強制介面實作：註冊的物件可以不必實作特定介面。 單純的容器：主要功能就是作為物件的儲存庫。 不使用反射：為避免效能開銷，它搭配一個 Installer（組合根） 來進行物件的註冊。 // 這裡透過 static 達成全域存取 public class ServiceLocator { private static readonly Dictionary\u0026lt;Type, object\u0026gt; instances = new Dictionary\u0026lt;Type, object\u0026gt;(); // 註冊服務 public static void Register\u0026lt;T\u0026gt;(T instance) { instances[typeof(T)] = instance; } // 尋找服務 public static T Resolve\u0026lt;T\u0026gt;() { if (instances.TryGetValue(typeof(T), out var instance)) { return (T)instance; } throw new Exception($\u0026#34;Service of type {typeof(T)} is not registered.\u0026#34;); } // 釋放服務 (可選) public static void Release\u0026lt;T\u0026gt;() { if (instances.ContainsKey(typeof(T))) { instances.Remove(typeof(T)); } } } // 由 Installer 集中註冊物件 public class DemoBasicServiceLocatorsInstaller : MonoBehaviour { public DemoBasicMoneyUI moneyUI; public MoneyType moneyType; public int moneyValue = 100; void Start() { switch (moneyType) { case MoneyType.Real: ServiceLocator.Register\u0026lt;IMoneyFormatConverter\u0026gt;(new RealMoneyFormatConverter()); break; case MoneyType.Coin: ServiceLocator.Register\u0026lt;IMoneyFormatConverter\u0026gt;(new CoinMoneyFormatConverter()); break; default: throw new System.NotImplementedException(); } moneyUI.Show(moneyValue); } } // 在需要的地方從容器取得服務 public class DemoBasicMoneyUI : MonoBehaviour { [SerializeField] private TMP_Text text; private IMoneyFormatConverter moneyFormatConverter; public void Show(int moneyValue) { // 透過 ??= 確保只在第一次使用時尋找服務 moneyFormatConverter ??= ServiceLocator.Resolve\u0026lt;IMoneyFormatConverter\u0026gt;(); text.text = moneyFormatConverter.Convert(moneyValue); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---pattern---service-locator/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Service Locator"},{"contents":"Quick Chat Assembly Definition (asmdef) 檔案是 Unity 用來組織和管理專案程式碼的工具。它能將你的腳本分組，形成多個獨立的「程式集 (Assembly)」。\n在沒有使用 asmdef 的情況下，Unity 會將所有腳本編譯成一個單一、龐大的 Assembly-CSharp.dll 程式集。這會導致兩個主要問題：\n編譯時間長：每次修改任何一個腳本，都必須重新編譯整個巨大的程式集，拖慢開發進度。 程式碼依賴混亂：所有腳本彼此間都可以任意存取，使得依賴關係變得複雜且難以管理。 asmdef 的核心價值就是為了解決這些問題。\nGuide Doc - Assembly definitions Unity中 .asmdef文件的作用 透過 asmdef，你可以將專案切分成邏輯上獨立的程式碼區塊，每個區塊都有自己的 asmdef 檔案，這帶來三大優勢：\n大幅縮短編譯時間 這是 asmdef 最重要的優點。當你只修改了某個程式集的腳本時，Unity 只會重新編譯那個程式集，以及任何依賴它的程式集。沒有被影響的部分則不會被重新編譯，能顯著加快開發迭代的速度。\n改善程式碼結構 asmdef 強制你明確定義程式集之間的依賴關係。一個程式集只能存取它所引用的程式碼，這能避免不必要的依賴，讓專案結構更清晰、更易於維護和重用。\n增強程式碼封裝性 你可以更好地控制程式碼的存取權限，防止內部函式被外部不相關的程式集隨意使用。\nPackage 與 Asmdef 的關係 Unity 的 Package Manager 系統正是建立在 asmdef 的基礎上。每個 Unity 套件都必須使用 asmdef 來定義其程式集結構，確保套件內的程式碼與專案其他部分相互獨立，只透過明確的引用進行互動。\n這也是為什麼你在使用或開發 Unity 套件時，會看到每個功能模組都有其對應的 asmdef 檔案。\n常見的結構：Runtime 與 Editor 在許多 Unity 專案和套件中，最常見的 asmdef 結構是將程式碼區分為 Runtime 和 Editor 兩部分：\nRuntime 程式集\n用途：包含遊戲執行時所需的程式碼，會被編譯進最終的遊戲建置中。 限制：不能引用任何 UnityEditor 相關的程式碼或 API。 Editor 程式集\n用途：包含只在 Unity 編輯器環境中運行的工具程式碼，例如自訂檢視器（Custom Inspector）。 限制：不會被編譯到最終的遊戲建置中。通常會引用對應的 Runtime 程式集，但 Runtime 程式集絕對不能反過來引用 Editor 程式集。 這種結構能確保最終的遊戲建置只包含必要的程式碼，避免錯誤並有效縮小檔案大小。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---assembly-definition-asmdef/","tags":["Unity"],"title":"Unity - Basic - Assembly Definition (Asmdef)"},{"contents":"Quick Chat 為 Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。\n⚠️無法處理已由 Unity 本身處理的文件擴展名。\nGuide Scripted Importers [Unity] 资源工作流程 - ScriptedImporter Example 這裡將 .lua 以 TextAsset\nusing UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, \u0026#34;lua\u0026#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( \u0026#34;text\u0026#34;, subAsset ); ctx.SetMainObject( subAsset ); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---editor---scripted-importer/","tags":["Unity"],"title":"Unity - Editor - Scripted Importer"},{"contents":"Package Samples 對應有些模組的操作比較複雜繁瑣，有時需要有一些 Sample 做參考。官方 Package Manager 有個 \u0026ldquo;半套\u0026rdquo; Sample 工作流，讓人不是很舒服。\n官方文件\nSample 資料夾後面加了波浪號 () 告訴 Unity 忽略 Samples 文件夾中的內容，此類文件夾不使用.meta文件進行跟踪。忽略 Samples~ 對 Package 使用者是好的，畢竟不是每個人都需要。\n但對 Package 開發者，畢竟 Samples 也是要進版控的，而這樣改名的作法會徒增一些重命名的提交也有點煩躁(除非在修改 Sample 的過程中完全不提交)。原先想說寫個 Samples ↔ Samples~ 切換的腳本就好，會一直有 meta 檔的警告(刪掉/改名都還是在)。\n官方作法 論壇中的某篇討論才記載他們的做法(倒是加到文件中阿\u0026hellip;)\n在內部確實使用了名為 Samples 的文件夾 (沒有 Samples~ ) 在推送新包版本之前通過腳本對其進行重命名(透過 CI ) OpenUPM 的作者也是使用類似的工作流，總之我也調整為上述的方式。\n透過 GitHub Actions Workflow 調整目錄名 我不熟 GitHub Actions/ YAML/ 文件操作，但這種初階的操作就交由 chatgpt 代勞，幫我省去不少實驗成本。這裡的操作只是堪用，應該有更好的方式。\n以下是我要求的條件\n想透過 GitHub Actions 中的 workflow 完成 如果 forPackage 分支已存在則將其刪除 從 main 建立新的 forPackage 分支 Assets/Modules 的所有子目錄(同時有 \u0026ldquo;package.json\u0026rdquo; 與 \u0026ldquo;Samples\u0026quot;資料夾)，將該子目錄的 \u0026ldquo;Samples資料夾\u0026rdquo; 重新命名 為 \u0026ldquo;Samples~資料夾\u0026rdquo; 並提交更新 將產出的 yml 做一點微調即可。主要文件操作的出錯率很高，find 指令似乎是有些眉角，等有空再回頭研究。\n想要連接到存儲庫的特定分支並下載特定目錄下的內容 最後調整一下訪問的格式即可。\n透過 Add package from git URL\nHTTPS_URL_Address?path=Target_Path#Branch\nHTTPS_URL_Address : https://github.com/user/repo.git Target_Path : Assets/Modules/Core 該目錄就是有 package.json 那層 #Branch : 指定分支是可選的 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity-package-manager-sample-workflow/","tags":["Unity","Package_Manager"],"title":"Unity - Package Manager - Sample Workflow"},{"contents":"Quick Chat 「在尚未深入依賴注入框架前，我常使用它來管理跨場景的資源。」 「當然，在小專案中，它仍是一個相當方便實用的工具。」 Guide Unity - Scripting API: Object.DontDestroyOnLoad DontDestroyOnLoad 標籤能確保物件在場景切換時不會被銷毀，主要應用於以下三種情境：\n全域管理器：此類物件需要貫穿遊戲始終，例如音效管理器、遊戲設定或玩家數據。標記為 DontDestroyOnLoad 後，這些管理器便能持續發揮功能並保留數據，確保遊戲體驗不間斷。 持久性資料：當有多個場景需要共享同一份資料時，例如玩家的遊戲進度或全域配置設定，可以將儲存這些資料的物件設為 DontDestroyOnLoad，確保不同場景都能存取並更新。 常駐物件：某些物件（如遊戲狀態面板、計時器或得分顯示）需要持續顯示。透過 DontDestroyOnLoad，這些物件在場景切換時不會消失，能保持持續更新。 Notice 雖然 DontDestroyOnLoad 很實用，但使用不當會引發以下問題：\n記憶體洩漏：如果一個 DontDestroyOnLoad 物件在後續場景中不再需要，但沒有手動銷毀，它會一直存在於記憶體中。這會造成記憶體佔用增加，導致遊戲效能下降，甚至出現記憶體洩漏。 場景耦合：DontDestroyOnLoad 會打破 Unity 場景應有的獨立性。當場景之間存在大量共享物件時，會增加它們之間的依賴性（高耦合），使得程式碼難以管理、維護和測試。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---dontdestroyonload/","tags":["Unity"],"title":"Unity - Basic - DontDestroyOnLoad"},{"contents":"Quick Chat 對於軟體模組化，我個人傾向採用漸進式的策略。不同的專案規模，從單一功能的小型專案到多功能的中型專案，各自有其適合的模組化方案。\n在深入探討之前，強烈建議先參考以下連結中的圖表，這對於理解 Clean Architecture 的實際應用細節至關重要：\nCA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture 連結 34章摘要心得 Guide Clean Architecture 模組化 Multiple ways of defining Clean Architecture layers Package by Component with Clean Modules in Java Package by feature or component 垂直切片架構 (Vertical Slice) Restructuring to a Vertical Slice Architecture Vertical Slice Architecture, not Layers! 模組化單體架構 (Modular Monolith) Modular Monolith architecture Thinking 以下我將以一個新的 Unity 專案為例，說明我的模組化實踐過程。\n階段一：專案初期的分層策略 (Package by Layer) 在專案初期，我會採用「依分層封裝 (Package by Layer)」的策略，將整個應用程式劃分為幾個核心模組：\nDomain：包含核心業務邏輯與規則。 Presentation：處理使用者介面 (UI) 與互動邏輯。 App：負責應用程式的特定使用案例 (Use Cases)。 Context：負責依賴注入 (DI)。 它們之間的依賴關係如下：\nApp 依賴 Domain。 App 依賴 Presentation。 Context 負責整合所有模組，並透過依賴注入 (DI) 來建構與串連物件。 對於功能單純的小型遊戲或應用程式，這樣的結構已基本足夠。\n階段二：演進至垂直切片與功能整合 當應用程式規模擴大，需要處理多個複雜功能時，我會將架構從水平分層演進為「依功能封裝 (Package by Feature)」，也就是所謂的「垂直切片 (Vertical Slicing)」。\n在這種策略下，每一個功能 (Feature) 本身就是一個可以獨立開發、測試與運作的完整模組。每個功能模組內部依然可以維持自己的分層結構（如 Domain, Presentation, App）。\n隨著功能模組增加，自然會產生模組間的導航與通訊需求。為了解決這個問題，我會建立一個頂層的 App 模組來負責整合：\n管理路由 (Routing)：負責協調不同功能模組之間的跳轉與資料傳遞。 整合功能 (Integration)：作為應用程式的進入點，並依賴所有需要被整合的功能模組。 這個階段將「功能開發」與「功能整合」明確分離，讓架構能夠隨著專案的複雜度一同成長，兼顧了初期的開發效率與後期的可維護性。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---architecture---modularization/","tags":["Software_Design","Architecture"],"title":"Software Design - Architecture - Modularization"},{"contents":"Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Screen How to capture the screen in Unity (3 methods) ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/unity---basic---misc/","tags":["Unity"],"title":"Unity - Basic - Misc"},{"contents":"Quick Chat 談到 Clean Architecture (CA)，我們總會先看到 Uncle Bob 的這張經典分層圖：\n本文不會逐一詳解 CA 的所有規則與細節，而是更側重於分享它如何改變了我的設計思維，以及在實際開發中的一些經驗與權衡。畢竟，對於追求可擴展性的專案來說，系統架構是確保應用程式能夠持續健康演化的關鍵。\n如果想深入了解 CA 的完整概念，文末的參考資料整理了相當豐富的連結。\nClean Architecture 並非銀彈，導入它需要付出額外的設計與分層成本。但它所倡導的關注點分離、單向依賴和以業務為核心的理念，即使不完全照搬，也能為我們在設計任何規模的系統時，提供一個清晰且強大的思考框架。\nGuide 「這份清單是我從數百篇文章中精選而來，每一篇都相當有價值，建議深入閱讀。」\nBasic Software Architecture - Clean Architecture Clean Architecture Clean architecture for the rest of us GitHub - serodriguez68/clean-architecture: A detailed summary of Clean Architecture by Robert C Martin (Uncle Bob) Clean Architecture の勘所は『鎖国』だ。 搞笑談軟工: 領域邏輯與應用邏輯 Practice Unityを利用した大規模なゲーム開発にクリーンアーキテクチャを採用した話 Getting Started With Clean Architecture for Android [Part 1] Clean Architecture on Frontend Discussion 以下參考資料著重於觀念釐清（可能會帶有較重的教條色彩），以及初期探索時容易踩坑的地方與相關討論串。\nClean Architecture Guide (with tested examples): Data Flow != Dependency Rule Why data layer has a dependency on the domain layer? Do Interactors in \u0026ldquo;clean architecture\u0026rdquo; violate the Single Responsibility Principle? Layer for Managers and Services that require Android Context Why you need Use Cases/Interactors What is the use of DTO instead of Entity? Clean Architecture: Use case containing the presenter or returning data? How to make the controller framework independent in Clean Architecture? Clean architecture - where to put input validation logic? How to pass the android dependent data from data-layer to presentation-layer Thinking 坦白說，我導入 CA 的專案經驗僅限於一個 casino 平台，而該專案最終因資金問題未能持續。因此，我並沒有機會在一個長期運維的產品中，見證最高規格 CA 的完整生命週期。\n即便如此，其中的幾個核心觀念對我的影響依然十分深遠。\n1. 分層與單向依賴：穩定核心的基石 CA 最核心的價值在於依賴原則 (The Dependency Rule)，也就是所有依賴關係都必須指向內部。這帶來了幾個顯著的好處：\n穩定的單向依賴流 紊亂的依賴關係是專案腐化的開端，容易導致「牽一髮而動全身」的窘境。CA 強制依賴方向由外向內，確保了核心的業務邏輯 (Domain) 不會受到外部「易變動」部分（如 UI、資料庫、第三方服務）的影響，從根本上阻斷了不穩定的依賴。\n依賴反轉原則 (DIP) 的實踐 「內層定義介面，外層實作」是 DIP 的精髓。這個設計在需要切換不同實作（例如更換資料庫、Mock 測試物件）時，搭配依賴注入 (Dependency Injection) 就會變得非常靈活、輕而易舉。\n跨層依賴的權衡 在實踐中，DataAccess 的介面通常會直接引用到 Domain 層的 Entity。在參考許多討論後，我認為這是一個可以接受的權衡。因為它的 「上下文單純」 —— Data Access 的實作層只專注於持久化物件與 Entity 之間的轉換，不應包含任何其他的業務邏輯，風險相對可控。\n2. Use Case：讓架構尖叫 Use Case (或稱 Interactor) 是應用程式所有功能的說明書，只要看過所有 Use Case，就能清楚地了解這個系統到底能做什麼。這種風格也被稱為尖叫的架構 (Screaming Architecture) —— 你的架構本身就在吶喊著系統的意圖，而不是它所使用的框架。\n將一個完整的「業務操作」封裝到一個類別中，我直接感受到的好處是：當需求變更時，能夠非常迅速地定位到要修改的程式碼。\n定義「做什麼」，而非「如何做」：Use Case 透過介面隱藏了所有實作細節，讓業務流程的意圖更加清晰。 業務邏輯集中化：所有相關的業務流程、輸入與輸出都集中在一個地方，易於理解與維護。 在這之前，我從未想過將單一業務操作封裝成一個類別。雖然接觸過類似的設計模式（如 Command、Strategy），但它們更偏向功能性或演算法的封裝，不像 Use Case 這樣直接反映了應用程式的需求。\n關於 Use Case 的一些常見討論：\nUse Case 可以依賴其他 Use Case 嗎？ 可以，但應盡量避免。我會將共用的邏輯抽離，並讓被依賴的 Use Case 保持 internal 可見度，限制其使用範圍。\nInput Port (介面) 有必要嗎？依賴方向本來就向內了。 當 Use Case 本身需要被抽象化或替換時（例如在特定情境下使用不同的實作），Input Port 就是必要的。如果沒有這種需求，可以省略以簡化設計。\nUse Case 有哪些常見的寫法風格？ 常見的有兩種：一種是將相關操作組織在一個 Service Class 中，形成方法集；另一種則是遵循 CQRS (Command Query Responsibility Segregation) 風格，將讀取與寫入操作嚴格分離。\n3. Adapter 的威力：隔離所有不穩定 過去我總覺得更換套件（例如 ORM、快取工具）是一件非常棘手的事，每次更換都像一場痛苦的移植手術。\n在理解 CA 後，透過 DIP 搭配 Adapter 模式，可以將所有不穩定的外部依賴（如 Presentation、Database、第三方 Service）安置在應用程式的最外層。當需要更換實作時，只需新增一個對應的 Adapter，而不需要更動任何核心業務邏輯。這讓「更換實作」從一場災難變成了一件輕鬆平常的事。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---architecture---clean-architecture/","tags":["Software_Design","Architecture"],"title":"Software Design - Architecture - Clean Architecture"},{"contents":"Quick Chat 符合 Fail Fast 原則，驗證條件並在不滿足條件時立即停止執行。 增加可讀性(更扁平)，減少了巢狀判斷。 Guide Guard Clause | DevIQ Implementation Patterns: Guard Clause Stop using trivial Guard Clauses! Try this instead Example Guard Clause | DevIQ Extras Guard Class GitHub - ardalis/GuardClauses 將通用的保護子句封裝在一個專門的類是一種很好的做法，可重用邏輯並編寫更具可讀性的保護子句。\nValue Object Stop using trivial Guard Clauses! Try this instead 文章作者避免瑣碎 Guard 的方式，是使用 Value Object，來避免域接受到無效參數。(YT評論區也建議閱讀，有許多不錯的討論)\n但不可否認的 Guard Clause 作法在大多情況下是有益的。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---pattern---guard-clauses/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Guard Clauses"},{"contents":"Quick Chat DTO，即數據傳輸物件，是在系統各層（如 API 層與業務邏輯層）或不同服務之間傳遞資料的專用物件。它像一個純粹的「數據包裹」，只負責承載數據，不包含任何業務邏輯。\nGuide Cutting Edge - Pros and Cons of Data Transfer Objects The DTO (Data Transfer Object) Data Transfer Objects Clean Architecture : why not using the entity as request model of the use case (interactor) Difference between Entity and DTO Advantages 建立清晰邊界，降低耦合：DTO 作為公開的數據契約，讓內部資料庫結構 (Entity) 可以自由修改，而不直接影響外部的客戶端或服務。\n精準控制數據，提升安全性與：只暴露客戶端真正需要的欄位，避免洩漏如密碼雜湊、內部 ID 等敏感或不相關的實作細節。\n優化傳輸效率：可以匯集多個來源的資料於一身，或只傳送部分欄位，以此減少網路請求次數與數據傳輸量。\n簡化序列化：因為 DTO 是單純的數據容器，不含複雜的業務邏輯或循環引用，所以能輕易地被序列化為 JSON 或 XML 等格式，在網路上順利傳輸。\nTrade-off 需要額外定義 DTO 類別與轉換邏輯，增加了程式碼量。在極簡單的應用中可能顯得過度設計。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---pattern---data-transfer-object-dto/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Data Transfer Object (DTO)"},{"contents":"Quick Chat 在 Unity 開發中，MVP（Model-View-Presenter）是我最常用的架構模式。相比之下，MVC（Model-View-Controller）在實作上常有模糊地帶，Controller 容易與 View 過度耦合；而 MVVM（Model-View-ViewModel）則仰賴 Data Binding 機制的支援，會限制 View 的寫法與彈性。\nMVP 的概念相對純粹，能清楚劃分各層的責任。在「關注點分離」（Separation of Concerns）的原則下，MVP 的構成如下：\nModel：負責資料處理與業務邏輯，不涉及畫面呈現，專注於商業規則。 View：負責 UI 與使用者互動。在理想情況下，View 是「被動的」，只根據 Presenter 指令更新畫面，並將使用者操作回報給 Presenter。 Presenter：作為 View 與 Model 的中介者，從 Model 取得資料並整理後交給 View 顯示；同時處理來自 View 的事件並驅動 Model。 Guide 界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 Unravelling MVC, MVP and MVVM 【Unity】MV(R)Pパターンのすすめ Dependency 在 MVP 模式中，Presenter 與 View 的互動方式主要有兩種，其核心差異在於「依賴方向」。\n1. View 依賴 Presenter (Supervising Controller) 在這種做法中，View 會持有 Presenter 的引用。當發生使用者操作（如按鈕點擊），View 直接呼叫 Presenter 的方法處理。\n流程：使用者操作 → View → Presenter → Model → Presenter → View 更新 優點：實作直觀，邏輯流暢。 缺點：View 直接依賴具體 Presenter，降低可重用性，也讓 View 測試變得困難。 2. Presenter 依賴 View (Passive View) 此風格中，Presenter 持有 View 的引用。常見做法是透過介面（Interface）與 View 溝通，但是否需要抽象化，取決於專案需求。\nView 的責任僅在於：\n定義自身能提供的操作（方法）。\n對外發出事件（例如 Observable、UnityEvent、delegate）。\n流程：\n使用者操作 → View 發出事件 → Presenter 監聽並處理 → Model → Presenter 呼叫 View 更新\n優點：\n解耦性：若使用介面，View 可完全獨立於 Presenter，具備替換或重用的彈性。 可測試性：可用 Mock View 單獨測試 Presenter。 缺點 / 實務考量：\n直接依賴具體 View 雖增加耦合，但能減少程式複雜度。 如果僅是 UI「換皮」，通常不會更換整個 View 類別，介面抽象的價值有限。 Presenter 的測試必要性值得思考：若 Model 已測試、View 也有測試，Presenter 多數僅扮演資料轉換與搬運的角色，單獨測 Presenter 的收益未必高。 Example - Passive View public class View : MonoBehaviour { [SerializeField] private Text messageText; [SerializeField] private Button[] playerChoices; [SerializeField] private Button nextButton; private readonly Subject\u0026lt;Choice\u0026gt; playerChoiceSelected = new Subject\u0026lt;Choice\u0026gt;(); private readonly CompositeDisposable disposables = new CompositeDisposable(); public IObservable\u0026lt;Choice\u0026gt; PlayerChoiceSelected =\u0026gt; playerChoiceSelected; public IObservable\u0026lt;Unit\u0026gt; PlayerNextRequested =\u0026gt; nextButton.onClick.AsObservable(); void Awake() { disposables.Clear(); playerChoices[0].onClick.AsObservable().Subscribe(_ =\u0026gt; SelecteChoice(Choice.Rock)).AddTo(disposables); playerChoices[1].onClick.AsObservable().Subscribe(_ =\u0026gt; SelecteChoice(Choice.Paper)).AddTo(disposables); playerChoices[2].onClick.AsObservable().Subscribe(_ =\u0026gt; SelecteChoice(Choice.Scissors)).AddTo(disposables); } void OnDestroy() { disposables.Clear(); } public void SetReady(string message) { messageText.text = message; nextButton.gameObject.SetActive(false); } public void SetResult(string message) { messageText.text = message; nextButton.gameObject.SetActive(true); } private void SelecteChoice(Choice choice) { playerChoiceSelected.OnNext(choice); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/software-design---pattern---model-view-presenter-mvp/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Model View Presenter (MVP)"},{"contents":"Audio 魔王魂 効果音ラボ フリーBGM（音楽素材）無料ダウンロード｜DOVA-SYNDROME フリー効果音素材・無料効果音 Color Coolors Palettable Feature Graphics Google Play Feature Graphics Font 中文免費字體 Google Fonts 2022/0113更新# 36個合法免費高品質字體 fontget LINE Seed Icon ICOOON MONO iconmonstr Flaticon IconKitchen Game-icons.net Image かわいいフリー素材集 いらすとや Unsplash Image API | Free HD Photo API Lorem Picsum Photosku 2023 熱門 47 個可商用無版權免費圖庫懶人包（圖片、圖示、圖標、素材、背景） OKUMONO | フリーイラスト素材サイト。VTuber・配信のサムネイルや画面に。 Textures Poly Haven Misc itch.io Kenney Opengameart ","permalink":"https://HoshikawaRyuukou.github.io/posts/_single/assets/","tags":["Assets"],"title":"Assets"},{"contents":"Github: HoshikawaRyuukou\n","permalink":"https://HoshikawaRyuukou.github.io/about/","tags":null,"title":"About me"},{"contents":"This is the search page, type keywords to search among my articles.\n","permalink":"https://HoshikawaRyuukou.github.io/search/","tags":null,"title":"Search"}]