[{"contents":"Issues 中文顯示問題 在腳本第一行再加上這行 [Console]::OutputEncoding = [System.Text.Encoding]::UTF8 把 .ps1 檔案存成 UTF-8 with BOM。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/os---windows---powershell/","tags":["OS","Windows","PowerShell"],"title":"OS - Window - PowerShell"},{"contents":"Quick 我總是習慣在中英文之間加個順眼的空白，如今我才知道他有 盤古之白 這名頭。\n「盤古之白」這個概念在英文中通常被稱為 Pangu spacing。這個術語用來描述在中文與半形英文字母、數字或符號之間需要插入的空格，以提高排版的可讀性和美觀性。\nGuide 定義：Pangu spacing 指的是在中文和英文（或數字）之間插入的空格，旨在劈開全形字和半形字之間的混沌，使得文本更易於閱讀。\n排版規範：在中英文混排的情況下，通常建議在中文和半形英文字母之間加入空格，例如「當你凝視著 bug，bug 也凝視著你」而不是「當你凝視著bug，bug也凝視著你」。\nExtra GitHub - vinta/pangu.js ","permalink":"https://HoshikawaRyuukou.github.io/posts/chat---misc---pangu-spacing/","tags":["Chat","Misc"],"title":"Chat - Misc - Pangu Spacing"},{"contents":"News AIbase基地 - 让更多人看到未来 通往AGI之路 Audio AI声音建模：MiniMax Audio 一键声音克隆 Coding GitHub项目理解神器：DeepWiki AsyncFuncAI/deepwiki-open Translation SakuraLLM/SakuraLLM zyddnys/manga-image-translator dmMaze/BallonsTranslator ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---tools/","tags":["AI"],"title":"AI - Tools"},{"contents":"Quick Chat ⚠️ 建議使用 Unity 2021 以上開發，我目前使用 Unity 6。 Guide Unity - Manual: Web development Getting started with Unity Web WebAssembly WebGL适配方案概述_抖音开放平台 Template (Unity) Better Minimal WebGL Template Build Export tips - CrazyGames Documentation 小游戏资源部署与缓存_小游戏_抖音开放平台 Host terreng/simple-web-server terreng/sws-unity-plugin Optimization Crazy Web Game Jam 24: Masterclass #1 - Web Optimization - YouTube 性能优化总览_抖音开放平台 提升Unity WebGL游戏启动速度_抖音开放平台 优化普通小游戏内存_抖音开放平台 Unity WebGL 运行时优化建议_抖音开放平台 Unity - Manual: Texture compression in Web Package Manager 停用 不使用的 Built-in 模組 Others Unity发布webgl获取浏览器的URL GitHub - Marinerer/unity-webg Possibly Outdated Unity WebGLビルドメモ - フレームシンセシス Unity 製 WebGL ゲームを AWS でお手軽公開 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---platform---web/","tags":["Unity","Web"],"title":"Unity - Platform - Web - Build"},{"contents":"Quick Chat 紀錄目前在使用的外掛。\nGuide Auto Link Title 自動取得貼上連結的網頁標題，並將其轉換成Markdown格式的鏈接。 Open vault in VSCode 在 VSCode 直接開啟整個 Obsidian Vault。 對於有時要做一些程序性的處理比較方便。 Image Converter 批量處理圖片。 支援剪貼簿直接貼上圖片，並將圖片放置指定位置。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/obsidian---plugins/","tags":["Obsidian"],"title":"Obsidian - Plugins"},{"contents":"Quick Chat ⚠️需要在 Unity 中開啟 Decompression Fallback 功能（GitHub Pages 不支援壓縮）。 ⚠️ 公開的 Repository (Public Repository) 才能免費使用 GitHub Pages。 以下提供兩種簡單方案（暫不涉及 CI 自動化）：\n方法一：獨立 Public Repository 建立一個新的 Public Repository。 將 Unity WebGL 的建置輸出檔案上傳至該 Repository。 在 GitHub 設定中，選擇包含 index.html 的目錄，即可完成部署。 方法二：孤兒分支 (Orphan Branch) 建立並切換到孤兒分支（例如 gh-pages）。 將 Unity WebGL 的建置輸出檔案推送到該分支。 在 GitHub 設定中，選擇包含 index.html 的目錄，即可完成部署。 🤖 以下使用 gemini 生成\n腳本生成 - AI Prompt 目錄結構\nproject-root/ ├── .git ├── Builds/Web/ └── PowerShellCommands/gh-page-command.ps1 我想實作 gh-page-command.ps1 目標是將指定目錄 (Builds/Web/) 內容推送至 git 的 orphan branch (gh-pages) 上\n腳本流程 檢查並建立分支：如果 gh-pages 分支不存在，會自動建立一個新的 orphan branch。 建立 Worktree：建立一個連結到 gh-pages 分支的暫時工作目錄 (gh-pages-worktree)。 同步檔案：將 Builds/Web 的內容複製到 worktree 中。 Commit \u0026amp; Push：在 worktree 中提交並強制推送到 gh-pages 分支。 清理：最後移除 worktree，保持您的主要工作目錄乾淨。 gh-page-command.ps1 # Deploys the content of a directory to a Git branch using git worktree. # Usage: ./gh-page-command.ps1 -SourceDir \u0026lt;path-to-dir\u0026gt; -Branch \u0026lt;branch-name\u0026gt; param ( [string]$SourceDir = \u0026#34;Builds/Web\u0026#34;, [string]$Branch = \u0026#34;gh-pages\u0026#34;, [string]$WorktreeDir = \u0026#34;gh-pages-worktree\u0026#34; ) $ErrorActionPreference = \u0026#39;Stop\u0026#39; # 1. Resolve paths $scriptPath = $MyInvocation.MyCommand.Path $projectRoot = (Resolve-Path (Join-Path (Get-Item $scriptPath).Directory.FullName \u0026#34;..\u0026#34;)).Path $fullSourcePath = Join-Path $projectRoot $SourceDir $fullWorktreePath = Join-Path $projectRoot $WorktreeDir if (-not (Test-Path $fullSourcePath)) { Write-Error \u0026#34;Source directory not found at \u0026#39;$fullSourcePath\u0026#39;\u0026#34; exit 1 } # 2. Cleanup previous worktree if it exists if (Test-Path $fullWorktreePath) { Write-Host \u0026#34;Removing existing worktree directory...\u0026#34; # Use Remove-Item with -Recurse and -Force for robustness Remove-Item $fullWorktreePath -Recurse -Force } # Prune any lingering worktree info from .git git worktree prune # 3. Check if the target branch exists and create it if not $branchExists = git branch --list --all | ForEach-Object { $_.Trim() } | Where-Object { $_ -eq $Branch -or $_ -eq \u0026#34;remotes/origin/$Branch\u0026#34; } if (-not $branchExists) { Write-Host \u0026#34;Branch \u0026#39;$Branch\u0026#39; not found. Creating it as an orphan branch...\u0026#34; # Create an orphan branch without checking it out git switch --orphan $Branch git rm -rf . git commit --allow-empty -m \u0026#34;Initial commit for $Branch branch\u0026#34; # Go back to the previous branch git switch - Write-Host \u0026#34;Orphan branch \u0026#39;$Branch\u0026#39; created.\u0026#34; } # 4. Add the worktree Write-Host \u0026#34;Creating worktree at \u0026#39;$WorktreeDir\u0026#39; for branch \u0026#39;$Branch\u0026#39;...\u0026#34; git worktree add $fullWorktreePath $Branch try { # 5. Copy files to the worktree Write-Host \u0026#34;Cleaning worktree directory...\u0026#34; Get-ChildItem -Path $fullWorktreePath -Force | Where-Object { $_.Name -ne \u0026#39;.git\u0026#39; } | Remove-Item -Recurse -Force Write-Host \u0026#34;Copying build artifacts to worktree...\u0026#34; Copy-Item -Path (Join-Path $fullSourcePath \u0026#34;*\u0026#34;) -Destination $fullWorktreePath -Recurse # 6. Commit and push from the worktree Write-Host \u0026#34;Committing and pushing from worktree...\u0026#34; # Use -C flag to run git commands in the context of the worktree\u0026#39;s directory git -C $fullWorktreePath add . if (git -C $fullWorktreePath status --porcelain) { git -C $fullWorktreePath commit -m \u0026#34;Deploy content to $Branch branch\u0026#34; git -C $fullWorktreePath push -u origin $Branch --force Write-Host \u0026#34;Successfully deployed to $Branch.\u0026#34; } else { Write-Host \u0026#34;No changes to deploy.\u0026#34; } } finally { # 7. Cleanup the worktree Write-Host \u0026#34;Removing worktree...\u0026#34; git worktree remove $fullWorktreePath Write-Host \u0026#34;Deployment script finished.\u0026#34; } ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow--host-unity-web-game-on-github-pages/","tags":["Workflow","Unity","Github"],"title":"Workflow – Host Unity Web Game on GitHub Pages"},{"contents":"News Yucchiy\u0026rsquo;s Note Community unityroom Qiita|Unity Zenn|Unity Unity Learning Materials 「unity」の人気の記事一覧｜note Blog (Enterprise) CyberAgent Developers Blog | サイバーエージェント デベロッパーズブログ QualiArtsエンジニアブログ REALITY｜note Mirrativ Tech Blog Blog (Active) コガネブログ LIGHT11 PG日誌 きゅぶろぐ はなちるのマイノート (:3[kanのメモ帳] やらなイカ？ ねこじゃらシティ 原カバンは鞄のお店ではありません。 Raspberlyのブログ unityでいってみよう！ Blog Game Dev Beginner - Everyone Can Make Games YAMADA TAISHI’s diary 渋谷ほととぎす通信 くものす Real-Man 偵錯桐人 - unity 老刘@开发笔记 L\u0026rsquo;s Blog LianBai Lightjiao的博客 ピクセルブログ Channel Code Monkey M Studio Coco Code Events Unity Meetup Unity Advent Calendar Unityユースクリエイターカップ ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---sites/","tags":["Unity"],"title":"Unity - Sites"},{"contents":"Quick Chat 試過幾款主題，但沒有特別喜歡的，感覺還是用預設主題就好。\n不過，Markdown 的顯示樣式還是想稍微調整一下。\nGuide CSS snippets - Obsidian Help Configuration 開啟 設定。 在 外觀 → CSS 片段 中，點選 開啟片段資料夾。 在該資料夾中建立一個 .css 檔，並寫入自訂的程式碼片段。 回到 Obsidian，於 外觀 → CSS 片段 中，點選 重新載入片段，即可在清單中看到新片段。 開啟對應的切換按鈕以啟用程式碼片段。 Modification H2 與 H3 字體大小太接近 H2 標題下方加一條淡色分隔線 清單項目之間的間距稍微拉開 custom.css .markdown-preview-view h2 { font-size: 1.6em; font-weight: bold; border-bottom: 2px solid var(--background-modifier-border); padding-bottom: 0.2em; margin-bottom: 0.5em; } .markdown-preview-view h3 { font-size: 1.3em; font-weight: bold; } .markdown-preview-view li { margin-bottom: 0.25em; } .markdown-preview-view ul, .markdown-preview-view ol { margin-bottom: 0.5em; } ","permalink":"https://HoshikawaRyuukou.github.io/posts/obsidian---css-snippets/","tags":["Obsidian","CSS"],"title":"Obsidian - CSS Snippets"},{"contents":"Quick Chat 透過移除未使用的 子模組（Submodules），你可以在不刪除整個功能套件的情況下，有效縮減遊戲的最終建置大小。\n這款套件可說是 Unity 6 推出至今，我個人認為最有價值的工具之一。然而，它卻只在 Unity Korea 的 YouTube 頻道上發布介紹，而且幾乎沒有任何宣傳，這點實在令人費解 😂。\n⚠️ 詳細的具體操作步驟，請務必參考官方文件與影片說明。此處僅列出幾個關鍵要點。\nGuide Web Stripping Tool package | Web Stripping Tool | 1.1.0 [꼬꼬유] Web Stripping 툴 패키지를 활용한 빌드 크기 및 로드 시간 최적화 Unity Web Stripping Tool - 초보자용 정리 가이드 Notice 適用於 Unity 6.1 及以上版本。 用於移除 Submodules 而不是整個 Modules。 若使用 2D Rendering 但未使用到 2D Rendering Sorting，則可以僅刪除指定子模組。 剝離過程是在遊戲完成初步建構後進行的，屬於建構管線的 後處理 步驟。 建議將設置文件納入版本控制。 該工具將持續改進，並計劃支持更多子模組。 Workflow 安裝與設置：\n在 Unity 的 Package Manager 中安裝該工具。 啟用「子模組剝離相容性」選項，並設置調試符號為外部。 剖析（Profiling）：\n進行初次建構並運行遊戲，完整測試遊戲的所有功能。 生成 JSON 格式的剖析報告，列出未使用的子模組。 子模組剝離：\n將剖析數據導入工具，選擇需要剝離的子模組。 執行剝離後，生成完整的報告，包括文件變更對比和剝離的子模組清單。 驗證與調整：\n測試遊戲是否正常運行，若發現錯誤，調整剝離清單。 整合到建構流程：\n可啟用「建構後自動剝離」選項，或使用剝離 API 進一步整合至自定義建構流程。 Workflow（Practice） 先 Build 一個 Dev 環境的版本\n不必做最佳化輸出，以快速輸出為目標。 這個版本指示是為了用來測試有什麼 子模組 可以被剝離。 使用這個版本導出可剝離的子模組清單。 我會將壓縮算法的子模組重新納入\n約 0.1 MB 還可以接受。 壓縮算法到導出的階段都可能在調整。 如果真的要保持極限乾淨的包體，之後應該會寫 BuildPipeline。 輸出 Release 版本\n於 Submodules Stripping 面板勾選 Strip Automatically After Build ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package---web-stripping-tool/","tags":["Unity"],"title":"Unity - Package - Web Stripping Tool"},{"contents":"Quick Chat 使用 robocopy 以鏡像方式，將 obsidian-notes 中的 posts 與 images 資料夾，同步到 Hugo 專案的對應目錄。\nOperation 詢問使用者是否要執行同步任務。 設定並驗證路徑，確保來源與目標皆存在。 執行 robocopy 鏡像同步，將來源內容完整覆蓋至 Hugo 專案目標位置。 mirror.bat @echo off setlocal :: Ask if the sync task should be run echo Do you want to run the sync task? (Y/N): set /p RUN_SYNC= if /I not \u0026#34;%RUN_SYNC%\u0026#34;==\u0026#34;Y\u0026#34; ( echo Sync task cancelled. pause goto :EOF ) :: Get the directory of the current script set \u0026#34;SCRIPT_DIR=%~dp0\u0026#34; :: Set relative paths set \u0026#34;SRC_POSTS=%SCRIPT_DIR%..\\obsidian-notes\\blog\\posts\u0026#34; set \u0026#34;SRC_IMGS=%SCRIPT_DIR%..\\obsidian-notes\\blog\\images\u0026#34; set \u0026#34;DST_POSTS=%SCRIPT_DIR%content\\posts\u0026#34; set \u0026#34;DST_IMGS=%SCRIPT_DIR%static\\images\u0026#34; :: Check if source paths exist echo Checking source paths... if not exist \u0026#34;%SRC_POSTS%\u0026#34; ( echo ERROR: Source posts directory not found: %SRC_POSTS% echo Please confirm that the blog-obsidian project location is correct. pause goto :EOF ) if not exist \u0026#34;%SRC_IMGS%\u0026#34; ( echo ERROR: Source images directory not found: %SRC_IMGS% echo Please confirm that the blog-obsidian project location is correct. pause goto :EOF ) echo Source path check passed. echo. echo Starting synchronization... :: Run synchronization echo Syncing posts directory... robocopy \u0026#34;%SRC_POSTS%\u0026#34; \u0026#34;%DST_POSTS%\u0026#34; /MIR echo. echo Syncing images directory... robocopy \u0026#34;%SRC_IMGS%\u0026#34; \u0026#34;%DST_IMGS%\u0026#34; /MIR echo. echo Synchronization complete! pause endlocal ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow--mirror-obsidian-notes-to-hugo/","tags":["Workflow","Obsidian","Hugo"],"title":"Workflow – Mirroring Obsidian Notes to Hugo"},{"contents":"robocopy 全名是 Robust File Copy。 是 Windows 作業系統內建的命令列檔案複製工具。 支援多執行緒、差異複製、恢復中斷等功能。 robocopy source destination /MIR source : 來源資料夾路徑 destination : 目標資料夾路徑 /MIR : 鏡像同步 新增來源有但目標沒有的檔案 覆蓋來源較新的檔案 刪除目標有但來源已刪除的檔案（⚠️注意不可逆） ","permalink":"https://HoshikawaRyuukou.github.io/posts/os---windows---tools/","tags":["OS","Windows","Tools"],"title":"OS - Windows - Tools"},{"contents":"Guide Development tips - CrazyGames Documentation Profiler Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Project Auditor Project Auditor package | Project Auditor | 1.0.1 Unity Project analysis with the Project Auditor - DEV Community ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---optimization/","tags":["Unity","Optimization"],"title":"Unity - Optimization"},{"contents":"Quick Chat 這是我近年於職場上的心態轉變，也算是告別曾經的那份天真👀。\n不再自我感動：職場沒有默契，只有溝通 以前常會想：「我都做到這樣了，應該會被看見吧？」\n但現實往往是——大家都在忙，沒人會有空觀察你、理解你努力背後的細節。\n有額外做，就清楚地說。這不是邀功，是讓資訊透明、讓決策更有依據。\n不再腦補結論：有問題就問，不猜測別人怎麼想 很多時候一句主管的語氣、一個同事的反應，可能讓人開始內心小劇場：\n「是不是我表現不好？他是不是在暗示我？」\n但其實根本沒這麼複雜，有問題就說、想知道就問。\n不確定的事先標註是猜測，別拿來當決策依據。\n不再只看自己的工具箱：用對資源比技術更重要 這是最近一個明顯體悟。某次 server 誤刪資料，技術面很難復原，大家都在討論備份或 rollback 的可能性。但以營運部門的觀點：\n其實有個方式可以救到 70% 關鍵資料，而且成本很低。\n因為他們知道哪些資料「真有價值」。技術不該只解「怎麼做」，更該問「為什麼做、為什麼這樣做比較值得」。\n不要急著找最強的技術解，要先找到對的人問對的問題。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/chat---career---mindset/","tags":["Chat","Career"],"title":"Chat - Career - Mindset"},{"contents":"Quick Chat 「Code Smells（程式碼異味）」是一個軟體工程的術語，指的是程式碼中潛在問題的「警訊」。雖然這些寫法不一定會直接造成錯誤，但它們通常代表設計不良、可讀性差、難以維護或擴充的風險。\n⚠️ 不過在實務上\n**Code Smells 重要，但是否需要處理，要考量 專案體量、維護週期、團隊規模 等因素。 小專案或短期原型，可以容忍一些 Code Smells；而長期、大型專案，則需要更嚴謹地處理。 Guide Code Smells Code Smells Catalog ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---code-smell/","tags":["Software_Design","Code_Smell"],"title":"Software Design - Code Smell"},{"contents":"Quick Chat 副作用（Side Effect）指的是一段程式在執行後，除了回傳值之外還影響了外部狀態。\n在錯誤的位置或缺乏揭露的情況下使用副作用，會造成：\n函式不可預測 測試困難 程式閱讀成本上升 Bug 躲藏不易察覺 Bad Examples function getUserName(user) { saveLog(user); // 副作用：寫入外部 log notifyOthers(user.name); // 副作用：發送通知 return user.name; } Extras 很多時候副作用可能是無法規避的，因此重點不在「禁止副作用」，而是「把副作用設計得可控、可觀測、可預期」。\n較健康的副作用處理策略：\n明確命名：像 updateState, notifyUser, logError 設計邊界：像 useEffect、controller 層 專職處理副作用 ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---code-smell---side-effect/","tags":["Software_Design","Code_Smell"],"title":"Software Design - Code Smell - Side Effect"},{"contents":"Quick Chat 協調者模式，主要用於管理多個獨立服務或元件之間錯綜複雜的互動。\n其核心理念是在系統中引入一個專責的「協調者」（Orchestrator）或「控制器」（Controller）元件，作為整體業務流程的指揮者。\n協調者本身並不執行具體的業務邏輯，而是像導演一樣，負責調度各個「參與者」（Participants）或「服務」（Services）來完成任務。每個參與者專注於自己擅長的部分（例如資料查詢、驗證、計算等），執行完後將結果回傳給協調者。\n協調者則根據這些結果，決定後續該呼叫哪個參與者、是否中斷流程，或如何彙整輸出，以推進整體流程邏輯。如此一來，流程控制與業務邏輯得以明確分離，讓系統更具彈性與可維護性。\nExamples class BaseGame { play() { console.log(\u0026#34;Playing base game...\u0026#34;); const result = this.spin(); return result; } spin() { return { symbols: [\u0026#34;Free\u0026#34;, \u0026#34;Free\u0026#34;, \u0026#34;Free\u0026#34;], freeSpinCount: 3, win: 100, }; } } class FreeGame { play() { console.log(\u0026#34;Playing free game...\u0026#34;); return { win: 200, spins: 6, }; } } class GameFlowController { constructor() { this.baseGame = new BaseGame(); this.freeGame = new FreeGame(); } run() { const baseResult = this.baseGame.play(); let finalResult = { from: \u0026#34;base only\u0026#34;, baseResult, }; if (baseResult.freeSpinCount \u0026gt;= 3) { const freeResult = this.freeGame.play(); finalResult = { from: \u0026#34;base + free\u0026#34;, baseResult, freeResult, }; } return finalResult; } } const controller = new GameFlowController(); const result = controller.run(); console.log(result); ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---orchestrator-pattern/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Orchestrator Pattern"},{"contents":"Quick Chat 前端開發時，「狀態管理」一直是個大哉問。\n本次的應用是 Slot Game，這類應用強調「表現層細節」，所以對於狀態的控制不像一般資料應用一樣單純，需要處理許多細部和即時的變化。\n狀態管理挑戰 響應式 data-binding 限制 :\n若完全依賴響應式 data-binding，容易產生太多「中間態」(例如動畫進行中、結果待顯示、部分組件已經觸發\u0026hellip;等)。 這樣會造成 state 爆炸、難以追蹤維護。 命令式流程控制的必要性 :\n部分場景下，直接用命令式（imperative）流程更有效率。 多組件聯動時的「動畫序列控制」。 一連串的 user action/遊戲事件，需明確依序觸發。 ⚙️ 技術棧一覽 UniTask (異步) R3 (Rx，UniRx 後繼者) VContainer (依賴注入) LitMotion (Tween) YooAsset (資源管理) Newtonsoft Json (Json 解析) Alchemy (編輯器擴充) 專案結構 Modules 主架構 project-root/ ├── _Debug/ # 測試或實驗用模組 ├── App/ # 啟動點與業務邏輯總控 ├── GameAPI/ # 遊戲 API 定義 ├── GameRunner/ # 遊戲平台通用組件 (純 UIComponent) ├── GameStage/ # 遊戲表演組件 (純 UIComponent) └── Shared/ # 共用模組 App：負責組合、調度各個模組，等於是專案的大腦。 GameAPI：只放介面定義，跨模組通訊與擴充。 GameRunner / GameStage：都是純 UIComponent (基本都是 Mono)。 Shared：共用邏輯、工具類、資料結構都放這裡。 _Debug：僅用於測試、debug，正式版本不打包。 Module 模組（以單一模組為例） module-root/ ├── Res/ # 模組獨立資源 └── Scripts/ # 腳本程式碼 ├── Editor/ # 編輯器相關 └── Runtime/ # 執行時相關 Res：模組內專屬資源包。 Scripts/Editor：編輯器工具。 Scripts/Runtime：模組實際邏輯，遊戲執行時會用到的部分。 App-Runtime（運行時架構） App-Runtime-root/ ├── Configs/ # 配置與定義 ├── Services/ # 封裝各種業務操作 ├── Presenters/ # 控制流程、狀態綁定 └── Stores/ # 狀態管理 Configs：所有定義類、配置文件，便於集中管理。 Services：將業務操作進行封裝，利於重用及維護。 Presenters：類似 MVP Pattern 的 Presenter，專注於流程控制和資料流。 Stores：專責狀態儲存，確保資料一致性。 實作體悟 1：實務上的狀態變化 一個操作觸發多處改變（One-to-Many Updates）\n例如：用戶點擊「開始」後，同時啟動動畫、鎖定按鈕、重置分數、播放音效。\n一個改變能被多處觸發（Many-to-One Triggers）\n例如：分數變化可能來自多種事件（贏分、補分、特殊獎勵），這些事件又同時影響相同的分數狀態。\n響應式的場合：狀態需要被多處觀測時 有些狀態會被多個元件同時觀察，並且常常需要被組合運用來驅動畫面邏輯。針對這類情境，我會選擇將相關的狀態邏輯獨立封裝到 Store 內，並採取「單向資料流」設計，結合 RX（Reactive Extensions）等觀察者模式來統一管理狀態變化。\n這種做法有幾個優點：\n狀態變動能集中管理，避免多個來源同時修改導致混亂。 Presenter（或 UI 層）只需要訂閱自己關心的狀態，無需額外管理彼此之間的監聽。 透過 RX 的 stream、pipe、merge、combine 等操作，可以很直覺地將複雜流程串接起來。 // 當 (GameState 變為 Idle) or (舞台表演結束) // SpinButton 變成可互動的 Observable .Merge( appStore.GameStateRP.Select(state =\u0026gt; state == GameState.Idle), gameStageDisplayer.EndStageTrigged.Select(_ =\u0026gt; true)) .Subscribe(gameRunnerSheet.SpinButton.SetInteractable) .AddTo(disposables); // 監聽每個 Update // 當玩家有互動或舞台正在表演，則重置 inactivity 時間 // 超過時間則觸發 inactivity 事件 Observable.EveryUpdate() .Where(_ =\u0026gt; IsUserActive() || IsDisplaying()) .Debounce(TimeSpan.FromSeconds(appConfig.InactivityThresholdSeconds)) .Subscribe(_ =\u0026gt; { confirmDialogScreen.SetActive(true); confirmDialogScreen.SetMessage(APIGameMessagesConstants.MSG_DEMO_TIMEOUT); Observable.Merge(confirmDialogScreen.ConfirmRequested, confirmDialogScreen.CloseRequested) .Take(1) .Subscribe(_ =\u0026gt; { Debug.Log(\u0026#34;User confirmed inactivity timeout, closing application.\u0026#34;); appCloser.CloseApp(); }); }) .AddTo(disposables); 命令式的場合：狀態封閉於單一流程時 有些狀態其實不會到處被訂閱或修改，像是遊戲中的「表演流程」這種緊密耦合、步驟明確的處理，我會直接用命令式的寫法，流程步驟一目了然，也比較方便 Debug 跟維護。\npublic async UniTask RunStep(StateStore stateStore, CancellationToken ct) { // 依據類型分流 if (StateType.IsSpecial(stateStore.Type)) await specialEffectDirector.Run(stateStore.Prev, stateStore.Current, ct); else if (stateStore.Bonus == null) await normalEffectDirector.Run(stateStore.Current, ct); else await bonusEffectDirector.Run(stateStore.Current, stateStore.Bonus.Count, ct); // 執行額外演出 if (stateStore.Prev.Count \u0026gt; 0) await extraEffectDirector.Run(stateStore.Prev, stateStore.Current, ct); // 處理連擊狀態 if (stateStore.Chain != null) { totalScore += stateStore.Chain.Score; scoreSync.OnNext(totalScore); await chainEffectDirector.Run(stateStore.Prev, stateStore.Current, stateStore.Chain, ct); } // 其他事件 if (stateStore.IsBonusTriggered) await bonusTriggerDirector.Run(ct); if (stateStore.Bonus?.ExtraCount \u0026gt; 0) await bonusExtraDirector.Run(stateStore.Bonus.ExtraCount, ct); // 判斷流程結束 if (StateType.IsFinished(stateStore.NextType)) { endEvent.OnNext(Unit.Default); if (stateStore.TotalScore \u0026gt; 0) { await finishDirector.Run(stateStore.TotalScore, ct); resetScore.OnNext(Unit.Default); totalScore = 0; } } } 實作體悟 2：封裝操作 有時候會遇到一種情境：某個 API response 回來的資料，可能同時需要更新多個 store。這時候我會寫一個 service 來專門處理這類「跨多個 store」的初始化或同步邏輯。\n像下面這個例子，就是把 app 初始化時需要設定的東西包成一個 service，讓每個 store 的狀態更新都集中在一起處理，維護起來比較有條理，也比較不容易出錯：\npublic sealed class InitializeApp { //... public void Execute() { //... authStore.SetJwt(jwt, jwtExpiration); gameInfoStore.SetBaseUrl(baseUrl); gameInfoStore.SetGameCode(gameCode); } } 這樣一來，初始化流程不會散落在各個地方，邏輯也比較集中。如果之後有需要擴充或調整，也只要改這個 service 就好，維護起來比較方便。\n實作體悟 3：GameStage 設計成純的 Displayer Displayer 本身完全不負責狀態邏輯、資料處理、流程判斷，它唯一的責任就是「接收訊號，把該演的動畫、音效、特效確實表現出來」。\n這次的設計有幾個核心前提：\n可獨立運作：Displayer 必須能單獨執行，且可以輕鬆指定測試資料進行驗證。 低耦合、高復用性：配置門檻要夠低，能夠在不同場景（正式/測試）下快速被複用，不需額外負擔。 資料格式彈性：資料來源會先轉換成內部專用的表演模型，再交由流程控制模組解讀。這樣一來，就算資料來源或格式有變動，只要維護轉換邏輯即可，大幅減少對後續表現層的影響。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---architecture---unity-slot-game-client/","tags":["Software_Design","Architecture","Unity"],"title":"Software Design - Architecture - Unity Slot Game Client"},{"contents":"Quick Chat 目前並未特別使用進階修圖技巧。若圖片瑕疵可透過簡單塗色與描邊處理，即會嘗試修復。\n若瑕疵較嚴重，則多半直接放棄並重新生成 —— 通常下一張會更好。\nModification 圖片先送入 img2img。 簡單處理：使用 Inpaint sketch（注意不要在 sketch 模式下直接生成）。 複雜處理：使用 photopea-embed 進行手動遮罩或編輯。 完成後再送回 Inpaint 重新生成。 Generation 採樣方法（Sampling method）：DPM++ 2M 時間表類型（Schedule type）：Karras 去雜強度（Denoising strength）建議範圍： 0.2 ~ 0.3：保留原圖整體色彩結構，僅微調瑕疵與過渡區域。 0.3 ~ 0.5：適度改變結構與細節，適合嘗試新的構圖或調整 seed 取得更好結果。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---art---stable-diffusion---inpainting/","tags":["AI","Art","Stable_Diffusion"],"title":"AI - Art - Stable Diffusion - Inpainting"},{"contents":"Package Collection XINCGer/Unity3DTraining killop/anything_about_game baba-s/awesome-unity-open-source-on-github Animation - Tween AnnulusGames/LitMotion Async Cysharp/UniTask Debug yasirkula/UnityIngameDebugConsole Dependency Injection hadashiA/VContainer Dialogue YarnSpinnerTool/YarnSpinner-Unity Editor AnnulusGames/Alchemy Hot Update focus-creative-games/hybridclr IO Cysharp/ZString Newtonsoft.Json git - com.unity.nuget.newtonsoft-json Language phanphantz/ThaiTextCare-for-Unity Localization Lean Localization Logging JoanStinson/UnityLoggerExtended Media yasirkula/UnityNativeCamera Messaging Cysharp/MessagePipe Persistence sabresaurus/PlayerPrefsEditor Resource Management tuyoogame/YooAsset Rx (Reactive Extensions) Cysharp/R3 Social Unity Native Share Plugin Sprite elringus/sprite-dicing State Machine Inspiaaa/UnityHFSM UI mob-sakai/UIEffect mob-sakai/ParticleEffectForUGUI qiankanglai/LoopScrollRect Web psygames/UnityWebSocket gree/unity-webview t-34400/SimpleUnity3DWebView TLabAltoh/TLabWebView ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---packages/","tags":["Unity"],"title":"Unity - Packages"},{"contents":"Quick Chat 在Unity這幾年的發展中，無疑經歷了不少波折\nUnity Runtime Fee 事件 CEO 的騷操作 中國的「團結引擎」，壓縮中國 Unity 原生社群，導致部分獨立開發者出走 Godot Godot 社群越來越活躍 不過我關注的幾個 出走到 Unreal/Godot 的開發者最近似乎都歸隊了，畢竟短期內這塊蛋糕還是有一定份量的😏。\n我覺得 Unity 在 AI 方面的發展稍顯落後，但這或許與整體的開發流程有關。畢竟遊戲畫面的呈現，並不像純前端那樣能完全依靠腳本來開發。\nReleases Unity 版本大致分為 LTS 與 Supported 兩種。\nLTS（Long Term Support）版本\n提供 2 年 的支援期。 適合專案已進入穩定運營，或即將鎖定版本（例如長期營運的線上遊戲）。 重點是穩定性，減少升級成本與風險。 Supported（Update releases）版本\n約一年內會推出多個更新版本。 適合新專案或開發中的專案，追求 最新功能、平台支援 與 效能優化 的團隊。 ⚠️ 只會維護最新版本（例如 6.2 發布後，6.1 將停止維護）。 更多細節可參考 官方說明。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/unity/","tags":["Unity"],"title":"Unity"},{"contents":"Quick Chat 紀錄常用的配置\nConfiguration 避免執行期間變動導致不可預料的問題 Edit \u0026gt; Preferences \u0026gt; General \u0026gt; Script Changes While Playing (Stop Playing and Recompile) IDE 配置出現問題可以嘗試重新生成 Edit \u0026gt; Preferences \u0026gt; External Tools Generate .csproj files for Embedded packages Local packages ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---env---preferences/","tags":["Unity"],"title":"Unity - Env - Preferences"},{"contents":"Quick Chat 有持續關注的遊戲劇情與遊戲設定。\nSeries ブルーアーカイブ (Blue Archive) 威威字幕君的个人空间-威威字幕君个人主页-哔哩哔哩视频 鳴潮 (Wuthering Waves) 鸣学|鸣潮剧情深度解读 モンスターハンター (Monster Hunter) 艾森巴赫 - YouTube ","permalink":"https://HoshikawaRyuukou.github.io/posts/acg---game---story/","tags":["ACG"],"title":"ACG - Game - Story"},{"contents":"Quick Chat ScriptableObjects 的主要用例是：\n在編輯器會話期間儲存和儲存資料。 將資料保存為專案中的資產以便在運行時使用。 Guide Unity - Manual: ScriptableObject Notice Editor Play Mode Persistence 在編輯器中進入「播放模式」(Play Mode) 時對 ScriptableObject 實例（.asset 文件對應的記憶體物件）所做的修改，在退出播放模式後會被保留下來。 如果需要在 Play Mode 中臨時修改數據進行測試，考慮使用 Instantiate() 創建 ScriptableObject 的副本來操作，這樣修改就不會影響原始的 .asset 文件。 Runtime Changes in Builds 在建構出的遊戲版本 (Build) 中，於執行期間對 ScriptableObject 實例所做的修改不會被保存回原始的資產文件。當遊戲關閉並重新啟動後，ScriptableObject 會恢復到建構時的初始狀態。 對於需要持久化的數據，應使用其他儲存機制，例如 PlayerPrefs、儲存為 JSON/XML/二進位檔案，或使用資料庫。 ScriptableObject 可以在執行期被修改，用作**單次遊戲會話（Session）**內的共享狀態容器，但要知道這些變更不會自動存檔。 Asset vs. Instance Confusion 多個地方直接引用同一個 ScriptableObject .asset，它們實際上都指向記憶體中的同一個共享實例。 對於實現全局配置或共享狀態非常有用。 如果每個使用者擁有獨立的數據副本，則需要在執行期 Instantiate() 這個 ScriptableObject 來創建副本。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---scriptableobject/","tags":["Unity"],"title":"Unity - Basic - ScriptableObject"},{"contents":"Quick Chat 我目前在 Windows 環境下，會依需求在 Visual Studio 與 VS Code 之間切換：\nVisual Studio\n專案初期建置 需要進行檔案或命名重構 (renaming) VS Code\n需要使用 GitHub Copilot 時 Configuration - VS Code .NET SDK 安裝 前往 .NET 官方下載頁面 下載對應版本 選擇對應平台的 SDK： Mac M 系列 (M1/M2) ➔ 安裝 Arm64 版本 其他 Mac 型號 ➔ 安裝 x64 版本 Windows ➔ 安裝 x64 版本 安裝完成後 重新啟動電腦，以讓環境變數生效 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---env---ide/","tags":["Unity","VScode","Visual_Studio","Mac","Windows"],"title":"Unity - Env - IDE"},{"contents":"Quick Chat 近幾年 AI 發展一日千里。😅\nGuide Artificial General Intelligence（AGI） AGI 就像能像人類一樣思考和學習的 AI。與目前只能處理特定任務的 AI 不同，AGI 能適應各種情境、學習新知、獨立思考並解決問題，是人工智慧的終極目標。\nEdge Computing 邊緣運算就是讓資料在靠近來源端的地方處理，而非全部送往遠端伺服器（雲端）計算。例如，自駕車能即時處理感測器資料，更快做出決策，減少延遲並提升效率。此技術廣泛應用於自駕車、智慧工廠、AR/VR、智慧家庭等需要即時反應的領域。\nRetrieval-Augmented Generation（RAG） RAG 就是讓 AI「先查資料再回答」，不單靠自身記憶。傳統 AI 模型可能因資訊過時而回答不準確，RAG 則會先查找最新資料後再生成回應。這讓它特別適合問答系統、知識搜尋、技術支援等需要即時可靠資訊的應用。\nMultimodal 多模態 AI 能同時理解和處理多種資料，如文字、圖片、聲音和影片。相較於只專注單一資料的傳統 AI，多模態 AI 能整合不同資訊，對世界的理解更全面，並執行更複雜的任務。\nNatively Multimodal 「原生多模態」是指模型從設計之初就支援多模態，因此能更自然、高效地跨模態理解與生成資訊。\nGemini 2.0 Flash - 用嘴 P 圖的這一天真的來了！超強多模態 Gemini AI 讓一票設計師默默把繪圖板拿起來邊啃邊思考人生 ~\nGPT 4o 原生多模態圖片生成 - OpenAI重大更新，降维打击，自然语言绘图功能修改图片功能跨代提升，真正的多模态，从此人人都是设计师\nModel Context Protocol（MCP） Function Calling、MCP和A2A的核心原理与区别 模型上下文協議（MCP）由 Anthropic 提出，是一種規範 AI 模型與外部工具、資料互動的開放標準。它像 AI 的「萬用轉接頭」，透過統一規範，讓 AI 無縫存取 API、資料庫與應用程式，大幅提升開發效率與彈性。\nExtras 一小時略懂 AI｜GPT、Sora、Diffusion model、類器官智慧OI、圖靈測試、人工智慧史 【人工智能】模型压缩四大方法概述 | 量化、剪枝、蒸馏和二值化 | 模型瘦身 | 降低精度 | 速度提升 | 知识蒸馏 | 温度参数 | XNOR | 优缺点 | 发展方向 Gemini逆袭Controlnet？扩散模型和自回归模型的真正秘密 ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---common/","tags":["AI"],"title":"AI - Common"},{"contents":"UNT0023 Coalescing assignment on Unity objects 合併賦值運算子 ??= 是 C# 8.0 引入的運算子，其功能是：如果左側運算元為 null，則將右側運算元的值賦給左側運算元。\n然而，在 Unity 中直接對 Unity 物件 (如 GameObject、Component 等) 使用這個運算子可能會導致問題，因為：\nUnity 物件的特殊生命週期：Unity 物件即使被銷毀，在 C# 層面的變數可能不會自動設為 null，而是成為\u0026quot;偽 null\u0026quot;物件。\n自訂的 null 檢查行為：Unity 覆寫了 == 運算子，使得對已銷毀的 Unity 物件進行 null 檢查時會返回 true，但 `?? 運算子使用的是底層的 null 檢查機制。\n使用明確的 null 檢查 private Rigidbody rb; void Start() { if (rb == null) { rb = GetComponent\u0026lt;Rigidbody\u0026gt;(); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---coding---warnings/","tags":["Unity"],"title":"Unity - Coding - Warnings"},{"contents":"Quick Chat Unity Package Manager (UPM) 的設計理念，是向現代軟體開發的 「套件管理系統」 看齊，最主要的借鏡對象就是網頁開發領域的 NPM (Node Package Manager)。\n模組化：不同功能（像是 2D 工具、Timeline、Addressables）都能獨立存在，更新或安裝時不會牽動整個專案。 可控版本：可以指定版本，就像你在 npm 裡選擇某個 library 的版本，確保團隊成員與 CI 環境一致。 遠端來源：除了 Unity 官方 registry，也可以掛上私有 registry，甚至用 Git URL 或本地資料夾引入。 幾個重要觀念：\n所有透過 UPM 安裝的套件都會被存放在 Packages 資料夾。 Packages 是唯讀的，不過仍有方式能夠修改。 UPM 的主要使用情境是管理可重用的「功能模組」，這些通常以程式碼為核心。而遊戲專案中獨特的、需頻繁修改的藝術素材 （如模型、貼圖、音效），其歸宿依然是傳統的 Assets 資料夾。 Guide 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM 【Unity】Package Manager活用術 使用OpenUPM发布自己的Unity项目 Installing Packages using UPM Package manager -\u0026gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -\u0026gt; Packages: My Registries -\u0026gt; Install ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package-manager/","tags":["Unity","Package_Manager"],"title":"Unity - Package Manager"},{"contents":"Guide Organizing Your Unity Project — Content vs Feature Folders Organizing Project Folder Structure: Function-Based vs Feature-Based Content-Based（依內容分類） 特點 以「資源類型」來劃分資料夾，例如腳本、材質、模型等。 缺點 同一個功能可能分散在多個資料夾中。\n例如你想找「商店系統」的 prefab、script 和 UI，可能得在三、四個資料夾中翻找。 範例 Assets/ ├── Materials/ ├── Models/ ├── Textures/ ├── Scripts/ ├── Animations/ ├── Prefabs/ ├── Audio/ Feature-Based（依功能分類） 特點 以功能模組為單位集中管理相關資源。 適合模組化開發，有助於封裝、重用與搬移。 找特定功能時，所有相關資源都集中在一起，不需東找西找。 缺點 相同類型的資源（例如所有動畫或音效）會分散各處，不利統一管理。\n（不過透過 Editor 的搜尋功能，其實影響不大。） 若模組間耦合度高，可能導致功能邊界模糊。 範例 Assets/ ├── Shop/ │ ├── Scripts/ │ ├── Prefabs/ │ ├── UI/ ├── Player/ │ ├── Scripts/ │ ├── Animations/ │ ├── Prefabs/ ├── Inventory/ │ ├── Scripts/ │ ├── UI/ Hybrid（混合式） 特點 以 Feature-Based 為主體。 共用資源集中放置於 Common 或 Shared 資料夾中，避免重複。 範例 Assets/ ├── Common/ │ ├── Materials/ │ ├── Fonts/ │ ├── Audio/ ├── Player/ │ ├── Scripts/ │ ├── Prefabs/ ├── Shop/ │ ├── Scripts/ │ ├── UI/ 實踐建議 小型專案或原型（Prototype）建議先採用 Content-Based 結構，快速上手。 專案逐漸擴大後，可以逐步轉向 Feature-Based，以利管理與維護。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---project-structure/","tags":["Unity"],"title":"Unity - Project Structure"},{"contents":"Description 85. 最大矩形 Sample input matrix = [ [1,0,1,0,0], [1,0,1,1,1], [1,1,1,1,1], [1,0,0,1,0] ] output 6 Key points Solution 1 - 暴力解 檢查矩陣中所有可能的矩形，並計算每個矩形是否符合條件。 對每個可能的矩形進行迴圈遍歷。 計算該矩形內的元素是否符合條件。 複雜度 m 為 row 的長度 ，n 是 column 的長度 時間複雜度：O(m^2 x n^2) 空間複雜度：O(m x n) Solution 2 - 單調棧 將原矩陣根據各 row 提取出數個高度(連續的1)陣列。 便可將問題拆解成數個 84 題。 推導 Step Matrix Row heights[] result by No.84 1 [1,0,1,0,0] [1, 0, 1, 0, 0] 1 2 [1,0,1,1,1] [2, 0, 2, 1, 1] 2 3 [1,1,1,1,1] [3, 1, 3, 2, 2] 6 4 [1,0,0,1,0] [4, 0, 0, 3, 0] 4 最大矩形面積 = 6\n複雜度 m 為 row 的長度，n 是 column 的長度 時間複雜度：O(m x n) 空間複雜度：O(m) ","permalink":"https://HoshikawaRyuukou.github.io/posts/leetcode-85---maximal-rectangle/","tags":["LeetCode","Algorithm"],"title":"LeetCode 85 - Maximal Rectangle"},{"contents":"Description 84. 柱状图中最大的矩形 Sample input heights = [2,1,5,6,2,3] output 10 Key points 目標是 找到每個柱子能擴展的最大寬度，然後計算以該柱子為高度的最大矩形面積。 Solution 1 - 暴力解 對於每個 heights[i]，向 左、右 擴展，直到遇到比它矮的柱子。 左邊界 (left)：找第一個小於 heights[i] 的索引 右邊界 (right)：找第一個小於 heights[i] 的索引 寬度 (width)：width = right - left - 1 面積 (area)：area = heights[i] * (right - left - 1) 推導 i heights[i] left right width area 0 2 -1 1 1 2 1 1 -1 6 6 6 2 5 1 4 2 10 3 6 2 4 1 6 4 2 1 6 4 8 5 3 4 6 1 3 最大矩形面積 = 10\n複雜度 時間複雜度：O(n^2) 空間複雜度：O(n) Solution 2 - 單調棧 單調棧 : 棧內元素 會按照 遞增/減順序 存放\n使用 單調遞增棧（Monotonic Increasing Stack） 當 遇到一個比棧頂元素小的數，意味著 棧頂柱子找到了右邊界 右邊界確定時，順便出棧，並計算面積 推導 設定 stack = [] 為了確保最後能計算所有矩形，在 heights 末尾補 0，確保最後所有柱子都會出棧。 i heights[i] Stack (i) action area 0 2 [0] 入棧 1 1 [] 出棧 (2 找到右邊界) 2 * (1 - 0) = 2 1 1 [1] 入棧 2 5 [1,2] 入棧 3 6 [1,2,3] 入棧 4 2 [1,2] 出棧 (6 找到右邊界) 6 * (4 - 3) = 6 4 2 [1] 出棧 (5 找到右邊界) 5 * (4 - 2) = 10 4 2 [1,4] 入棧 5 3 [1,4,5] 入棧 6 0 [1,4] 出棧 (3 找到右邊界) 3 * (6 - 5) = 3 6 0 [1] 出棧 (2 找到右邊界) 2 * (6 - 1) = 8 6 0 [] 出棧 (1 找到右邊界) 1 * (6 - 0) = 6 最大矩形面積 = 10\n複雜度 時間複雜度：O(n) 空間複雜度：O(n) ","permalink":"https://HoshikawaRyuukou.github.io/posts/leetcode-84---largest-rectangle-in-histogram/","tags":["LeetCode","Algorithm"],"title":"LeetCode 84 - Largest Rectangle in Histogram"},{"contents":"Search Gelbooru image search Danbooru image search キャラ誕 アニメ漫画ラノベ キャラクター誕生日カレンダー Translation Fast manga translator \u0026amp; Translations in Multiple Languages ","permalink":"https://HoshikawaRyuukou.github.io/posts/acg/","tags":["ACG"],"title":"ACG"},{"contents":"Antivirus DefenderUI - Unlocks the full power of Windows Defender with an intuitive, streamlined interface. Automation taojy123/KeymouseGo Batch Save All Resources Context BluePointLilac/ContextMenuManager Diagram 只會用 Office 畫流程圖？許多人試用過這個後直呼回不去了 👍 | Draw.io 教學 postspark Disk WizTree - The Fastest Disk Space Analyzer Document HackMD：協作 Markdown 文件，分享知識的平台 Media - Image Spritesheet Cutter texture packer Atlased Media - Speech jianchang512/stt Media - Video 如何安裝FFmpeg ScreenToGif Twitter 影片下載器 VLC media player Tyrrrz/YoutubeDownloader mifi/lossless-cut CapCut Andrews54757/FastStream Message Emojipedia Network rejetto/hfs terreng/simple-web-server emanuele-f/PCAPdroid Package Manager marticliment/UniGetUI Translation 沙拉翻譯：聚合字典 、劃詞翻譯 \u0026amp; 查詞 - Chrome 線上應用程式商店 dmMaze/BallonsTranslator Search Felo - 您的免費 AI 搜尋引擎 Site 史上最簡單「一頁式網站」建置工具！ | Google Sites 協作平台快速上手 Misc 網路資源列表| DeTools ","permalink":"https://HoshikawaRyuukou.github.io/posts/tools/","tags":["Tools"],"title":"Tools"},{"contents":"Quick Chat ⚠️ 這是一篇新手導引，目的不在於精準解釋。 ⚠️ Checkpoint 一般會提供推薦的參數設置，建議依據模型的特性調整，以獲得最佳效果。 Resources Civitai: The Home of Open-Source Generative AI Checkpoint 決定生成圖片的基礎風格。\n寫實風格 (Photorealistic) 動漫風 (Anime) 油畫風格 (Painting) 科幻賽博龐克 (Cyberpunk) 像素風格 (Pixel Art) LoRA 輕量化微調模型可額外載入來增強特定風格或角色。\n簡單的比喻來形容 LoRA 模型，那就是「濾鏡」 Embedding 增強對某些 Prompt 的理解。\nVAE 提高圖片細節與顏色準確度。\n📝 部分 Checkpoints 會內建（Baked）VAE，如使用外部 VAE，請確認是否需要覆蓋內建版本。 ⚠️ 如果發現圖片的型都對，但只有顏色壞掉，通常都是 VAE 的問題。 Resolutions 不同種類的 Checkpoints 建議的解析度會有所不同\nSD 1.5 512 x 512 : 1:1 512 X 768 : 2:3 SDXL 640 x 1536 = 5:12 768 x 1344 = 4:7 832 x 1216 = 13:19 896 x 1152 = 7:9 1024 x 1024 = 1:1 1024 x 1536 = 2:3 Sampler + Schedule Sampler 是從雜訊圖到成品的去噪算法。\n快速收斂 – 能迅速找到解答，適合驗證創意和想法。 高品質收斂 – 需較長時間，但能提供更精確結果。 無固定收斂 – 無明確收斂條件，為創新提供更大空間。 Schedule 是從雜訊圖到成品的去噪程度。\n📝 常用組合\nEuler A Automatic DPM++ 2M Karras DPM++ SDE Karras Steps 從雜訊圖到成品的迭代次數。\n⚠️ 步數過少可能導致產生的影像品質不佳。 ⚠️ 步數過多可能使影像產生過程變得冗長，但未必能提升品質。 📝 建議從較低的步數開始，例如 15 或 20。 CFG Scale 遵循 Prompt 的程度。數值越大，產生的影像與文字提示的相關性越高。\n⚠️ 但當數值過大時可能會出現過度飽和或不自然的情況。 📝 建議從較低的 CFG 比例值開始並增加它，直到對結果滿意為止。 📝 沒有最佳值，要根據模型的不同來設定不同的值。 📝 常用區間：3 ~ 7 Seed 用於生成雜訊圖。\n⚠️ 當圖片大小改變時所生成的雜訊圖也會有差異(即使比例一樣)。 📝 使用相同的 Seed 可重現相同圖片(前提是設備/環境需一致)。 📝 設為 -1 為隨機。 📝 固定 Seed 進行實驗：在進行圖像生成時，建議固定一個 Seed，然後調整提示詞或其他參數，以便觀察這些變化對最終圖像的影響。 Clip Skip 調整生成圖像過程中對提示詞的處理方式。\n📝 現實系建議設為 1。 📝 動畫風建議設為 2。 Prompt 不同的 Checkpoints 對提示詞的理解會有所不同，選對模型才能產生最好的效果。 從左到右的順序來解析提示詞，越前面的詞影響越大，越後面的詞影響越小。 正向 Prompt：描述想要的內容。 負向 Prompt：描述不想要的內容。 BREAK：可用來分隔不同場景或主題。 數值控制權重：調整提示詞的影響力，數值越高影響越強。例如： (beautiful:1.5)：增強 \u0026ldquo;beautiful\u0026rdquo; (dark:0.8)：減弱 \u0026ldquo;dark\u0026rdquo; 提示詞應該從少量開始，逐步增加，這樣才能確保： 確定哪些詞有效 避免無效詞 確保 Prompt 保持清晰，容易控制風格 Illustrious XL 提示 (+ 更新！) NOOBAI XL快速指南 Settings Saving images \u0026gt; Saving images/grids Images filename pattern : [datetime]-[seed] Add number to filename when saving : 反選 這樣避免整合圖片時發生亂序。 Extras img2img - inpaint ControlNet ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---art---stable-diffusion---quick-start/","tags":["AI","Art","Stable_Diffusion"],"title":"AI - Art - Stable Diffusion - Quick Start"},{"contents":"Quick Chat ⚠️ 以下皆須安裝指定版本不可貿然升級。\n目前產圖只使用到 Forge + SDXL 。\nLocal deployment nvidia 驅動更新至最新 檢查顯卡支援的最高 cuda 支援: nvidia-smi 安裝 CUDA 12.1 顯示 cuda 編譯工具的版本信息: nvcc --version 安裝 [stable-diffusion-webui-forge] Google Colab gutris1/segsmaker 配置 Civitai API Key Civitai 網站 Menu \u0026gt; Account Settings(齒輪 icon) \u0026gt; API Keys Extensions DominikDoom/a1111-sd-webui-tagcomplete Physton/sd-webui-prompt-all-in-one Bing-su/adetailer yankooliveira/sd-webui-photopea-embed ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---art---stable-diffusion---env/","tags":["AI","Art","Stable_Diffusion"],"title":"AI - Art - Stable Diffusion - Env"},{"contents":"Quick Chat 目前 Stable Diffusion 只拿來自娛自樂 😃。\nCore Working Principles Stable Diffusion 主要包含三個核心技術：\n前向擴散（Forward Diffusion） 先從大量圖片資料集中學習圖片特徵。 然後，系統會逐步加入高斯雜訊（Gaussian Noise），使圖片變得模糊、無法辨識。 最後，這個過程會讓圖片變成完全的純雜訊（random noise）。 反向去噪（Reverse Denoising / U-Net） Stable Diffusion 學習如何逆向去噪，一步步從雜訊還原出清晰的圖片。 這部分的關鍵是 U-Net 神經網路架構，它可以在多層次的細節中，捕捉圖片的各種特徵。 文本引導（Text Conditioning / CLIP） Stable Diffusion 之所以能生成符合指令的圖片，是因為它使用了CLIP（Contrastive Language-Image Pretraining）。 CLIP 會將文字轉換成向量表示（latent embeddings），這些向量再指導模型生成符合描述的圖像。 Diagram Improving Diffusion Models as an Alternative To GANs, Part 1 Extras Re: [問題] AI 風格怎麼了嗎？為什麼容易膩？ - 看板C_Chat - PTT網頁版 ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---art---stable-diffusion/","tags":["AI","Art","Stable_Diffusion"],"title":"AI - Art - Stable Diffusion"},{"contents":"Configuration 在 GitHub 上設定 SSH Key 主要有兩個情境：\n1. 新增至個人帳戶 適用情境：您需要透過 SSH 存取您個人帳戶下所有具備權限的儲存庫 (Repository)。 設定位置：GitHub \u0026gt; Settings \u0026gt; SSH and GPG keys 2. 新增至組織的 Deploy Key 適用情境：您的 SSH Key 僅需存取組織下某個特定的儲存庫，而非整個帳戶。 設定位置：GitHub 組織 \u0026gt; 目標 Repository \u0026gt; Settings \u0026gt; Deploy keys ","permalink":"https://HoshikawaRyuukou.github.io/posts/github---ssh-key/","tags":["Github"],"title":"Github - SSH Key"},{"contents":"Quick Chat 當 main 分支有 push，或有 pull request 時，會自動用 Hugo 生成靜態網站，並將 public 目錄的內容部署到 GitHub Pages。\nOperation 檢出程式碼（含 submodules，全歷史） 安裝 Hugo（最新版、Extended 版） 建置網站（hugo --minify 壓縮輸出） 部署到 GitHub Pages（僅 main 分支才執行部署） gh-pages.yml name: github pages on: push: branches: - main pull_request: jobs: deploy: runs-on: ubuntu-22.04 steps: - uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v4 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow--build-and-deploy-hugo-site/","tags":["Workflow","Hugo","Github"],"title":"Workflow – Build and Deploy Hugo Site"},{"contents":"Quick Chat Hugo 是一款以 Go 語言編寫的 靜態網站生成器（Static Site Generator, SSG），特色是 速度極快、部署簡單，且不依賴後端伺服器程式。\n對於非前端專業的我來說，Hugo 最大的優勢在於：能專注於以 Markdown 撰寫內容，不必過度投入在前端細節。當然，若有需要，也能自製或改造主題。\n建議新手可以先嘗試以下功能完整且持續維護的主題：\nadityatelange/hugo-PaperMod nunocoracao/blowfish Guide The world’s fastest framework for building websites | Hugo Hugo 從零開始：環境安裝（Windows） Environment 從 Hugo GitHub Release 下載執行檔（建議選擇 hugo_extended 版本） 設置環境變數 常用指令： hugo version：檢視 Hugo 版本 hugo server：本地預覽網站 Theme ⚠️ 安裝主題前，請先閱讀該主題作者的安裝與配置文件（不同主題的流程可能略有差異）。 主題資源：Hugo Themes 本 blog 主題：hoshikawaryuukou/hugo-theme-cactus 是基於以下 repository 修改： monkeyWzr/hugo-theme-cactus OmeletWithoutEgg/hugo-theme-cactus 小幅修改主題 ⚠️ 不要直接修改主題原始檔案。\n若需要修改，請將要編輯的文件 依相同資料夾結構 複製到專案根目錄，Hugo 會依模板查找優先順序載入你修改的版本。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/hugo/","tags":["Hugo"],"title":"Hugo"},{"contents":"Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---media/","tags":["Unity"],"title":"Unity - Basic - Media"},{"contents":"Guide Editor 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them? EditorBuildSettings Example ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---editor/","tags":["Unity"],"title":"Unity - Basic - Editor"},{"contents":"Guide 【Unity】3つだけでいい!?覚えるべきUIアンカー 【Unity基礎】スマホ向けゲームUIの作り方！基本的なUI配置から複数解像度対応まで解説 Master your Unity UI Buttons! - Unity UI tutorial How to scale Unity UI objects for every screen - Unity UI tutorial Canvas Designing UI for Multiple Resolutions Unity Canvas Scaler 组件的使用 Unity分辨率适配方案设置 Material Unity中，UI反向Mask效果（图片挖洞） Text 【Unity编辑器扩展】艺术字/自定义图片字体生成工具 【Unity】自作フォントを作成してTextで表示する方法 Unity中自制UGUI艺术字体（位图字体）（Bitmap Font Generator） TextMeshPro TextMeshPro Anatomy [Unity干货]使用TextMeshPro动态字体节省时间 【Unity】TextMesh Proで数字をスプライト表示する ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---ui/","tags":["Unity"],"title":"Unity - Basic - UI"},{"contents":"Error Error : Failed to parse binary data file Build/xxx.data.br\u0026hellip; Failed to parse binary data file Build/web.data.br (with \u0026ldquo;Content-Type: null\u0026rdquo;), because it is still brotli-compressed. It should have been uncompressed by the browser, but it was unable to do so since the web server provided the compressed content without specifying the HTTP Response Header \u0026ldquo;Content-Encoding: br\u0026rdquo; that would have informed the browser that decompression is needed. Please verify your web server hosting configuration to add the missing \u0026ldquo;Content-Encoding: br\u0026rdquo; HTTP Response Header.\n📝 需要配置 Content-Encoding 參考 terreng/sws-unity-plugin\nError : Unable to load file Build/xxx.framework.js.br\u0026hellip; Unable to load file Build/xxx.framework.js.br! Check that the file exists on the remote server. (also check browser Console and Devtools Network tab to debug)\n📝 這是因為 Brotli 壓縮算法僅在 HTTPS 連接中被啟用\nOptional Optional : autoSyncPersistentDataPath 修復了 Application.persistentDataPath 持久化的問題\n📝 通過於 index.html 添加新的 JS 配置選項 autoSyncPersistentDataPath： true 來啟用 Application.persistentDataPath 到 IndexedDB 的自動同步。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---platform---web---issue/","tags":["Unity","Web"],"title":"Unity - Platform - Web - Issue"},{"contents":"Quick Chat 物件生命週期管理（Object Lifecycle Management）是程式設計中的一個重要概念，它指的是有效控制和管理一個物件從建立、使用到銷毀的整個過程。良好的生命週期管理不僅能提升應用程式的效能，還能提高程式碼的可維護性，並有效地利用系統資源。\nStage 建立（Creation）\n物件被初始化並在記憶體中生成。在這個階段，程式碼通常會執行建構函式，完成必要的設定，或注入所需的依賴項。\n使用（Usage）\n物件處於活躍狀態，執行其核心功能。這段期間，應用程式會不斷地呼叫物件的方法，讀取或修改其屬性，處理各項業務邏輯。\n銷毀（Destruction）\n當物件不再被需要時，系統會回收其所佔用的資源。這個過程通常涉及垃圾回收機制（Garbage Collection），並釋放如檔案連線、資料庫連線等外部資源，避免資源洩漏。\nLifetime 瞬時（Transient）\n這種模式下的物件是一次性的。每次需要時，系統都會建立一個全新的實例。它特別適合那些不帶有狀態（Stateless）或只在短期內使用的物件，確保每次呼叫都是一個獨立乾淨的實體。\n單例（Singleton）\n顧名思義，在整個應用程式的執行期間，只會建立一個單一的實例。所有對該物件的請求都會共用同一個實體。這種模式常用於管理全域性資源，例如設定檔、日誌記錄器或資料庫連線池等。\n範圍（Scoped）\n這是一種介於瞬時和單例之間的模式。物件的生命週期被限制在一個特定的作用範圍內，例如一次 HTTP 請求或一個獨立的執行單元。在該範圍內，該物件都是唯一的；但當範圍結束時，該物件就會被銷毀。這種模式非常適合在單次請求中共享狀態，同時又確保不同請求之間不會互相干擾。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---concept---object-lifecycle-management/","tags":["Software_Design","Concept"],"title":"Software Design - Concept - Object Lifecycle Management"},{"contents":"Quick Chat 從 DOTween 轉換到 LitMotion 的過程很順利，特別是看中它「零記憶體配置」（Zero Allocation）的特性。加上它對 UniTask 和 R3 的良好支援。\nGuide GitHub - annulusgames/LitMotion LitMotion Overview | LitMotion DOTweenのイージング一覧を世界一詳しく\u0026amp;分かりやすく説明する | ゲームUIネット Practice 【Unity】2次ベジェ曲線を使ってLitMotionでジャンプ機能を実装する - 原カバンは鞄のお店ではありません。 【Unity】Splineを利用してLitMotionでパス移動を実現する - 原カバンは鞄のお店ではありません。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package---litmotion/","tags":["Unity"],"title":"Unity - Package - LitMotion"},{"contents":"箱庭工作室 (Miniature Garden Studio) 這是我的工作室名，其核心思想是\n每個創作都是一個精心構築的 箱庭/微型世界，在有限的環境中創造豐富且深度的體驗，讓使用者能夠沉浸其中。\n現實中的箱庭 箱庭（はこにわ，Hakoniwa），它是一種縮小版的庭園或景觀模型。這個概念源於日本，最早用來指代傳統日式庭園的迷你模型，但後來這個詞的應用範圍擴展到了各種縮小版的自然景觀創作。\n遊戲中的箱庭 箱庭設計在遊戲中已成為一種經典理念。\nIGN小课堂#49：箱庭 从沙盒和开放世界谈起，说说日本的箱庭设计理念 ","permalink":"https://HoshikawaRyuukou.github.io/posts/chat---profile---studio/","tags":["Chat","Profile"],"title":"Chat - Profile - Studio"},{"contents":"Quick Chat 別名方法是一種眾所周知的演算法，用於從任意離散機率分佈中進行恆定時間採樣，該演算法依賴於簡單的預先計算的查找表。\nGuide Alias Method: 非均匀随机抽样算法 Darts, Dice, and Coins: Sampling from a Discrete Distribution Weighted Random: algorithms for sampling from discrete probability distributions mackysoft/Choice jgrapht-core/src/main/java/org/jgrapht/alg/util/AliasMethodSampler.java 務必先觀看\n第一篇文章的漸進思考與核心精神 第二篇文章最後的 Vose\u0026rsquo;s Alias Method 圖解 Example 給定的權重 [0.1, 0.2, 0.3, 0.4]。\n按均值縮放權重： 均值為 : 0.25 縮放後的權重：[0.4, 0.8, 1.2, 1.6] 分類權重到 large 和 small 隊列： 初始狀態：small = [], large = [] 權重 0.4 小於 1，放入 small：small = [0] 權重 0.8 小於 1，放入 small：small = [0, 1] 權重 1.2 大於 1，放入 large：large = [2] 權重 1.6 大於 1，放入 large：large = [2, 3] 構建別名表： 初始狀態：\nprobs = [0.4, 0.8, 1.2, 1.6] aliases = [null, null, null, null] small = [0, 1] large = [2, 3] 處理 small[0] = 0, large[0] = 2：\naliases[0] = 2 probs[2] = 1.2 + 0.4 - 1 = 0.6 small.shift() -\u0026gt; small = [1] 再次分類 probs[2] \u0026lt; 1 放入 small 更新狀態：\nprobs = [0.4, 0.8, 0.6, 1.6] aliases = [2, null, null, null] small = [1, 2] large = [3] 處理 small[0] = 1, large[0] = 3：\naliases[1] = 3 probs[3] = 1.6 + 0.8 - 1 = 1.4 small.shift() -\u0026gt; small = [2] 再次分類，probs[3] \u0026gt; 1 放回 large 更新狀態：\nprobs = [0.4, 0.8, 0.6, 1.4] aliases = [2, 3, null, null] small = [2] large = [3] 處理 small[0] = 2, large[0] = 3：\naliases[2] = 3 probs[3] = 1.4 + 0.6 - 1 = 1.0 small.shift() -\u0026gt; small = [] large.shift() -\u0026gt; large = [] 現在所有 small, large 隊列均已空，構建完成。\n結果： 最終權重：probs = [0.4, 0.8, 0.6, 1.0] 最終別名：aliases = [2, 3, 3, null] 操作： 第一個隨機值 i 用於選擇權重索引。 第二個隨機值 r 用於決定是否使用別名。 case ( i = 3 ) : aliases[3] 為 null，採樣結果為 3 case ( i = 1, r = 0.6 ) : aliases[1] 非 null，且 r \u0026lt; probs[1]，採樣結果為 1 case ( i = 1, r = 0.9 ) : aliases[1] 非 null，且 r \u0026gt; probs[1]，採樣結果為 3 (aliases[1]) Summary probs alias small large [0.4, 0.8, 1.2, 1.6] [null, null, null, null] [0, 1] [2, 3] [0.4, 0.8, 0.6, 1.6] [2, null, null, null] [2] [1, 3] [0.4, 0.8, 0.6, 1.4] [2, 3, null, null] [2] [3] [0.4, 0.8, 0.6, 1.0] [2, 3, 3, null] - - ","permalink":"https://HoshikawaRyuukou.github.io/posts/algorithm---sampling---alias-method/","tags":["Algorithm"],"title":"Algorithm - Sampling - Alias Method"},{"contents":"Quick Chat 符號連結本身只是一個檔案，但它的內容指向另一個檔案或資料夾的路徑。當你存取這個符號連結時，作業系統會自動將你導向到它所指向的目標。\n⚠️ 符號連結它只是一個指標，不包含實際的檔案內容。如果你刪除原始檔案，符號連結就會失效。\nWindows ⚠️ Windows 建立符號連結需要 管理員權限\n使用 cmd（需管理員權限）：mklink 使用 PowerShell（需管理員權限）：Create a symbolic link to a file or folder ","permalink":"https://HoshikawaRyuukou.github.io/posts/os---file-system---symbolic-link/","tags":["OS","Windows"],"title":"OS - File System - Symbolic Link"},{"contents":"Quick Chat 最近我從 Unity 轉向了 Node.js，因此花了不少時間在 npm 上尋找合適的套件。大部分的 README 寫得很清晰，但也有少數讓人摸不著頭緒。這讓我意識到，README 就是專案的門面。\nGuide 你知道對專案來說，README.md 有多麼重要嗎？ ── 工程師血淚史 README 的藝術 Template README-Template.md GitHub README Templates ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-development---document---readme/","tags":["Software_Development"],"title":"Software Development - Document - README"},{"contents":"Quick Chat 後端：深入且穩定 前端：廣泛且彈性 Roadmap Developer Roadmaps - roadmap.sh Algorithm fucking-algorithm hello-algo The Algorithms ","permalink":"https://HoshikawaRyuukou.github.io/posts/chat---career---software-engineer/","tags":["Chat","Career","Software_Engineer"],"title":"Chat - Career - Software Engineer"},{"contents":"Quick Chat Rider 能更好處理 Unity 開發環境的大小事，但你知道的費用\u0026hellip; 👀 處理 Renaming 事務一律切到 Visual Studio，因為 VS Code 的支援很不到位。 Field Unity - Scripting API: FormerlySerializedAsAttribute MonoBehaviour Class 現在 Unity 裡對 Class 重新命名（這時 .cs 檔會與 class name 不一致） 到 Visual Studio 裡重新命名 ⚠️ 順序錯誤可能會導致引用噴掉 ⚠️ 步驟 2 先執行會導致 Unity 的 class 檔名會一起變動（有概率會出錯）\nNamespace 有兩個情境\n真的想重新命名 namespace （對著 namespace 直接右鍵重新命名即可） 想把某 Type 歸屬到指定 namespace 情境 2 要使用 Visual Studio 的重構工具\n對著 Type 右鍵 - 快速動作與重構 選擇 移到命名空間（這樣所有的參考都會連動修改） ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---coding---renaming/","tags":["Unity","Visual_Studio"],"title":"Unity - Coding - Renaming"},{"contents":"Quick Chat 在構建過程中，Unity 通過稱為託管代碼剝離的過程刪除未使用或無法訪問的代碼，這可以顯著減小應用程式的最終大小。\nFile -\u0026gt; Build Settings -\u0026gt; Player Settings -\u0026gt; Optimization -\u0026gt; Managed Stripping Level\n⚠️ Managed Stripping Level 等級越高裁剪掉的代碼越多，包體也就越小，但是對應的風險也就更大。 藉由屬性或特殊 XML 配置檔的形式提供註釋，以指示 Unity 連結器要保留代碼庫的哪些部分。 Guide Unity - Manual: Managed code stripping KuraiAndras/LinkerGenerator IUnityLinkerProcessorでCodeStrippingからコードを守る Preserving Preserve attribute ⚠️ [Preserve] 屬性屬於“侵入式”的解決方案，不建議 class Foo { [Preserve] public void PreservedMethod(){} } link.xml 在專案的 Assets 目錄下創建個 link.xml \u0026lt;linker\u0026gt; \u0026lt;assembly fullname=\u0026#34;DOTween\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;Newtonsoft.Json\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;Assembly-CSharp\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;UnityEngine\u0026#34;\u0026gt; \u0026lt;type fullname=\u0026#34;UnityEngine.SpriteRenderer\u0026#34; preserve=\u0026#34;all\u0026#34;/\u0026gt; \u0026lt;type fullname=\u0026#34;UnityEngine.Rigidbody2D\u0026#34; preserve=\u0026#34;all\u0026#34;/\u0026gt; \u0026lt;/assembly\u0026gt; \u0026lt;/linker\u0026gt; ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---coding---managed-code-stripping/","tags":["Unity"],"title":"Unity - Coding - Managed code stripping"},{"contents":"Extracting AssetRipper/AssetRipper Games 28598519a/TSK_AssetDL ZM-Kimu/Blue-Archive-Asset-Downloader Deathemonic/BA-AD ","permalink":"https://HoshikawaRyuukou.github.io/posts/assets---game/","tags":["Assets"],"title":"Assets - Game"},{"contents":"Quick Chat 客製化 Unity 官方 / git 直接導入 的 Package\nGuide How can I modify built-in packages? Unity - 如何修改一个 Package 或是如何将 Package Local化 Steps 至 ProjrctRoot\\Library\\PackageCache 找到目標的 Package 剪下貼上至 ProjrctRoot\\Packages 即可 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package-manager---modify-a-package/","tags":["Unity","Package_Manager"],"title":"Unity - Package Manager - Modify a Package"},{"contents":"Quick Chat Google 停止維護 Game Package Registry (GPR) 導致不能直接使用 Package Manager 導入包。必須到封存檔網站下載「.tgz」手動導入。\nGoogle Unity 套件 Install a package from a local tarball file 其他的相關的 Google Service 依賴(AR/Firebase/Google Play等)也可以用此方法導入。\nConfiguration Assets \u0026gt; External Dependency Manager \u0026gt; Android Resolver \u0026gt; Settings 啟用這三個 Patch\n並至 Player Settings \u0026gt; Publishing Settings 啟用以下選項\nAuto Resolution Assets \u0026gt; External Dependency Manager \u0026gt; Android Resolver \u0026gt; Force Resolve 後會去收集專案所有 Editor 資料夾下的 *Dependencies.xml 加到 mainTemplate 中\n","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package---external-dependency-manager-for-unity-edm4u/","tags":["Unity","Google_Service"],"title":"Unity - Package - External Dependency Manager for Unity (EDM4U)"},{"contents":"Quick Chat 過去常以為 rebase 是像「剪下貼上」的操作，但實際上更像是「複製貼上」，它會將一系列的 Commit 複製一份，並重新套用在新的基底上，因此會產生新的 SHA-1 值。\n主要情境與特性 歷史紀錄更簡潔：rebase 不會像 merge 那樣產生額外的合併節點（Merge Commit），讓 Commit 歷史紀錄更為線性、乾淨。\n適用於未推送的 Commit：當你想要整理、合併或修改本地端「還沒推送到遠端」的 Commit 時，rebase 是非常實用的工具。\n避免修改已推送的歷史：由於 rebase 會改寫 Commit 歷史，因此 絕對不要 對已經推送到遠端（與他人協作中）的分支進行 rebase 操作，以免造成他人的困擾。\nGuide 另一種合併方式（使用 rebase） git rebase 用法 Extras 如何取消 Rebase 操作 如果你在進行 rebase 時後悔了，可以透過以下兩種方式安全地回溯到操作之前的狀態：\n使用 git reflog 尋找歷史紀錄\n輸入 git reflog，這會列出你所有的 Git 操作紀錄。 找到 rebase 執行前的 Commit ID。 輸入 git reset XXXXXXX --hard 來回溯（其中 XXXXXXX 為該 Commit ID）。 使用 ORIG_HEAD 快速回溯 由於 Git 在執行 reset 等具風險的操作時，會額外將上一個 HEAD 的位置記錄在 ORIG_HEAD 中。因此，你也可以直接執行以下指令來快速達到相同的效果：\ngit reset ORIG_HEAD --hard ","permalink":"https://HoshikawaRyuukou.github.io/posts/git---rebase/","tags":["Git"],"title":"Git - Rebase"},{"contents":"Quick Chat 有些環境也稱為合併請求（Merge Request）。\n產品開發中，通常會指定一個分支作為可發布的正式版本分支（例如 master 或 main）。在多人協作時，讓每位開發者都能直接提交（Commit）至這個正式分支並非最佳實踐。\n為了有效管理，可以採用 Pull Request (PR) 的方式來控制權限。當其他開發者完成工作後，他們會發起一個 PR。專案管理者在審核並確認無誤後，即可將其合併，這能確保產品分支始終處於隨時可發布的狀態。\n若您參與開源專案，在建立 PR 前，建議先在本地分支上執行 git rebase 指令，將您的變更建立在最新的程式碼進度之上，這有助於降低審核者的理解與合併難度。\nGuide 與其它開發者的互動 - 使用 Pull Request（PR） ","permalink":"https://HoshikawaRyuukou.github.io/posts/github---pull-request/","tags":["GitHub"],"title":"GitHub - Pull Request"},{"contents":"Quick Chat 當你一開始沒 ignore 到某些檔案，後來補上 .gitignore，卻發現 Git 還是繼續追蹤那些檔案。\nSolution # 先清掉 Git 的快取（不會刪檔，只是取消追蹤） git rm -r --cached . # 再重新加入所有檔案（讓 .gitignore 這次能正確發揮作用） git add . # 然後提交變更 git commit -m \u0026#34;Reapply .gitignore rules\u0026#34; ","permalink":"https://HoshikawaRyuukou.github.io/posts/git---reapply-.gitignore/","tags":["Git"],"title":"Git - Reapply .gitignore"},{"contents":"Quick Chat 在口語交流中，我們常用 Define 來稱呼，但正式名稱其實是 前置處理器指示詞（Preprocessor Directives）。\n我最近接手一個舊專案時，發現裡面大量使用了 條件式編譯。例如：\n#if DEBUG Console.WriteLine(\u0026#34;Debug version\u0026#34;); #endif 在 Unity 中，這類寫法也經常出現在處理不同平台或環境時：\npublic class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(\u0026#34;Unity Editor\u0026#34;); #endif #if UNITY_IOS Debug.Log(\u0026#34;iOS\u0026#34;); #endif #if UNITY_STANDALONE_OSX Debug.Log(\u0026#34;Standalone OSX\u0026#34;); #endif #if UNITY_STANDALONE_WIN Debug.Log(\u0026#34;Standalone Windows\u0026#34;); #endif } } 前置處理器指示詞並非沒有代價，過度使用會帶來以下困擾：\n編譯版本數量容易爆炸（至少是 2^(指示詞分類數) 種），使得除錯與測試難度上升。 在 Unit Test 中幾乎無法有效使用。 無法透過一般的編譯檢查來捕捉錯誤。 巢狀結構一旦出現，可讀性大幅降低。 最直接的影響就是：問題會被延後發現！\nQuide C# 前置處理器指示詞 macroのカジュアル多用は危険 Conditional Compilation Practice 原則上能避免就避免使用，通常可以透過 條件分支、策略模式 或 依賴注入 來更清楚地表達邏輯，並提升程式的可維護性。\n✅ 允許 — 少量使用 UNITY_EDITOR 在 MonoBehaviour 某些情境下需要針對編輯器做額外處理(客製編輯器)，這算是合理的使用方式：\n#if UNITY_EDITOR ... #endif ✅ 建議 — 降低指示詞的影響範圍 若條件允許，可以透過 介面定義 將影響控制在實例化階段，避免在業務邏輯中直接出現。\n#if UNITY_EDITOR var runner = new EditorRunner(); #elif UNITY_IOS var runner = new IOSRunner(); #elif UNITY_ANDROID var runner = new AndroidRunner(); #endif ✅ 建議 — 善用 ConditionalAttribute 官方文件也建議使用 ConditionalAttribute，可在不污染邏輯的情況下控制程式是否執行。\n[Conditional(\u0026#34;DEBUG\u0026#34;)] private void DebugLog(string message) { Debug.Log(message); } ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---preprocessor-directives/","tags":["Unity","CSharp"],"title":"Unity - Basic - Preprocessor Directives"},{"contents":"Quick Chat Service Locator 是一種 依賴尋找（Dependency Lookup） 的實作方式，它確實屬於控制反轉（IoC）的一種。\n過去我曾頻繁使用這個模式，當時對於 DI（依賴注入）與 IoC 的概念還不熟悉，只覺得它讓依賴的取用變得非常方便，因為你可以在任何地方直接這樣取得所需物件：\nvar target = ServiceLocator.Resovle\u0026lt;Target\u0026gt;(); 然而，這種作法存在幾個顯著問題：\n隱性依賴：由於依賴的取得過程被隱藏起來，程式碼的真實依賴關係難以被一眼識別，增加了閱讀與維護的難度。 打破分層原則：任何元件都可以隨意取得服務，這可能會導致 View 層級的物件存取到不屬於其範疇的業務邏輯，破壞了應用程式的架構分層。 因此，當我對 DI 與 IoC 的概念更加熟悉，並開始使用 DI/IoC Container 後，就逐漸棄用了 Service Locator 這個模式。\nSituation 這次的專案讓我重新思考了 Service Locator 的價值。我發現它非常適合做為從 Singleton 過渡到 DI/IoC Container 的中間階段。\n我們目前專案嚴重依賴 Singleton 模式，團隊成員也已經習慣了這種寫法。若要直接切換到 DI/IoC Container，勢必會引發不小的陣痛期。\n在這種情況下，Service Locator 成了理想的過渡方案，理由如下：\n寫法近似 Singleton：它的使用方式與靜態的 Singleton 模式極為相似，能讓團隊成員無痛轉換，降低學習成本。 快速感受 IoC 好處：儘管只是過渡，但它能讓團隊成員立即感受到集中管理依賴所帶來的便利性，為後續全面採用 DI/IoC Container 鋪路。 集中管理依賴：它提供一個中央註冊點，讓所有依賴關係被統一看管。 Practice 這種模式使用一個中央註冊表（Service Locator）來根據請求返回執行特定任務所需的物件。\n以下是一個簡化版的實作範例，它有別於一般的 IoC Container，具有以下特色：\n不強制介面實作：註冊的物件可以不必實作特定介面。 單純的容器：主要功能就是作為物件的儲存庫。 不使用反射：為避免效能開銷，它搭配一個 Installer（組合根） 來進行物件的註冊。 // 這裡透過 static 達成全域存取 public class ServiceLocator { private static readonly Dictionary\u0026lt;Type, object\u0026gt; instances = new Dictionary\u0026lt;Type, object\u0026gt;(); // 註冊服務 public static void Register\u0026lt;T\u0026gt;(T instance) { instances[typeof(T)] = instance; } // 尋找服務 public static T Resolve\u0026lt;T\u0026gt;() { if (instances.TryGetValue(typeof(T), out var instance)) { return (T)instance; } throw new Exception($\u0026#34;Service of type {typeof(T)} is not registered.\u0026#34;); } // 釋放服務 (可選) public static void Release\u0026lt;T\u0026gt;() { if (instances.ContainsKey(typeof(T))) { instances.Remove(typeof(T)); } } } // 由 Installer 集中註冊物件 public class DemoBasicServiceLocatorsInstaller : MonoBehaviour { public DemoBasicMoneyUI moneyUI; public MoneyType moneyType; public int moneyValue = 100; void Start() { switch (moneyType) { case MoneyType.Real: ServiceLocator.Register\u0026lt;IMoneyFormatConverter\u0026gt;(new RealMoneyFormatConverter()); break; case MoneyType.Coin: ServiceLocator.Register\u0026lt;IMoneyFormatConverter\u0026gt;(new CoinMoneyFormatConverter()); break; default: throw new System.NotImplementedException(); } moneyUI.Show(moneyValue); } } // 在需要的地方從容器取得服務 public class DemoBasicMoneyUI : MonoBehaviour { [SerializeField] private TMP_Text text; private IMoneyFormatConverter moneyFormatConverter; public void Show(int moneyValue) { // 透過 ??= 確保只在第一次使用時尋找服務 moneyFormatConverter ??= ServiceLocator.Resolve\u0026lt;IMoneyFormatConverter\u0026gt;(); text.text = moneyFormatConverter.Convert(moneyValue); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---service-locator/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Service Locator"},{"contents":"Quick Chat Assembly Definition (asmdef) 檔案是 Unity 用來組織和管理專案程式碼的工具。它能將你的腳本分組，形成多個獨立的「程式集 (Assembly)」。\n在沒有使用 asmdef 的情況下，Unity 會將所有腳本編譯成一個單一、龐大的 Assembly-CSharp.dll 程式集。這會導致兩個主要問題：\n編譯時間長：每次修改任何一個腳本，都必須重新編譯整個巨大的程式集，拖慢開發進度。 程式碼依賴混亂：所有腳本彼此間都可以任意存取，使得依賴關係變得複雜且難以管理。 asmdef 的核心價值就是為了解決這些問題。\nGuide Doc - Assembly definitions Unity中 .asmdef文件的作用 透過 asmdef，你可以將專案切分成邏輯上獨立的程式碼區塊，每個區塊都有自己的 asmdef 檔案，這帶來三大優勢：\n大幅縮短編譯時間 這是 asmdef 最重要的優點。當你只修改了某個程式集的腳本時，Unity 只會重新編譯那個程式集，以及任何依賴它的程式集。沒有被影響的部分則不會被重新編譯，能顯著加快開發迭代的速度。\n改善程式碼結構 asmdef 強制你明確定義程式集之間的依賴關係。一個程式集只能存取它所引用的程式碼，這能避免不必要的依賴，讓專案結構更清晰、更易於維護和重用。\n增強程式碼封裝性 你可以更好地控制程式碼的存取權限，防止內部函式被外部不相關的程式集隨意使用。\nPackage 與 Asmdef 的關係 Unity 的 Package Manager 系統正是建立在 asmdef 的基礎上。每個 Unity 套件都必須使用 asmdef 來定義其程式集結構，確保套件內的程式碼與專案其他部分相互獨立，只透過明確的引用進行互動。\n這也是為什麼你在使用或開發 Unity 套件時，會看到每個功能模組都有其對應的 asmdef 檔案。\n常見的結構：Runtime 與 Editor 在許多 Unity 專案和套件中，最常見的 asmdef 結構是將程式碼區分為 Runtime 和 Editor 兩部分：\nRuntime 程式集\n用途：包含遊戲執行時所需的程式碼，會被編譯進最終的遊戲建置中。 限制：不能引用任何 UnityEditor 相關的程式碼或 API。 Editor 程式集\n用途：包含只在 Unity 編輯器環境中運行的工具程式碼，例如自訂檢視器（Custom Inspector）。 限制：不會被編譯到最終的遊戲建置中。通常會引用對應的 Runtime 程式集，但 Runtime 程式集絕對不能反過來引用 Editor 程式集。 這種結構能確保最終的遊戲建置只包含必要的程式碼，避免錯誤並有效縮小檔案大小。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---assembly-definition-asmdef/","tags":["Unity"],"title":"Unity - Basic - Assembly Definition (Asmdef)"},{"contents":"Quick Chat 為 Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。\n⚠️無法處理已由 Unity 本身處理的文件擴展名。\nGuide Scripted Importers [Unity] 资源工作流程 - ScriptedImporter Example 這裡將 .lua 以 TextAsset\nusing UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, \u0026#34;lua\u0026#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( \u0026#34;text\u0026#34;, subAsset ); ctx.SetMainObject( subAsset ); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---editor---scripted-importer/","tags":["Unity"],"title":"Unity - Editor - Scripted Importer"},{"contents":"Quick Chat 「在尚未深入依賴注入框架前，我常使用它來管理跨場景的資源。」 「當然，在小專案中，它仍是一個相當方便實用的工具。」 Guide Unity - Scripting API: Object.DontDestroyOnLoad DontDestroyOnLoad 標籤能確保物件在場景切換時不會被銷毀，主要應用於以下三種情境：\n全域管理器：此類物件需要貫穿遊戲始終，例如音效管理器、遊戲設定或玩家數據。標記為 DontDestroyOnLoad 後，這些管理器便能持續發揮功能並保留數據，確保遊戲體驗不間斷。 持久性資料：當有多個場景需要共享同一份資料時，例如玩家的遊戲進度或全域配置設定，可以將儲存這些資料的物件設為 DontDestroyOnLoad，確保不同場景都能存取並更新。 常駐物件：某些物件（如遊戲狀態面板、計時器或得分顯示）需要持續顯示。透過 DontDestroyOnLoad，這些物件在場景切換時不會消失，能保持持續更新。 Notice 雖然 DontDestroyOnLoad 很實用，但使用不當會引發以下問題：\n記憶體洩漏：如果一個 DontDestroyOnLoad 物件在後續場景中不再需要，但沒有手動銷毀，它會一直存在於記憶體中。這會造成記憶體佔用增加，導致遊戲效能下降，甚至出現記憶體洩漏。 場景耦合：DontDestroyOnLoad 會打破 Unity 場景應有的獨立性。當場景之間存在大量共享物件時，會增加它們之間的依賴性（高耦合），使得程式碼難以管理、維護和測試。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---dontdestroyonload/","tags":["Unity"],"title":"Unity - Basic - DontDestroyOnLoad"},{"contents":"Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Screen How to capture the screen in Unity (3 methods) ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---misc/","tags":["Unity"],"title":"Unity - Basic - Misc"},{"contents":"Quick Chat 符合 Fail Fast 原則，驗證條件並在不滿足條件時立即停止執行。 增加可讀性(更扁平)，減少了巢狀判斷。 Guide Guard Clause | DevIQ Implementation Patterns: Guard Clause Stop using trivial Guard Clauses! Try this instead Example Guard Clause | DevIQ Extras Guard Class GitHub - ardalis/GuardClauses 將通用的保護子句封裝在一個專門的類是一種很好的做法，可重用邏輯並編寫更具可讀性的保護子句。\nValue Object Stop using trivial Guard Clauses! Try this instead 文章作者避免瑣碎 Guard 的方式，是使用 Value Object，來避免域接受到無效參數。(YT評論區也建議閱讀，有許多不錯的討論)\n但不可否認的 Guard Clause 作法在大多情況下是有益的。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---guard-clauses/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Guard Clauses"},{"contents":"Quick Chat DTO，即數據傳輸物件，是在系統各層（如 API 層與業務邏輯層）或不同服務之間傳遞資料的專用物件。它像一個純粹的「數據包裹」，只負責承載數據，不包含任何業務邏輯。\nGuide Cutting Edge - Pros and Cons of Data Transfer Objects The DTO (Data Transfer Object) Data Transfer Objects Clean Architecture : why not using the entity as request model of the use case (interactor) Difference between Entity and DTO Advantages 建立清晰邊界，降低耦合：DTO 作為公開的數據契約，讓內部資料庫結構 (Entity) 可以自由修改，而不直接影響外部的客戶端或服務。\n精準控制數據，提升安全性與：只暴露客戶端真正需要的欄位，避免洩漏如密碼雜湊、內部 ID 等敏感或不相關的實作細節。\n優化傳輸效率：可以匯集多個來源的資料於一身，或只傳送部分欄位，以此減少網路請求次數與數據傳輸量。\n簡化序列化：因為 DTO 是單純的數據容器，不含複雜的業務邏輯或循環引用，所以能輕易地被序列化為 JSON 或 XML 等格式，在網路上順利傳輸。\nTrade-off 需要額外定義 DTO 類別與轉換邏輯，增加了程式碼量。在極簡單的應用中可能顯得過度設計。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---data-transfer-object-dto/","tags":["Software_Design","Pattern"],"title":"Software Design - Pattern - Data Transfer Object (DTO)"},{"contents":"Audio 魔王魂 効果音ラボ フリーBGM（音楽素材）無料ダウンロード｜DOVA-SYNDROME フリー効果音素材・無料効果音 Color Coolors Palettable Feature Graphics Google Play Feature Graphics Font 中文免費字體 Google Fonts 2022/0113更新# 36個合法免費高品質字體 fontget LINE Seed Icon ICOOON MONO iconmonstr Flaticon IconKitchen Game-icons.net Image かわいいフリー素材集 いらすとや Unsplash Image API | Free HD Photo API Lorem Picsum Photosku 2023 熱門 47 個可商用無版權免費圖庫懶人包（圖片、圖示、圖標、素材、背景） OKUMONO Textures Poly Haven Misc itch.io Kenney Opengameart ","permalink":"https://HoshikawaRyuukou.github.io/posts/assets/","tags":["Assets"],"title":"Assets"},{"contents":"Github: HoshikawaRyuukou\n","permalink":"https://HoshikawaRyuukou.github.io/about/","tags":null,"title":"About me"},{"contents":"This is the search page, type keywords to search among my articles.\n","permalink":"https://HoshikawaRyuukou.github.io/search/","tags":null,"title":"Search"}]