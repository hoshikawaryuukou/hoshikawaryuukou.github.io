[{"contents":"ブルーアーカイブ (Blue Archive) 威威字幕君的个人空间-威威字幕君个人主页-哔哩哔哩视频 鳴潮 (Wuthering Waves) 文明的漂泊者，解剖鳴潮最深的秘密，《鳴潮》究竟講了一個什麽故事？ 鳴學02|信仰寄生，聖女已死，黎那汐塔隱藏的真正秘密，《鳴潮》劇情深度解讀 モンスターハンター (Monster Hunter) 艾森巴赫 - YouTube ","permalink":"https://HoshikawaRyuukou.github.io/posts/acg---game---story/","tags":["ACG"],"title":"ACG - Game - Story"},{"contents":"Quick Chat Photopea 是一款免費線上圖像編輯工具，介面與 Photoshop 相似，支援 PSD、XD、Sketch 等多種檔案格式。使用者無需安裝軟體，即可在瀏覽器中進行圖層編輯、濾鏡處理與設計排版，非常適合快速修圖與設計需求。\nCases 【Photopea】色を置き換える方法 ","permalink":"https://HoshikawaRyuukou.github.io/posts/art---photopea---note/","tags":["Art"],"title":"Art - Photopea - Note"},{"contents":"Artificial General Intelligence（AGI） 簡單來說，AGI（通用人工智慧）就像是一個能夠像人類一樣思考和學習的 AI。現在的 AI 通常只能做特定的事情，比如語音助理能聽懂指令、圖像辨識能認臉，但它們無法舉一反三或解決各種不同的問題。\nAGI 則不同，它能夠適應各種情境、學習新知識、自己思考並解決問題，就像一個真正有智慧的人。這也是人工智慧發展的終極目標——打造一個可以自由學習、理解世界的「超級 AI」。\nEdge Computing 簡單來說，邊緣運算就是讓資料的處理工作盡量靠近資料來源，而不是全部送到遠端的伺服器（雲端）去計算。\n舉個例子，如果你在用自駕車，車子上的感測器會即時收集路況資訊。如果這些資料都要先傳到雲端再回來，可能會有延遲，影響安全。但如果車子本身就能即時處理這些資料，那麼它可以更快做出決策，避免危險。\n這種技術不只適合自駕車，也廣泛應用在智慧工廠、AR/VR、智慧家庭等需要即時反應的領域，因為它可以減少延遲、降低網路負擔，並提升運算效率。\nRetrieval-Augmented Generation（RAG） 簡單來說，RAG 就是讓 AI 會「先查資料再回答」，而不是單靠自己記住的知識來作答。\n一般的 AI 模型只能根據訓練時學到的內容回答問題，這可能會導致資訊過時或不夠準確。但 RAG 的特點是，它會先去找最新或相關的資料，然後再根據這些資訊來產生回應。\n想像一下，你問 AI：「最近的 AI 技術發展如何？」一般的 AI 可能只會回答它訓練時學到的內容，但 RAG 會先查找最新的研究或新聞，再提供更準確的答案。這讓它特別適合問答系統、企業內部知識搜尋、技術支援等需要即時、可靠資訊的應用。\nMultimodal 簡單來說，多模態 AI 就是讓人工智慧能夠同時理解和處理多種形式的資料，例如文字、圖片、聲音和影片等。​\n傳統的 AI 模型通常只專注於單一類型的資料，例如僅處理文字或圖像。​但多模態 AI 能夠整合不同形式的資訊，使其對世界的理解更加全面，並能執行更複雜的任務。\nNatively Multimodal（原生多模態） 所謂「原生」是指模型從一開始就是為多模態設計，並非後期再整合進去，因此能更自然、有效率地跨模態理解與生成資訊。\nGemini 2.0 Flash 用嘴 P 圖的這一天真的來了！超強多模態 Gemini AI 讓一票設計師默默把繪圖板拿起來邊啃邊思考人生 ~ GPT 4o 原生多模態圖片生成 OpenAI重大更新，降维打击，自然语言绘图功能修改图片功能跨代提升，真正的多模态，从此人人都是设计师 為圖像生成帶來更穩定/可控的輸出 角色一致性 文字渲染能力 支援多輪對話調整迭代創作(明確指示修改) 基於參考圖二次創作(風格遷移) Model Context Protocol（MCP） 模型上下文協議（Model Context Protocol，MCP）由 Anthropic 提出，是一種開放標準，用來規範 AI 模型與外部工具、資料來源的互動方式。\n傳統上，開發者每次整合新工具或數據源都要寫專屬程式碼，導致開發與維護成本高。MCP 則像是 AI 的「萬用轉接頭」，透過統一規範，讓 AI 無縫存取 API、資料庫與應用程式，大幅提升開發效率與靈活性。\n🔗 延伸參考與應用案例 Cursor + MCP + Blender = 人人都能 3D 建模？ AI 直接操作電腦建模！MCP 這個詞今年一定要知道！【Blender-MCP 安裝教學】 GitHub: justinpbarnett/unity-mcp ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---llm---note/","tags":["AI","LLM"],"title":"AI - LLM - Note"},{"contents":"UNT0023 Coalescing assignment on Unity objects 合併賦值運算子 ??= 是 C# 8.0 引入的運算子，其功能是：如果左側運算元為 null，則將右側運算元的值賦給左側運算元。\n然而，在 Unity 中直接對 Unity 物件 (如 GameObject、Component 等) 使用這個運算子可能會導致問題，因為：\nUnity 物件的特殊生命週期：Unity 物件即使被銷毀，在 C# 層面的變數可能不會自動設為 null，而是成為\u0026quot;偽 null\u0026quot;物件。\n自訂的 null 檢查行為：Unity 覆寫了 == 運算子，使得對已銷毀的 Unity 物件進行 null 檢查時會返回 true，但 `?? 運算子使用的是底層的 null 檢查機制。\n使用明確的 null 檢查 private Rigidbody rb; void Start() { if (rb == null) { rb = GetComponent\u0026lt;Rigidbody\u0026gt;(); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---coding---warnings/","tags":["Unity"],"title":"Unity - Coding - Warnings"},{"contents":"Quick Chat 廣場協議（Plaza Accord）短期內成功讓美元貶值，減緩美國貿易逆差問題，但對日本造成嚴重衝擊，間接導致日本的泡沫經濟與經濟停滯。\n背景 美國為了抗通膨升息，外資湧入導致美元升值。 里根經濟學擴大財政赤字，外國購買美國國債進一步推高美元。 美國當時對日本和西德的貿易逆差特別嚴重。 目的 讓美元貶值，降低美國貿易逆差，提高美國出口競爭力。 讓日圓、德國馬克升值，減少日本與西德的出口優勢，平衡國際貿易。 操作 1985年9月，美國、日本、西德、法國、英國（G5）在紐約廣場飯店簽訂Plaza Accord。 G5 協同干預外匯市場，透過拋售美元、購買日圓與德國馬克來改變匯率。 後果 美國 出口競爭力回升。 日本 日圓升值 → 日本企業競爭力下降，出口受創。 日本央行採取低利率與寬鬆貨幣政策來刺激經濟，結果導致資產泡沫（房地產 \u0026amp; 股票暴漲）。 1990年代泡沫破裂，進入「失落的十年」。 西德（德國） 馬克升值，影響出口，但影響較日本小。 全球 G5後來在1987年簽訂 「羅浮宮協議」（Louvre Accord）來穩定匯率。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/economics---events---plaza-accord/","tags":["Economics"],"title":"Economics - Events - Plaza Accord"},{"contents":"Health 【花小烙】不小心食物中毒，身体里会发生什么？ Sleep 睡眠專家：休息的關鍵不在晚上，而是白天｜【初日會客室】哇賽心理學 蔡宇哲 Sport 善於長跑的原始部落:現代人忘了跑步的正確方式(跑鞋的誤區) | 暢銷書解讀《天生就會跑》 挺直背部、彎曲膝蓋、前腳掌先著地，以及抬腳時足跟接近臀部 落地的重心跟身體的重心在一條線上 ","permalink":"https://HoshikawaRyuukou.github.io/posts/life---note/","tags":["Life"],"title":"Life - Note"},{"contents":"Package Manager Installing Packages using UPM Package manager -\u0026gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -\u0026gt; Packages: My Registries -\u0026gt; Install Guide Unity中 .asmdef文件的作用 使用OpenUPM发布自己的Unity项目 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM 【Unity】Package Manager活用術 Package Collection killop/anything_about_game baba-s/awesome-unity-open-source-on-github Animation AnnulusGames/LitMotion Async Cysharp/UniTask Debug yasirkula/UnityIngameDebugConsole Dependency Injection hadashiA/VContainer Dialogue YarnSpinnerTool/YarnSpinner-Unity Editor AnnulusGames/Alchemy HotFix focus-creative-games/hybridclr IO Cysharp/ZString Newtonsoft.Json git - com.unity.nuget.newtonsoft-json Language phanphantz/ThaiTextCare-for-Unity Localization Lean Localization Media yasirkula/UnityNativeCamera Messaging Cysharp/MessagePipe Particle Effect mob-sakai/ParticleEffectForUGUI Persistence sabresaurus/PlayerPrefsEditor Resource Management tuyoogame/YooAsset Rx (Reactive Extensions) Cysharp/R3 Social Unity Native Share Plugin Sprite elringus/sprite-dicing State Machine Inspiaaa/UnityHFSM UI qiankanglai/LoopScrollRect Web psygames/UnityWebSocket gree/unity-webview ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---packages/","tags":["Unity"],"title":"Unity - Packages"},{"contents":"Sprite 【2Dゲームで必須】UnityのSprite（スプライト）の単位をわかりやすく解説 【間違えやすい】Unityの正しい画像サイズとは SpriteAtlas 【Unity】SpriteをパックするSpriteAtlasの使い方 減少DrawCall 圖集將圖片打包為2的冪次方的素材大小，可以提升性能 減小包體大小 使用 AssetBundle 來打包時，不要勾選 Include In Build ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---sprite-and-atlas/","tags":["Unity"],"title":"Unity - Basic - Sprite and Atlas"},{"contents":"Guide Organizing Your Unity Project — Content vs Feature Folders Organizing Project Folder Structure: Function-Based vs Feature-Based Content-Based（依內容分類） 特點 以「資源類型」來劃分資料夾，例如腳本、材質、模型等。 缺點 同一個功能可能分散在多個資料夾中。\n例如你想找「商店系統」的 prefab、script 和 UI，可能得在三、四個資料夾中翻找。 範例 Assets/ ├── Materials/ ├── Models/ ├── Textures/ ├── Scripts/ ├── Animations/ ├── Prefabs/ ├── Audio/ Feature-Based（依功能分類） 特點 以功能模組為單位集中管理相關資源。 適合模組化開發，有助於封裝、重用與搬移。 找特定功能時，所有相關資源都集中在一起，不需東找西找。 缺點 相同類型的資源（例如所有動畫或音效）會分散各處，不利統一管理。\n（不過透過 Editor 的搜尋功能，其實影響不大。） 若模組間耦合度高，可能導致功能邊界模糊。 範例 Assets/ ├── Shop/ │ ├── Scripts/ │ ├── Prefabs/ │ ├── UI/ ├── Player/ │ ├── Scripts/ │ ├── Animations/ │ ├── Prefabs/ ├── Inventory/ │ ├── Scripts/ │ ├── UI/ Hybrid（混合式） 特點 以 Feature-Based 為主體。 共用資源集中放置於 Common 或 Shared 資料夾中，避免重複。 範例 Assets/ ├── Common/ │ ├── Materials/ │ ├── Fonts/ │ ├── Audio/ ├── Player/ │ ├── Scripts/ │ ├── Prefabs/ ├── Shop/ │ ├── Scripts/ │ ├── UI/ 實踐建議 小型專案或原型（Prototype）建議先採用 Content-Based 結構，快速上手。 專案逐漸擴大後，可以逐步轉向 Feature-Based，以利管理與維護。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---project-structure/","tags":["Unity"],"title":"Unity - Project Structure"},{"contents":"Repository michael811125/OxGFrame gmhevinci/UniFramework ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---frameworks/","tags":["Unity"],"title":"Unity - Frameworks"},{"contents":"Shotcut 功能 快捷鍵 顯示/隱藏 檔案或資料夾 Shift + Command + . ","permalink":"https://HoshikawaRyuukou.github.io/posts/os---mac---note/","tags":["OS","Mac"],"title":"OS - Mac - Note"},{"contents":"Description 85. 最大矩形 Sample input matrix = [ [1,0,1,0,0], [1,0,1,1,1], [1,1,1,1,1], [1,0,0,1,0] ] output 6 Key points Solution 1 - 暴力解 檢查矩陣中所有可能的矩形，並計算每個矩形是否符合條件。 對每個可能的矩形進行迴圈遍歷。 計算該矩形內的元素是否符合條件。 複雜度 m 為 row 的長度 ，n 是 column 的長度 時間複雜度：O(m^2 x n^2) 空間複雜度：O(m x n) Solution 2 - 單調棧 將原矩陣根據各 row 提取出數個高度(連續的1)陣列。 便可將問題拆解成數個 84 題。 推導 Step Matrix Row heights[] result by No.84 1 [1,0,1,0,0] [1, 0, 1, 0, 0] 1 2 [1,0,1,1,1] [2, 0, 2, 1, 1] 2 3 [1,1,1,1,1] [3, 1, 3, 2, 2] 6 4 [1,0,0,1,0] [4, 0, 0, 3, 0] 4 最大矩形面積 = 6\n複雜度 m 為 row 的長度，n 是 column 的長度 時間複雜度：O(m x n) 空間複雜度：O(m) ","permalink":"https://HoshikawaRyuukou.github.io/posts/algorithm---leetcode-85---maximal-rectangle/","tags":["Algorithm","LeetCode"],"title":"Algorithm - LeetCode 85 - Maximal Rectangle"},{"contents":"Description 84. 柱状图中最大的矩形 Sample input heights = [2,1,5,6,2,3] output 10 Key points 目標是 找到每個柱子能擴展的最大寬度，然後計算以該柱子為高度的最大矩形面積。 Solution 1 - 暴力解 對於每個 heights[i]，向 左、右 擴展，直到遇到比它矮的柱子。 左邊界 (left)：找第一個小於 heights[i] 的索引 右邊界 (right)：找第一個小於 heights[i] 的索引 寬度 (width)：width = right - left - 1 面積 (area)：area = heights[i] * (right - left - 1) 推導 i heights[i] left right width area 0 2 -1 1 1 2 1 1 -1 6 6 6 2 5 1 4 2 10 3 6 2 4 1 6 4 2 1 6 4 8 5 3 4 6 1 3 最大矩形面積 = 10\n複雜度 時間複雜度：O(n^2) 空間複雜度：O(n) Solution 2 - 單調棧 單調棧 : 棧內元素 會按照 遞增/減順序 存放\n使用 單調遞增棧（Monotonic Increasing Stack） 當 遇到一個比棧頂元素小的數，意味著 棧頂柱子找到了右邊界 右邊界確定時，順便出棧，並計算面積 推導 設定 stack = [] 為了確保最後能計算所有矩形，在 heights 末尾補 0，確保最後所有柱子都會出棧。 i heights[i] Stack (i) action area 0 2 [0] 入棧 1 1 [] 出棧 (2 找到右邊界) 2 * (1 - 0) = 2 1 1 [1] 入棧 2 5 [1,2] 入棧 3 6 [1,2,3] 入棧 4 2 [1,2] 出棧 (6 找到右邊界) 6 * (4 - 3) = 6 4 2 [1] 出棧 (5 找到右邊界) 5 * (4 - 2) = 10 4 2 [1,4] 入棧 5 3 [1,4,5] 入棧 6 0 [1,4] 出棧 (3 找到右邊界) 3 * (6 - 5) = 3 6 0 [1] 出棧 (2 找到右邊界) 2 * (6 - 1) = 8 6 0 [] 出棧 (1 找到右邊界) 1 * (6 - 0) = 6 最大矩形面積 = 10\n複雜度 時間複雜度：O(n) 空間複雜度：O(n) ","permalink":"https://HoshikawaRyuukou.github.io/posts/algorithm---leetcode-84---largest-rectangle-in-histogram/","tags":["Algorithm","LeetCode"],"title":"Algorithm - LeetCode 84 - Largest Rectangle in Histogram"},{"contents":"Search Gelbooru image search Danbooru image search キャラ誕 アニメ漫画ラノベ キャラクター誕生日カレンダー Translation Fast manga translator \u0026amp; Translations in Multiple Languages ","permalink":"https://HoshikawaRyuukou.github.io/posts/acg---note/","tags":["ACG"],"title":"ACG - Note"},{"contents":" ⚠️ 以下使用 unity 6\nGuide Day10 / Unity 跟上時代！如何設定 Visual Studio Code 編輯器環境 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 VSCode Extensions Extension - Unity .NET SDK 安裝 .NET Core Mac M 系列 ( M1 M2 ) ➔ .NET SDK Arm64 版本 Mac 其餘型號 ➔ .NET SDK x64 版本 Windows ➔ .NET SDK x64 版本 重新開機使環境變數被應用 Unity Package Manager 移除 Visual Studio Code Editor 已經停止維護 (比較舊的版本可能要裝) 安裝 Visual Studio Editor Preferences Edit \u0026gt; Preferences \u0026gt; External Tools External Script Editor \u0026gt; Visual Studio Code Generate .csproj files for Embedded packages Local packages Common Preferences Edit \u0026gt; Preferences \u0026gt; General \u0026gt; Script Changes While Playing (Stop Playing and Recompile) ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---environment/","tags":["Unity","Mac","VScode"],"title":"Unity - Environment"},{"contents":"Analyzer WizTree - The Fastest Disk Space Analyzer Antivirus DefenderUI Automation taojy123/KeymouseGo Batch Save All Resources Context BluePointLilac/ContextMenuManager Diagram 只會用 Office 畫流程圖？許多人試用過這個後直呼回不去了 👍 | Draw.io 教學 postspark Document HackMD：協作 Markdown 文件，分享知識的平台 Media - Image Spritesheet Cutter texture packer Atlased Media - Speech jianchang512/stt Media - Video 如何安裝FFmpeg ScreenToGif Twitter 影片下載器 VLC media player Tyrrrz/YoutubeDownloader mifi/lossless-cut CapCut Andrews54757/FastStream Message Emojipedia Network rejetto/hfs terreng/simple-web-server emanuele-f/PCAPdroid Package Manager marticliment/UniGetUI Translation 沙拉翻譯：聚合字典 、劃詞翻譯 \u0026amp; 查詞 - Chrome 線上應用程式商店 dmMaze/BallonsTranslator Search Felo - 您的免費 AI 搜尋引擎 Site 史上最簡單「一頁式網站」建置工具！ | Google Sites 協作平台快速上手 ","permalink":"https://HoshikawaRyuukou.github.io/posts/tools/","tags":["Tools"],"title":"Tools"},{"contents":"Quick Chat ⚠️ 這是一篇新手導向的筆記，目的不在於精準解釋。 ⚠️ 環境配置請參考 AI - Stable diffusion - Environment ⚠️ Checkpoint 一般會提供推薦的參數設置，建議依據模型的特性調整，以獲得最佳效果。 Resources Civitai: The Home of Open-Source Generative AI Checkpoint 決定生成圖片的基礎風格。\n寫實風格 (Photorealistic) 動漫風 (Anime) 油畫風格 (Painting) 科幻賽博龐克 (Cyberpunk) 像素風格 (Pixel Art) LoRA 輕量化微調模型可額外載入來增強特定風格或角色。\n簡單的比喻來形容 LoRA 模型，那就是「濾鏡」 Embedding 增強對某些 Prompt 的理解。\nVAE 提高圖片細節與顏色準確度。\n📝 部分 Checkpoints 會內建（Baked）VAE，如使用外部 VAE，請確認是否需要覆蓋內建版本。 ⚠️ 如果發現圖片的型都對，但只有顏色壞掉，通常都是 VAE 的問題。 Sampler + Schedule Sampler 是從雜訊圖到成品的去噪算法。\n快速收斂 – 能迅速找到解答，適合驗證創意和想法。 高品質收斂 – 需較長時間，但能提供更精確結果。 無固定收斂 – 無明確收斂條件，為創新提供更大空間。 Schedule 是從雜訊圖到成品的去噪程度。\n📝 常用組合\nEuler A Automatic DPM++ 2M Karras DPM++ SDE Karras Steps 從雜訊圖到成品的迭代次數。\n⚠️ 步數過少可能導致產生的影像品質不佳。 ⚠️ 步數過多可能使影像產生過程變得冗長，但未必能提升品質。 📝 建議從較低的步數開始，例如 15 或 20。 CFG Scale 遵循 Prompt 的程度。數值越大，產生的影像與文字提示的相關性越高。\n⚠️ 但當數值過大時可能會出現過度飽和或不自然的情況。 📝 建議從較低的 CFG 比例值開始並增加它，直到對結果滿意為止。 📝 沒有最佳值，要根據模型的不同來設定不同的值。 📝 常用區間：3 ~ 7 Seed 用於生成雜訊圖。\n⚠️ 當圖片大小改變時所生成的雜訊圖也會有差異(即使比例一樣)。 📝 使用相同的 Seed 可重現相同圖片(前提是設備/環境需一致)。 📝 設為 -1 為隨機。 📝 固定 Seed 進行實驗：在進行圖像生成時，建議固定一個 Seed，然後調整提示詞或其他參數，以便觀察這些變化對最終圖像的影響。 Clip Skip 調整生成圖像過程中對提示詞的處理方式。\n📝 現實系建議設為 1。 📝 動畫風建議設為 2。 Prompt 正向 Prompt：描述想要的畫面，例如 a beautiful girl, wearing kimono, sakura background\n負向 Prompt：描述不想要的內容，例如 blurry, low quality, deformed\nBREAK：可用來分隔不同場景或主題。例如：a warrior in armor BREAK a futuristic cityscape。\n數值控制權重：使用 (word:1.2) 來增加特定詞的影響力，數值越高影響越強。例如：(beautiful:1.5), (dark:0.8) 讓 \u0026ldquo;beautiful\u0026rdquo; 更突出，而 \u0026ldquo;dark\u0026rdquo; 影響較弱。\n從左到右的順序來解析提示詞，越前面的詞影響越大，越後面的詞影響越小。\n不同的 Checkpoints 對提示詞的理解會有所不同，選對模型才能產生最好的效果。\n提示詞應該從少量開始，逐步增加，這樣才能確保：\n確定哪些詞有效 避免無效詞 確保 Prompt 保持清晰，容易控制風格 Settings Saving images \u0026gt; Saving images/grids Images filename pattern : [datetime]-[seed] Add number to filename when saving : 反選 這樣避免整合圖片時發生亂序。 Extras img2img - inpaint ControlNet ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---stable-diffusion---quick-start/","tags":["AI","Stable diffusion","Art"],"title":"AI - Stable diffusion - Quick Start"},{"contents":"a1111-sd-webui-tagcomplete DominikDoom/a1111-sd-webui-tagcomplete sd-webui-prompt-all-in-one Physton/sd-webui-prompt-all-in-one adetailer Bing-su/adetailer sd-webui-photopea-embed yankooliveira/sd-webui-photopea-embed sd-webui-lora-block-weight hako-mikan/sd-webui-lora-block-weight XERSON005:1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0 PERSON105:1,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0 ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---stable-diffusion---extensions/","tags":["AI","Stable diffusion","Art"],"title":"AI - Stable diffusion - Extensions"},{"contents":"Quick Chat 建議新手直接從 Forge 入門即可\nGuide Comfyui官方客户端 desktop桌面版来了 AI 繪圖的終極沙盒 ComfyUI 快速上手 #1 無視一切規則，AI 神級繪圖工具還給你全方位掌控權！ AI 繪圖的終極沙盒 ComfyUI 快速上手 #2 - LoRA 微調模型 \u0026amp; AI 影像畫質提升 AI 繪圖的終極沙盒 ComfyUI 快速上手 #3 - ControlNet 精確構圖技巧 Automatic1111 是最早推出的圖形使用者介面之一，為使用者提供了直觀且功能豐富的操作平台。由於其開源性質和強大的社群支持，許多初學者和開發者選擇從 Automatic1111 入手，逐步熟悉 Stable Diffusion 的各項功能和應用。\nForge 基於 Automatic1111 進行了多項優化\n記憶體控制優化且推理速度提升 算法優化 新增取樣器 簡化的命令標誌 介面與 Automatic1111 高度相似，基本能無痛從 Automatic1111 轉移。\nset COMMANDLINE_ARGS=--xformers --no-half-vae --medvram ComfyUI 是一個開源的節點式圖形介面，允許使用者通過直觀的節點系統設計和執行複雜的工作流程。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---stable-diffusion---gui/","tags":["AI","Stable diffusion","Art"],"title":"AI - Stable diffusion - GUI"},{"contents":"Local deployment ⚠️ 以下皆須安裝指定版本不可貿然升級\nnvidia 驅動更新至最新 cuda: CUDA 12.1 檢查顯卡支援的最高 cuda 支援: nvidia-smi 顯示CUDA編譯工具的版本信息: nvcc --version Python: Python 3.10.11 python --version Git: Fork GUI: lllyasviel/stable-diffusion-webui-forge clone 上述專案，執行 webui.bat Google Colab gutris1/segsmaker cagliostrolab/forge-colab Civitai API Key Menu \u0026gt; Account Settings(齒輪 icon) \u0026gt; API Keys\n","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---stable-diffusion---environment/","tags":["AI","Stable diffusion","Art"],"title":"AI - Stable diffusion - Environment"},{"contents":"Quick Chat Web 遊戲的測試免不了要在實機上觀測 FPS 數據。\nDevice 開啟開發者選項 USB 為資料傳輸模式 Browser - Firefox 手機 Firefox 瀏覽器開啟 USB 偵錯 網址列輸入 about:debugging#/setup 連接 USB 裝置 選擇分頁 Console (function () { let lastTime = performance.now(); let frame = 0; function loop() { let now = performance.now(); frame++; if (now \u0026gt; lastTime + 1000) { console.log(`FPS: ${frame}`); lastTime = now; frame = 0; } requestAnimationFrame(loop); } loop(); })(); ","permalink":"https://HoshikawaRyuukou.github.io/posts/game-development---web-game---device-evaluation/","tags":["Game Development"],"title":"Game Development - Web Game - Device Evaluation"},{"contents":"Quick Chat 建議閱讀順序\nAI - Stable diffusion - Environment AI - Stable diffusion - GUI AI - Stable diffusion - Quick Start AI - Stable diffusion - Extensions AI - Stable diffusion - CheckPoints AI - Stable diffusion - Resources Core Working Principles Stable Diffusion 主要包含三個核心技術：\n前向擴散（Forward Diffusion） 先從大量圖片資料集中學習圖片特徵。 然後，系統會逐步加入高斯雜訊（Gaussian Noise），使圖片變得模糊、無法辨識。 最後，這個過程會讓圖片變成完全的純雜訊（random noise）。 反向去噪（Reverse Denoising / U-Net） Stable Diffusion 學習如何逆向去噪，一步步從雜訊還原出清晰的圖片。 這部分的關鍵是 U-Net 神經網路架構，它可以在多層次的細節中，捕捉圖片的各種特徵。 文本引導（Text Conditioning / CLIP） Stable Diffusion 之所以能生成符合指令的圖片，是因為它使用了CLIP（Contrastive Language-Image Pretraining）。 CLIP 會將文字轉換成向量表示（latent embeddings），這些向量再指導模型生成符合描述的圖像。 Diagram Improving Diffusion Models as an Alternative To GANs, Part 1 ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---stable-diffusion---overview/","tags":["AI","Stable diffusion","Art"],"title":"AI - Stable diffusion - Overview"},{"contents":"Quick Chat Overdraw 就是 「同一個像素點被繪製多次」，當 Unity 把一個畫面繪製出來時，所有 Sprite 都是 從後到前（Back to Front） 疊加上去。如果某個像素被重複繪製了很多次，GPU 的工作量就會變大，導致 效能下降。\nCases 大量重疊的透明 Sprite 2D 遊戲裡很多元素是有 透明區域（Alpha 通道） 的，例如 UI、特效、光影效果。 GPU 必須計算這些透明度，並且疊加不同圖層的顏色，這個過程很吃資源。 過多的粒子 \u0026amp; 特效 如果妳的遊戲有超多粒子特效，特別是 煙霧、火焰、閃光 這種會有大量透明像素的元素。 大範圍透明圖 例如 UI 設計時，一個按鈕可能只是中間一小塊有圖案，但它的整張貼圖是 512 x 512 的 PNG，外圍全是透明的區域，這樣就會讓 GPU 花額外的時間去計算透明像素，而不是有效渲染有內容的部分。 畫面排序導致重複繪製 Unity 會根據 Sorting Layer 和 Order in Layer 來決定渲染順序。 如果物件排序不合理，可能會讓後面的 Sprite 被前面的遮住，但 GPU 還是得先畫出來，結果白白浪費效能。 Debug Unity 內建了檢測工具 打開 Scene 視圖 點擊 Shading Mode 選擇 Overdraw Mode Overdraw 視覺化顯示方式 藍色 / 黑色 → 幾乎沒問題 綠色 / 黃色 → 有點 Overdraw，但還能接受 紅色 / 白色 → 🚨 過度繪製嚴重，GPU 負擔大，要優化了！ Optimization 減少透明區域 盡量 縮小 Sprite 的實際範圍，不要讓透明區域過大。 例如 UI 按鈕的 Sprite，最好裁剪成 剛好包住可見部分，而不是整張 512x512 貼圖全都透明。 善用 Sprite Packing（圖集） 把小圖合併成 Sprite Atlas，讓 GPU 少做一些不必要的切換，提高效率。 減少畫面重疊的透明圖層 UI 設計時，盡量讓按鈕、圖示等 不要有過多重疊。 如果 UI 有半透明背景，可以嘗試改用 單一大圖片代替多個小圖片疊加。 控制粒子數量 降低粒子數量 縮小粒子範圍 減少透明度計算（調整 Shader） 改善 Sorting Order 避免不必要的遮擋運算，如果一個物件永遠會被其他東西蓋住，考慮 改變它的 Sorting Layer，甚至在不必要時直接不渲染它（SetActive(false)）。 使用 Shader 優化透明渲染 如果 Sprite 不需要半透明效果，可以換成 Opaque Shader（不透明著色器），這樣 GPU 就不會計算透明度疊加。 改用 Tilemap 如果遊戲是 2D 地圖類型（像素風格、平面地圖等），可以用 Unity Tilemap 來減少 Overdraw，因為 Tilemap 會幫妳合併小區塊來優化繪製。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---performance---render---overdraw/","tags":["Unity","Performance"],"title":"Unity - Performance - Render - Overdraw"},{"contents":"Community Civitai Qpipi_AI绘画社区和SD模型 Channel 星光のAIラボ SoreNuts Prompts SDXL Prompts 進階指南 (1) - 鏡頭視角距離 Stable Diffusion 用 prompt 控制鏡頭距離及角度 Illustrious XL / NoobAI XL Hairstyles Gallery PixAI.Art AIBooru Lizardon1025 pepegles Artists artist list Artists | Danbooru Akitetsu | Danbooru Sakamoto Masaru | Danbooru Fight Yoghurt | Danbooru Reia 76 | Danbooru Kagto (Alterna) | Danbooru mo (kireinamo) | Gelbooru Happoubi Jin | Danbooru Ohisashiburi | Danbooru Shirotaka (5Choume) | Danbooru Rokuwata Tomoe | Danbooru Fight Yoghurt | Danbooru Hidis0086 | Danbooru Ulrich (Tagaragakuin) | Danbooru Haimura Kiyotaka | Danbooru Qtian | Danbooru Zanya 000 | Danbooru ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---stable-diffusion---resources/","tags":["AI","Stable diffusion","Art"],"title":"AI - Stable diffusion - Resources"},{"contents":"Quick Chat ⚠️ 以下主題專注於二次元/動漫風格圖像生成 Guide Re: [問題] AI 風格怎麼了嗎？為什麼容易膩？ - 看板C_Chat - PTT網頁版 SD1.5 在性能和穩定性上提升很多，社群迎來爆發式成長。\nMilestone/Events Waifu Diffusion：這是一個基於 Stable Diffusion 的模型，專注於生成二次元風格的圖像。該模型使用 Danbooru 資料集進行訓練，適合生成各類動漫風格的圖像。\nNovelAI 模型外洩（NAI）：NovelAI 是一個提供 AI 輔助創作的服務平台，其專注於二次元圖像生成的模型曾發生外洩事件。該模型同樣使用 Danbooru 資料集進行訓練。\nAnything 系列模型：Anything V3 和 V4 是專注於二次元圖像生成的模型，具有較高的生成質量和風格多樣性。\nChilloutMix：這是一個專注於生成寫實風格圖像的模型，能夠生成高品質的寫實人物圖像。\nResolutions 512 x 512 : 1:1 512 X 768 : 2:3 SDXL 相比於 SD1.5 在多方面有顯著的提升\n更大的模型規模：SDXL 的參數量遠超 SD1.5，這使其能夠捕捉更複雜的圖像特徵。 更高分辨率：SDXL 支持更高分辨率的圖像生成。 雙模型架構：SDXL 採用雙模型架構，包含一個基礎模型和一個精煉模型。基礎模型生成初步圖像，精煉模型進一步提升細節和質量，這種分工協作顯著提升了生成效果。 更強的文本理解能力：SDXL 在理解複雜提示詞方面表現更好，能更準確地將文本描述轉化為圖像內容，減少誤解和偏差。 Milestone/Events Pony Diffusion：\n訓練流程有使用審美分級標籤。 原版 Pony 生成的結果接近歐美審美。 Pony 系明顯缺點用色偏暗偏髒。 Pony 在「多人互動」方面與 nsfw 表現很好。 NovelAI 3 (NAI3)：\n在識別和再現特定角色和畫師風格方面表現出色，能夠生成高度還原的角色形象和畫風，並融合風格。 Illustrious XL：\nIllustrious XL 提示 (+ 更新！) NoobAI XL：\nNOOBAI XL快速指南 Resolutions 640 x 1536 = 5:12 768 x 1344 = 4:7 832 x 1216 = 13:19 896 x 1152 = 7:9 1024 x 1024 = 1:1 1024 x 1536 = 2:3 ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---stable-diffusion---checkpoints/","tags":["AI","Stable diffusion","Art"],"title":"AI - Stable diffusion - CheckPoints"},{"contents":"Quick Chat SSH（Secure Shell）是一種加密的網路協議，允許你安全地連接到遠端伺服器。對 Git 來說，使用 SSH 主要有這些優勢：\n免密碼認證：使用 SSH 金鑰（SSH Keys）後，不需要每次都輸入帳號密碼。 更安全：SSH 使用非對稱加密，比 HTTPS（帳號 + 密碼）更安全。 更適合自動化：如果你要寫腳本來自動處理 Git 操作，SSH 會比 HTTPS 更方便。 Env - Windows ⚠️ 以下皆使用 PowerShell 操作\nStep 1: 檢查 Windows 是否已安裝 OpenSSH Windows 10 以上的系統已經內建 OpenSSH\nssh -V 如果有顯示類似這樣的版本資訊，代表 OpenSSH 已經安裝：\nOpenSSH_for_Windows_8.1p1, LibreSSL 3.0.2 Step 2: 產生 SSH 金鑰 ssh-keygen -t rsa -b 4096 -C \u0026#34;your-email@example.com\u0026#34; t rsa：使用 RSA 演算法（GitHub 推薦） b 4096：密鑰長度 4096 bits（更安全） C \u0026quot;your-email@example.com\u0026quot;：加上你的 Email 作為標註 Step 3: 儲存金鑰 執行指令後，系統會詢問你要存在哪裡：\nEnter file in which to save the key (/c/Users/YourName/.ssh/id_rsa): # 直接按 Enter 然後，系統會問你是否要設定密碼（passphrase），如果你希望 SSH Key 更安全，可以輸入密碼，否則直接按 Enter。\nStep 4: 將公鑰新增到 Git 服務 SSH 金鑰有兩個檔案：\n私鑰（id_rsa）：不要洩漏，這是你本機的登入金鑰。 公鑰（id_rsa.pub）：可以分享，這是給遠端伺服器認證的金鑰。 檢視公鑰\nGet-Content $env:USERPROFILE\\.ssh\\id_rsa.pub 填入 GitHub\nSettings \u0026gt; SSH and GPG keys（GitHub）\nStep 5: 測試 SSH 連線 ssh -T git@github.com 如果成功，你會看到\nHi your-username! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. ","permalink":"https://HoshikawaRyuukou.github.io/posts/network---protocol---ssh/","tags":["Network"],"title":"Network - Protocol - SSH"},{"contents":"Quick Chat 在 GitHub 上，SSH Key 有兩種加法：\n1. 加到個人帳戶 適用於：你要用 SSH 可以 存取你有權限的所有 Repo 位置：GitHub \u0026gt; Settings \u0026gt; SSH and GPG keys 2. 加到 GitHub 組織的 Deploy Key（組織的特定倉庫） 適用於：你的 SSH Key 只 存取某個特定的組織 Repo，而不是整個帳號 位置：GitHub 組織 \u0026gt; 目標 Repository \u0026gt; Settings \u0026gt; Deploy keys 📝 如果你是組織的開發者，通常是第一種（加到個人帳戶），因為組織管理員不一定會讓你直接加 Deploy Key。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/github---ssh-key/","tags":["Github"],"title":"Github - SSH Key"},{"contents":"Quick Chat Unity Package Manager (UPM) 支援從 Git repository 直接安裝與管理 package，這對於團隊開發和共享自定義 package 非常有用。\n⚠️ 如果是 organization 協同，需開啟相關的成員權限。 ⚠️ Using private repositories with HTTPS Git URLs，提到的 Git Credential Manager 似乎不起作用。 Solution 1 - SSH (建議) ⚠️ 需確保 SSH Key 已添加到 GitHub。 Solution 2 - Personal Access Token ⚠️ 建議使用較客製化的 Fine-Grained Token ⚠️ Resource owner 要注意(如果有多個身分) Guide Install Unity Package from a private GitHub repository Steps 至 GitHub \u0026laquo;帳戶設定\u0026raquo;（非儲存庫設定） Developer Settings -\u0026gt; Personal Access Tokens -\u0026gt; Fine-Grained Tokens 生成 Token (Read-Only Permission for the repo Content). \u0026#34;com.yourusername.yourpackage\u0026#34;: \u0026#34;git+https://x-oauth-basic:\u0026lt;token\u0026gt;@\u0026lt;repo\u0026gt;?path=\u0026lt;folder\u0026gt;\u0026#34; ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package-manager---import-a-private-package-from-github-repository/","tags":["Unity","Package Manager","GitHub"],"title":"Unity - Package Manager - Import a private package from GitHub repository"},{"contents":"GitHub Actions gh-pages.yml name: github pages on: push: branches: - main pull_request: jobs: deploy: runs-on: ubuntu-22.04 steps: - uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v4 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public ","permalink":"https://HoshikawaRyuukou.github.io/posts/hugo---github-actions-+-github-pages/","tags":["Hugo","Github"],"title":"Hugo - Github Actions + Github Pages"},{"contents":"Quick Chat 使用 Hugo 建立網站時，Markdown 編輯器預覽圖片時可能遇到的問題。\n原因是相對路徑\n文章位於 /content/posts 目錄 圖片位於 /static/images 目錄 Hugo 能夠正確渲染圖片，因為它知道 /images 是相對於 static 目錄的路徑。然而，許多 Markdown 編輯器在預覽時，無法識別這種相對路徑，導致圖片無法顯示。\nSolutions Rendering Images in Markdown Preview of Hugo Site 在 Hugo 項目的根目錄創建一個指向 static/images 目錄的符號連結（symlink）。 以管理員權限開啟 cmd mklink /D images .\\static\\images ","permalink":"https://HoshikawaRyuukou.github.io/posts/hugo---image-reference/","tags":["Hugo","Blog"],"title":"Hugo - Image Reference"},{"contents":"Quick Chat Blog/筆記軟體 平台玲瑯滿目，但依賴於平台的風險難以忽視(倒站/政策改變)，網站搬家也讓人很頭疼。此 Blog 採方案是 Github Pages + Hugo。\nGuide The world’s fastest framework for building websites | Hugo gohugoio/hugo Hugo 從零開始 環境安裝(Windows) Environment 至 Hugo github release 下載執行檔 (hugo_extended) 設置環境變數 hugo version : 檢視 hugo 版本 Quick Chat adityatelange/hugo-PaperMod 建議新手使用該主題練習 社群較活躍 教學較完善 Themes Hugo Themes hoshikawaryuukou/hugo-theme-cactus 本 Blog Theme 基於以下 repository 修改 monkeyWzr/hugo-theme-cactus OmeletWithoutEgg/hugo-theme-cactus Custom 使用 git submodule 導入主題。 不要直接修改主題範本文件。 要修改的文件從主題範本 複製(文件夾結構要相同) 出來到根目錄，Hugo 會照優先度來處理。 多數主題都有配置 Google Analytics，只需填入 id 到 config 即可。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/hugo---note/","tags":["Hugo"],"title":"Hugo - Note"},{"contents":"Quick Chat 發現 GitHub 網頁面板上好像沒辦法直接刪除 deployment，得用 GitHub CLI 來操作。\nGuide GitHub CLI | Take GitHub to the command line Memo 登入 gh auth login 僅保留最近 200 個部屬，其餘的刪除 gh api repos/{owner}/{repo}/deployments --paginate --jq \u0026#39;.[].id\u0026#39; | Select-Object -Skip 200| ForEach-Object { Write-Host \u0026#34;Deleting deployment $_\u0026#34; gh api --method DELETE repos/{owner}/{repo}/deployments/$_ } gh api：用 GitHub CLI 發送 API 請求。 repos/{owner}/{repo}/deployments：指定查詢的 GitHub Repository 和其部署。 --paginate：表示如果結果有很多頁，會自動翻頁取得所有部署資訊。 --jq '.[].id'：這部分是使用 jq 來過濾和格式化結果，提取所有部署的 ID。 Select-Object -Skip 200：這行會將返回的部署 ID 進行處理，並跳過前 200 個部署。 ForEach-Object { ... }：對每一個 ID 執行大括號 {} 中的命令。 --method DELETE：指定 HTTP 請求方法為 DELETE，用來刪除資源。 repos/{owner}/{repo}/deployments/$_：指定要刪除的部署，$_ 是當前處理的 deployment ID。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/github---github-cli/","tags":["Github"],"title":"Github - GitHub CLI"},{"contents":"Quick Chat Addressables 是在 AssetBundle 的基礎上對操作進行更友善的封裝，AssetBundle 有很多要小心的地方\nAssetBundle 卸載 Addressable System 主要改善幾點\n透過 name/label，而是不與資源直接連結，減少因移動或重命名資產而出錯的機會。 本地或是異地都可以追踪。 簡化打包和依賴管理(name/label/group/catalog)。 較好的記憶體管理機制(引用計數)與性能分析系統。 Guide tuyoogame/YooAsset AssetBundle Assets, Resources and AssetBundles Case Studies of Unity AssetBundle Efficient Encryption Addressable Frameworks 不同 Framework 在常規操作上大同小異，可以從資源最多的 Addressables 做觀念入門\nUnity Addressables资源管理方式用起来太爽了，资源打包、加载、热更变得如此轻松（Addressable Asset System | 简称AA） Unity - Addressables项目总结（一）：基础工作流 Unity - Addressables项目总结（二）：业务需求 静态包、动态包有什么区别？何时使用增量更新？Addressables 更新流程大梳理 Issue Shaders are pink when loaded from an AssetBundle 大部分時候是 Editor 的問題，關注真機運作如何即可(因為 AssetBundle 是根據指定平台生成的)。 ⚠️ Unity 6 之後似乎無法透過取消 Auto Graphics API 來調整 Graphics API Extra 为什么抛弃了 Addressable ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package---yooasset/","tags":["Unity"],"title":"Unity - Package - YooAsset"},{"contents":"Quick Chat ⚠️ 使用 Unity 6 開發 Guide Unity - Manual: Web Getting started with Unity Web 【Unity】WebGL開発時の注意事項 Unity发布webgl获取浏览器的URL Unity WebGLビルドメモ - フレームシンセシス Unity 製 WebGL ゲームを AWS でお手軽公開 Template (Unity) Better Minimal WebGL Template Performance Using the Unity Profiler Using the web platform Diagnostics Overlay tool Unity WebGL Loading Test Host terreng/simple-web-server terreng/sws-unity-plugin Issue Error : Failed to parse binary data file Build/xxx.data.br\u0026hellip; Failed to parse binary data file Build/web.data.br (with \u0026ldquo;Content-Type: null\u0026rdquo;), because it is still brotli-compressed. It should have been uncompressed by the browser, but it was unable to do so since the web server provided the compressed content without specifying the HTTP Response Header \u0026ldquo;Content-Encoding: br\u0026rdquo; that would have informed the browser that decompression is needed. Please verify your web server hosting configuration to add the missing \u0026ldquo;Content-Encoding: br\u0026rdquo; HTTP Response Header.\n📝 需要配置 Content-Encoding 參考 terreng/sws-unity-plugin\nError : Unable to load file Build/xxx.framework.js.br\u0026hellip; Unable to load file Build/xxx.framework.js.br! Check that the file exists on the remote server. (also check browser Console and Devtools Network tab to debug)\n📝 這是因為 Brotli 壓縮算法僅在 HTTPS 連接中被啟用\n","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---platform---web/","tags":["Unity","Web"],"title":"Unity - Platform - Web"},{"contents":"Quick Chat 參考以下教學\n十分钟部署本地离线免费大模型！ Ngrok + Ollama | 在世界任何地方与localhost开源大模型聊天 Free Inference Is All I Need: How to Run Large Language Models for Free Using Google Colab Requirements 註冊 ngrok 帳號，取得 token ( ngrok \u0026gt; Your Authtoken ) 將 token 填至 colab \u0026gt; Secret name : NGROK_AUTH value : token 本機端使用 Page Assist - A Web UI for Local AI Models 與 Ollama 互動 Steps 安裝必要工具 !sudo apt-get install -y pciutils !curl https://ollama.ai/install.sh | sh !pip install pyngrok 安裝 pciutils: 提供硬件檢測和配置工具，用於檢查和診斷 GPU 設置。 安裝 Ollama: 下載並執行 Ollama 的安裝腳本。 安裝 pyngrok: 用於創建到本地服務的反向代理，從而將本地服務器公開到互聯網。 啟動 Ollama 服務器 import os import threading import subprocess import requests from pyngrok import ngrok, conf from google.colab import userdata def ollama(): os.environ[\u0026#39;OLLAMA_HOST\u0026#39;] = \u0026#39;0.0.0.0:11434\u0026#39; os.environ[\u0026#39;OLLAMA_ORIGINS\u0026#39;] = \u0026#39;*\u0026#39; os.environ[\u0026#39;OLLAMA_KEEP_ALIVE\u0026#39;] = \u0026#39;-1\u0026#39; subprocess.Popen([\u0026#34;ollama\u0026#34;, \u0026#34;serve\u0026#34;]) ollama_thread = threading.Thread(target=ollama) ollama_thread.start() 配置環境變量： OLLAMA_HOST: 指定服務器的主機和端口，這裡為 0.0.0.0:11434，表示本地所有網絡接口。 OLLAMA_ORIGINS: 設置跨域資源共享 (CORS) 的允許範圍。 OLLAMA_KEEP_ALIVE: 保持服務器活躍的時長（-1 表示無限）。 啟動 Ollama 服務器：使用 subprocess 啟動 Ollama 的服務模式。 使用執行緒運行服務器：確保主程序不被阻塞，允許服務器在後台運行。 下載模型 Ollama search !ollama pull {model_name} 公開服務 conf.get_default().auth_token = userdata.get(\u0026#39;NGROK_AUTH\u0026#39;) ollama_tunnel = ngrok.connect(\u0026#34;11434\u0026#34;, \u0026#34;http\u0026#34;) public_url = ollama_tunnel.public_url print(f\u0026#34;Public URL: {public_url}\u0026#34;) 配置 ngrok 驗證令牌：使用用戶提供的 NGROK_AUTH 確保 Tunnel 服務的授權。 創建 ngrok Tunnel： 將本地服務器（11434 端口）通過 HTTP 隧道公開到互聯網。 獲取公開 URL： 輸出 Tunnel 的公開 URL，便於遠程訪問 Ollama 服務。 列出可用模型 !ollama list 執行模型 !ollama run {model_name} 透過 Page Assist 訪問 於 Page Assist 設置 public_url 訪問 public_url 並點擊 visit site，否則 Page Assist 偵測不到遠端 ollama ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---ollama---google-colab-+-ngrok/","tags":["AI","Ollama","Google Colab","ngrok"],"title":"AI - Ollama - Google Colab + ngrok"},{"contents":"Quick Chat 1. 如果你的程式中，有一個物件需要另一個物件，應該怎麼做？ 直接由需求方 new 一個實例嗎？ 2. 如果那個物件的建構方式很複雜呢？ 例如，它可能需要多個參數，還需要一些初始化邏輯。 如果每次都在需求方進行這些操作，會不會重複又繁瑣？ 3. 如果有多個需求方重複依賴這個物件呢？ 這些需求方能共享同一個物件嗎？ 如果共享，如何管理這個共用的實例？誰來負責它的生命週期？ 4. 依賴管理是誰的責任？ 需求方是否應該負責處理自己所有的依賴？ 還是應該有一個「專門負責管理依賴」的角色？ 如果有一個「外部機制」來幫你管理這些依賴，需求方只需要專注於自己的邏輯，不需要擔心如何建構物件，這樣會不會更簡單？ 控制反轉 - 什麼反轉了？ 控制反轉（Inversion of Control, IoC）就是為了解決這些問題而生的。它帶來了一個核心理念：\n需求方不再自己去「控制」依賴的構建和配置，而是把這部分的「控制權」交給「外部機制」（通常是 IoC 容器）。\n需求方只需專注於「接收」或「查詢」依賴，並專心「使用」它們。簡化需求方的職責，使其僅專注於處理業務邏輯，從而提升模組化與可維護性。\n好處 依賴管理 通過外部機制統一管理依賴，開發者不需要在各處手動管理物件實例的生命週期與建構邏輯。 容器能管理共享的物件實例，有效避免重複建構，提高資源利用率。 將依賴配置集中於容器，能輕鬆應對需求變更。例如，替換某個服務的具體實現時，只需要調整配置，而非修改多處程式碼。 提升模組化與可維護性 需求方與具體實現之間的耦合度降低，使得每個模組能更容易地獨立開發、測試與替換。 提升測試便利性 透過依賴注入，需求方可以接收模擬物件（mock）或測試替身（stub），從而更輕鬆地撰寫單元測試。 sample - c# var mockStorageService = new Mock\u0026lt;IStorageService\u0026gt;(); mockStorageService.Setup(service =\u0026gt; service.SaveOrder(It.IsAny\u0026lt;Order\u0026gt;())).Verifiable(); var orderService = new OrderService(mockStorageService.Object); sample - js const mockStorageService = { saveOrder: (order) =\u0026gt; { console.log(`Mock saving order ${order.id}`); }, }; const orderService = new OrderService(mockStorageService); 技術實現 組合根（Composition Root） 集中管理所有依賴的構建與組合，通常位於應用程式的進入點。 依賴尋找（Dependency Lookup） 需求方主動向容器請求所需的依賴。 依賴注入（Dependency Injection, DI） 容器將依賴主動注入至需求方的機制，例如透過建構子注入、屬性注入或方法注入。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---principle---inversion-of-control-ioc/","tags":["Software Design","Principle"],"title":"Software Design - Principle - Inversion of Control (IoC)"},{"contents":"Guide GlitchEnzo/NuGetForUnity Config 將資源調整放置 Packages 而不是 Assets\nNuGet \u0026gt; Preferences \u0026gt; Placement \u0026gt; In Packages Folder\n調整 .gitignore\n/Packages/nuget-packages/InstalledPackages* ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package-manager---nugetforunity/","tags":["Unity","Package Manager","NuGet"],"title":"Unity - Package Manager - NuGetForUnity"},{"contents":"Guide Cysharp/MessagePipe Extras 搭配 VContainer v1.14.0 之後可以簡化配置\nusing MessagePipe; using UnityEngine; using VContainer; using VContainer.Unity; public sealed class GameLifetimeScope : LifetimeScope { protected override void Configure(IContainerBuilder builder) { // 只需這行即可 builder.RegisterMessagePipe(); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package---messagepipe/","tags":["Unity"],"title":"Unity - Package - MessagePipe"},{"contents":"Quick Chat 後端: 深入且穩定 前端: 廣泛且彈性 Roadmap Developer Roadmaps - roadmap.sh ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-engineer---note/","tags":["Career"],"title":"Software Engineer - Note"},{"contents":"Quick Chat 物件生命週期管理（Object Lifecycle Management）是指在程式運行過程中，對物件的創建、使用、及銷毀進行有效的控制和管理。\n適當的物件生命週期管理有助於提高應用程式的性能、可維護性和資源利用效率。\nStage 創建：\n物件被創建並初始化。 創建時，可能會注入其他依賴物件或設定一些必要的屬性。 使用：\n物件在應用程式中進行各種操作，如方法調用、屬性設定等。 這是物件的活躍期，通常是應用程式邏輯處理的核心部分。 銷毀：\n物件不再被需要時，它的資源會被釋放。 這個過程通常涉及到記憶體回收和釋放外部資源（例如檔案、資料庫連線等）。 Lifetime Transient（瞬時）：\n每次請求或需要該物件時會創建一個新的實例。 適用於短暫的、不需要保持狀態的物件。 Singleton（單例）：\n整個應用程式生命周期內，只有一個實例被創建。 適用於那些需要跨應用程式共享狀態的物件。 Scoped（範圍）：\n物件的生命周期被限制在特定的範圍內，通常是某個特定的操作或請求範圍。 在範圍內，物件實例會被共享。但範圍結束後，物件會被銷毀。 適用於那些需要在某個範圍內共享狀態，但範圍結束後無需保持的物件。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---concept---object-lifecycle-management/","tags":["Software Design","Concept"],"title":"Software Design - Concept - Object Lifecycle Management"},{"contents":"Core Application: 是一個簡化使用 PixiJS 的輔助類別。它會建立渲染器、建立舞台，然後啟動一個用於更新的計時器。 Container: 現在是所有 PixiJS 物件的基本類別。 擴充元件 會自行安裝，只須匯入類別即可使用。\nimport \u0026lsquo;@pixi/accessibility\u0026rsquo;;\n","permalink":"https://HoshikawaRyuukou.github.io/posts/pixijs---basic/","tags":["PixiJS"],"title":"PixiJS - Basic"},{"contents":"Guide PixiJS | The HTML5 Creation Engine | PixiJS Starter PixiJS Create | PixiJS Create pnpm create pixi.js Extensions PixiJS Devtools | PixiJS Devtools PixiJS Devtools Template turbokirichenko/pixijs-typescript-vite-template t-tonyo-maru/pub_template_web_pixijs-gsap-spine Sample pixijs/open-games MateuszSuder/PixiSlot CyberDex/pixi-game-ui Particle experiment using Pixi.js \u0026amp; GSAP Sample - slot ktsalik/sloticon artdon/angular-pixi-slots Slamaio/pixi-js-slot-machine jogracz/pixi-slot-game Slot-PixiJS Slots | PixiJS feldhaus/slot-machine Others Pixi | GSAP | Docs \u0026amp; Learning Bug: Visual issue rendering spine on v7 ","permalink":"https://HoshikawaRyuukou.github.io/posts/pixijs---note/","tags":["PixiJS"],"title":"PixiJS - Note"},{"contents":"Solitaire gubicsz/Solitaire Reversi Unity設計練習 - リバーシ qemel/gpp-reversi ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---samples/","tags":["Unity"],"title":"Unity - Samples"},{"contents":"Quick Chat UI = f( state )\nstate\nwidget state : 只存在於當前 widget 範圍內的狀態 app state : 存在於整個應用程式中，多個 widget 可能需要使用的狀態。 Guide 范式角度思考的前端状态管理 2022年，我们还需要全局状态管理吗？ ","permalink":"https://HoshikawaRyuukou.github.io/posts/front-end---state-management/","tags":["Front-End"],"title":"Front-End - State Management"},{"contents":"PixiJS 2D 渲染引擎 專注於高性能渲染，適合需要流暢繪圖的應用場景 提供低層級 API，開發者需要更多手動操作，具高度靈活性 Phaser 2D 遊戲框架 早期基於 PixiJS 開發，現具自有渲染引擎 提供全面的遊戲開發工具集，包含場景管理、物理引擎、動畫和音效支援 支援開發 HTML5 遊戲，並可輕鬆部署至 iOS、Android 或桌面應用 對於 slot game 這種低互動高表演的類型 PixiJS 也許較具優勢\n","permalink":"https://HoshikawaRyuukou.github.io/posts/game-development---web-game---overview/","tags":["Game Development"],"title":"Game Development - Web Game - Overview"},{"contents":"定義 沉沒成本（Sunk Cost）是經濟學中的一個概念，指的是過去已經發生且無法回收的支出。這些成本無論未來如何決策都不會改變，因此在理性決策中應該被忽略。然而，人們在實際決策中往往因心理因素而受到沉沒成本的影響，從而作出不利的選擇。\n核心特點 不可回收性\n沉沒成本是已經投入的資源（例如時間、金錢、精力），即便未來的行動如何，也無法追回或改變。\n與未來無關性\n在理性決策中，應該只考慮未來的邊際收益和成本，而不應因過去的沉沒成本影響判斷。\n生活中的例子 看完無聊的電影\n你購買了一張電影票，但發現電影內容無聊透頂。雖然時間和金錢已經浪費，但你可能仍選擇堅持看完，以求“對得起票價”，這正是受到沉沒成本影響。\n持續不佳的投資\n某項投資已經大幅虧損，但因為之前投入了大量資金或精力，你可能選擇繼續追加投入，試圖“挽回損失”。\n難以放棄的關係\n在一段關係中，儘管雙方已經不再適合，但因為已投入許多感情和時間，人們往往不願結束這段關係。\n商業談判的例子 政府標案策略\n低價中標吸引合作，進入執行後可能因延誤或額外需求而增加成本。政府因已投入預算和時間，通常選擇追加預算，而非重新招標，這樣的情況有效利用了政府痛恨損失的心理。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/economics---sunk-cost/","tags":["Economics","Decision-making"],"title":"Economics - Sunk cost"},{"contents":"Thinking Cognitive load is what matters ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---architecture-design/","tags":["Software Design","Architecture"],"title":"Software Design - Architecture Design"},{"contents":"cocos creator ide 配置 vscode path C:\\Users\\User\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\n⚠️ 較新版的 cocos creator 已經不需要， 开发者 -\u0026gt; VS Code 工作流 -\u0026gt; 安装 VS Code 扩展插件 package manager 使用 pnpm packages pnpm create @eslint/config@latest pnpm add -D prettier pnpm add -D prettier-plugin-organize-imports pnpm add -D eslint-config-prettier vscode - extensions vscode-eslint esbenp.prettier-vscode .vscode/extension.json { \u0026#34;recommendations\u0026#34;: [\u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;dbaeumer.vscode-eslint\u0026#34;] } .vscode/setting.json { \u0026#34;files.exclude\u0026#34;: { \u0026#34;library/\u0026#34;: true, \u0026#34;local/\u0026#34;: true, \u0026#34;temp/\u0026#34;: true, \u0026#34;**/*.meta\u0026#34;: true }, \u0026#34;search.exclude\u0026#34;: { \u0026#34;build/\u0026#34;: true, \u0026#34;temp/\u0026#34;: true, \u0026#34;library/\u0026#34;: true, \u0026#34;**/*.anim\u0026#34;: true, \u0026#34;**/*.meta\u0026#34;: true }, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;[typescript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[json]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; } } package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;format\u0026#34;: \u0026#34;prettier --write --cache .\u0026#34;, \u0026#34;format-check\u0026#34;: \u0026#34;prettier --check --cache .\u0026#34; }, } eslint.config.mjs import pluginJs from \u0026#39;@eslint/js\u0026#39;; import eslintConfigPrettier from \u0026#39;eslint-config-prettier\u0026#39;; import globals from \u0026#39;globals\u0026#39;; import tseslint from \u0026#39;typescript-eslint\u0026#39;; /** @type {import(\u0026#39;eslint\u0026#39;).Linter.Config[]} */ export default [ { files: [\u0026#39;**/*.{js,mjs,cjs,ts}\u0026#39;] }, { languageOptions: { globals: globals.browser } }, pluginJs.configs.recommended, ...tseslint.configs.recommended, eslintConfigPrettier, ]; .prettierrc { \u0026#34;semi\u0026#34;: true, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;printWidth\u0026#34;: 150, \u0026#34;endOfLine\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;singleAttributePerLine\u0026#34;: true, \u0026#34;vueIndentScriptAndStyle\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;ignore\u0026#34;, \u0026#34;plugins\u0026#34;: [\u0026#34;prettier-plugin-organize-imports\u0026#34;], \u0026#34;overrides\u0026#34;: [ { \u0026#34;files\u0026#34;: \u0026#34;.prettierrc\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;parser\u0026#34;: \u0026#34;json\u0026#34; } } ] } .prettierignore dist pnpm-lock.yaml CHANGELOG*.md ","permalink":"https://HoshikawaRyuukou.github.io/posts/cocos---env/","tags":["Cocos"],"title":"Cocos - Env"},{"contents":"Guide cocos creator零基础教学 Cocos-siki学院 Cocos 教學資源 Rescource awesome-CocosCreator ","permalink":"https://HoshikawaRyuukou.github.io/posts/cocos---note/","tags":["Cocos"],"title":"Cocos - Note"},{"contents":"Quick Chat 在尋求最優解法設計 既快又省 的資料結構與演算時，有以下兩個面向\n時間效率：演算法執行時間的長短。 空間效率：演算法佔用記憶體空間的大小。 Guide 第 2 章 - 复杂度分析 時間複雜度 (Time Complexity) 2.3 時間複雜度 ⚠️ 時間複雜度分析統計的不是演算法執行時間，而是演算法執行時間隨著資料量變大時的增長趨勢。\n有效評估演算法效率。 推算方法更簡便。 存在一定的侷限性(當輸入資料大小較小時)。 空間複雜度 (Space Complexity) 2.4 空間複雜度 ⚠️ 我們通常只關注最差空間複雜度。\n輸入空間：演算法的輸入資料。 暫存空間：執行過程中的變數、物件、函式上下文等資料。 輸出空間：儲存演算法的輸出資料。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/algorithm---complexity/","tags":["Algorithm"],"title":"Algorithm - Complexity"},{"contents":"Quick Chat 無狀態設計專注於系統可重現性和邏輯純淨性的設計方法。其核心設計思維旨在將邏輯從外部狀態的依賴中解放出來，使每個狀態完全由輸入決定，而非持續記錄和修改內部狀態。\nFeatures 純函數式邏輯：輸出僅依賴輸入，無副作用。 輸入驅動：狀態由輸入序列完全決定。 不可變狀態：每次改變都生成新狀態(防止副作用)，支持回溯。 可重現性：同樣的輸入序列可重現遊戲進程。 Limitations 在高度互動和即時性要求高的系統中，狀態的不可變性可能增加性能開銷。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---stateless/","tags":["Software Design","Pattern"],"title":"Software Design - Pattern - Stateless"},{"contents":"Quick Chat 這本書偏向經營管理和領導力的層面，特別是岩田聰如何作為任天堂的社長，帶領公司走向成功。雖然書中也有描述岩田聰作為程式設計師的背景，但更多的焦點放在他如何運用管理哲學和人性化領導來塑造任天堂的發展。\nReview 第一章 岩田先生成為社長以前。 展示了岩田聰如何從一名年輕的程式設計師，逐步成為一位備受尊敬的遊戲業領袖。\n引導組織發揮優勢，揚長避短，這就是經營。\n高中時代：萌芽的天賦與熱忱 靠好奇心和創造力自行探索早期計算機，嘗試開發遊戲，奠定基礎技能。 在實驗中累積對電腦的深刻理解，明白其「能與不能」。 受到讚賞後獲得正向激勵，促使他不斷進步。 大學時代：實踐中學習 積極參與程式聚會，認識志同道合的朋友。 進入 HAL 研究所 打工，正式踏足遊戲開發領域。 雖認同大學教育的價值，但認為工作所需的技能多來自實踐經驗。 HAL 開發組時期：快速成長的責任 作為 HAL 開發組的創始成員，必須負責從技術到決策的多項工作。 見證團隊從 5 人擴展到 90 人，搭上任天堂紅白機的成功浪潮。 被提拔為開發部長，承擔更大的管理責任。 HAL 社長時期 - 經營危機 在公司面臨破產時毅然接任社長，直言：「這件事由我來做最合理。」 在極限壓力下經歷人情冷暖，領悟短期迅速獲利未必是最佳解。 花一個月與全體員工進行個別面談，建立決策基準。 「做決策，就是收集，分析情報，決定事務的優先度」 「依照訂立的優先順序推行即可」 HAL 社長時期 - 以心換心 理想的公司：老闆能理解員工的公司 與 老闆認真為每個員工的幸福考慮的公司 面談第一個問題 : 你現在開心嗎? 有些話只有面對面才能說出口。 先讓對方說完，才有可能真心對話。 面談則是聊到 : 何時豁然開朗 確定雙方價值觀，盡可能解釋決策動機。 「所謂的公司，是擁有共同目標的人們各司其職、齊心協力完成目標的地方，因此最好先制定共同的目標」 「若是如此這般的背景條件，換作是你，你有何想法?」 建立信任：實際看到那個人解決問題 -\u0026gt; 相信那個人的決定 HAL 社長時期 - 轉折契機 勇敢叫停《叮噹波波》的修改，即使導致銷售部顏面掃地。 帶領團隊推出《星之卡比》，憑藉亮眼表現大獲成功，預購量達預期的 200 倍。 第二章 岩田先生的領導能力。 第三章 岩田先生的個性。 第四章 岩田先生信賴的人。 第五章 岩田先生所追求的遊戲。 第六章 別人口中的岩田先生。 宮本茂口中的岩田先生 系井重里口中的岩田先生 第七章 岩田先生這個人。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/reading---%E5%B2%A9%E7%94%B0%E8%81%B0%E5%A6%82%E6%98%AF%E8%AA%AA%E5%BE%9E%E5%A4%A9%E6%89%8D%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E5%B8%AB%E5%88%B0%E9%81%8A%E6%88%B2%E5%85%AC%E5%8F%B8%E7%A4%BE%E9%95%B7%E4%BB%BB%E5%A4%A9%E5%A0%82%E4%B8%AD%E8%88%88%E4%B9%8B%E4%B8%BB%E5%82%B3%E5%A5%87%E7%9A%84%E4%B8%80%E7%94%9F/","tags":["Reading"],"title":"Reading - 岩田聰如是說：從天才程式設計師到遊戲公司社長，任天堂中興之主傳奇的一生"},{"contents":"Quick Chat 提示工程是一種專注於設計和優化輸入提示的操作者技術，旨在不改變模型的前提下，通過精心設計提示來提升生成式人工智慧（如大型語言模型，LLMs）的輸出品質。這種技術能幫助模型更準確地理解用戶意圖並生成符合需求的回應。\n提示（Prompt）：提示是提供給 AI 模型的輸入內容，如問題、命令或指示。高品質提示是生成高品質輸出的關鍵。 Guide 提示工程(Prompt Engineering)：如何有效與AI對話 Practice - Github Copilot Domain Model 偏重邏輯，提示詞規格越詳細越好。 Vue Component 前端組件，初期提示詞規格未必越詳細越好。 建議先實現核心功能，再逐步優化。 中後期規格大幅調整，修改成功率偏低(尤其是布局相關失敗率較高)。 提供範例檔案有助於生成，例如：基於 XXX.vue 幫我寫另一個 OOO.vue 的組件。 Extras 原型階段不建議過早拆分以免降低開發效率。 基本成形後可封裝部分可以考慮重構為小單元，提升處理效率(減少重複生成相同部位)。 雖然可透過 selection 的方式局部修正，但目前讓完整上下文一起參與生成較為穩健。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---prompt-engineering/","tags":["AI"],"title":"AI - Prompt Engineering"},{"contents":"CUDA # 查找 GPU 支持的 CUDA 版本 nvidia-smi # 如果安裝了CUDA，將顯示CUDA編譯工具的版本信息 nvcc --version ","permalink":"https://HoshikawaRyuukou.github.io/posts/nvidia---note/","tags":["Nvidia","Cuda"],"title":"Nvidia - Note"},{"contents":"Quick Chat 以下是 Conventional Commit 的一些主要好處 :\n一致性：統一提交訊息格式，便於理解和閱讀。 自動化支持：助力自動生成變更日誌，並與 CI/CD 等工具無縫整合。 版本控制友好：與 Semantic Versioning 搭配良好，根據提交類型自動升級版本。 提高溝通效率：簡明的訊息格式促進團隊內溝通與代碼審查。 歷史追蹤：規範化提交便於回溯和維護，增強項目可讀性和可維護性。 Guide Conventional Commits conventional-changelog/commitlint commitizen/cz-cli Usage samples chore(deps): add dependencies chore(deps): update pnpm to v9.12.3 chore(release): 9.12.3 ci: rename audit job feat!: the link command should add overrides ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-development---conventional-commits/","tags":["Software Development"],"title":"Software Development - Conventional Commits"},{"contents":"Guide Vite | 下一代的前端工具链 Vite 是什麼? 為什麼要用 Vite? 它解決了哪些問題? 又是如何解決? 新舊時代 JS Bundler 的世代交替 - Vite vs. Webpack 的詳細比較 | Bosh 的技術探索筆記 ","permalink":"https://HoshikawaRyuukou.github.io/posts/front-end---vite---note/","tags":["Front-End","Vite"],"title":"Front-End - Vite - Note"},{"contents":"Guide changesets/action .github/workflows/publish-package.yml name: Publish package to GitHub Packages on: workflow_dispatch: release: types: [published] concurrency: ${{ github.workflow }}-${{ github.ref }} jobs: release: runs-on: ubuntu-latest steps: - name: Checkout Repo uses: actions/checkout@v4 - uses: pnpm/action-setup@v4 with: version: 9 run_install: false - uses: actions/setup-node@v4 with: node-version: \u0026#39;20.x\u0026#39; registry-url: \u0026#39;https://npm.pkg.github.com\u0026#39; scope: \u0026#39;@user-or-organization\u0026#39; - name: Install dependencies run: pnpm install - name: Build package run: pnpm build - name: Create Release Pull Request or Publish to npm id: changesets uses: changesets/action@v1 with: # This expects you to have a script called release which does a build for your packages and calls changeset publish publish: pnpm release env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} - name: Done if: steps.changesets.outputs.published == \u0026#39;true\u0026#39; # You can do something when a publish happens. run: echo \u0026#34;Done\u0026#34; ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---publish-private-packages-to-github-packages-using-changesets/","tags":["Workflow","Github","pnpm"],"title":"Workflow - Publish private packages to Github Packages using Changesets"},{"contents":"Guide 語意化版本 2.0.0 NPM Semver Calculator 定義 語意化版本號由以下三部分構成：\n主版本號 (Major)：當發生不向後相容的變更時增加。 次版本號 (Minor)：當增加向下相容的新功能時增加。 修訂號 (Patch)：當修復向下相容的問題時增加。 例如：1.2.3 中，1 是主版本號，2 是次版本號，3 是修訂號。\n預發布版本 預發布版本用於標示還不夠穩定的版本，通常是開發、測試中的版本，例如 alpha 或 beta 階段。這些標記常用於給開發者或測試者試用，在正式發布之前捕捉可能的問題。\n語法上，預發布版本會附加在主版本號、次版本號、修訂號之後，以連字號 (-) 分隔，常見的標記包括：\nalpha：表示非常早期、初步的版本，可能還不完整。 beta：表示功能已基本完成，正在進行測試和改進的版本。 rc (Release Candidate)：表示接近正式發布的候選版本，可能只需要進行少量修改。 例如：\n1.2.3-alpha：表示這是版本 1.2.3 的一個 alpha 預發布版本。 1.2.3-beta.1：表示這是版本 1.2.3 的第一個 beta 預發布版本。 1.2.3-rc.2：表示這是版本 1.2.3 的第二個候選版本。 版本範圍 (以 npm 為例) 波浪符號 (~)\n允許更新修訂號，但不更新次版本號。\n例如，~1.2.3 表示可以更新到 \u0026lt;1.3.0，允許的版本包括 1.2.4、1.2.5 等。\n插入符號 (^)\n允許更新次版本號和修訂號，但不更改主版本號（0 版本除外）。\n例如，^1.2.3 表示可以更新到 \u0026lt;2.0.0，允許的版本包括 1.3.0、1.4.5 等。\n比較符號 (\u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=)\n用於指定版本的上限或下限。\n例如，\u0026lt;2.0.0 表示可以使用比 2.0.0 更早的所有版本。\n星號 (*)\n匹配任意版本。\n例如，1.2.* 表示匹配所有 1.2.x 的版本，如 1.2.1、1.2.9 等。\n範圍符號 (-)\n指定一個範圍的版本。\n例如，1.2.3 - 2.3.4 表示所有從 1.2.3 到 2.3.4 的版本。\n或運算符 (||)\n允許多個版本範圍。\n例如，1.2.3 || 2.0.0 表示可以使用 1.2.3 或 2.0.0。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-development---semantic-versioning/","tags":["Software Development"],"title":"Software Development - Semantic Versioning"},{"contents":"DOM (Document Object Model) 是一種瀏覽器用來表示和操作 HTML 或 XML 文件的結構化方式。當一個網頁加載時，瀏覽器會將 HTML 文檔解析成 DOM 樹，然後讓開發者使用 JavaScript 等語言動態修改網頁的內容、結構和樣式。\nview size window.devicePixelRatio: 代設備的屏幕通常具有比標準顯示器更高的像素密度（1 個 CSS 像素 = 2 個物理像素）。 window.outerWidth: 瀏覽器窗口的整體寬度（包括邊框、工具欄等）。 window.innerWidth: 可見區域的寬度（包含滾動條）。 document.documentElement.clientWidth: 可見區域的寬度（不包含滾動條）。 screen.width: 屏幕(硬體)解析度的寬度（整個設備屏幕的寬度，與瀏覽器窗口大小無關）。 url window.location.search: 用於獲取 URL 中的查詢字串（query string）。查詢字串是指 ? 後面的部分，通常用來傳遞參數，例如：https://example.com/page?name=John\u0026amp;age=30 中的 ?name=John\u0026amp;age=30 ","permalink":"https://HoshikawaRyuukou.github.io/posts/front-end---html---note/","tags":["Front-End"],"title":"Front-End - Html - Note"},{"contents":"Quick Chat HackMD 的核心思想是\n輕鬆使用 Markdown 協作文件的工具\n符合的筆者的使用需求\n免費方案適合輕度用戶 跨平台兼容性（桌面/移動設備） 支援 Markdown 格式 文件管理（標籤/搜索功能） 分享控制（私人/公開） 支援遠端同步 付費方案差異\n多人協作人數 文件大小限制 版本控制 API 接入 Guide HackMD：協作 Markdown 文件，分享知識的平台 HackMD 使用教學 HackMD 快速入門教學 用 HackMD 做簡報 Slide-example ","permalink":"https://HoshikawaRyuukou.github.io/posts/hackmd---note/","tags":["HackMD"],"title":"HackMD - Note"},{"contents":"Quick Chat ExifTool 用來讀取、寫入、編輯各種檔案的 元數據（Metadata），特別是 照片、影片、音訊、PDF 等格式。\nMemo source 覆蓋 target exiftool -overwrite_original -all= target.png exiftool -tagsFromFile source.png -all:all target.png ","permalink":"https://HoshikawaRyuukou.github.io/posts/tools---exiftool---note/","tags":["Tools"],"title":"Tools - ExifTool - Note"},{"contents":"戰鬥 探讨服务端回合制战斗系统 技能 一种易扩展游戏技能系统的实现方案 如何设计技能系统 場景 樓梯是如何成為遊戲界難題的？拆解鳴潮和絕區零的解決方案 Shader 【OpenGL 篇】为什么游戏总要编译着色器？ ","permalink":"https://HoshikawaRyuukou.github.io/posts/game-design---system/","tags":["Game Design"],"title":"Game Design - System"},{"contents":"Guide Monorepo：让你的项目脱胎换骨，既能代码复用，又能独立部署！ Config Boost your productivity with TypeScript project references An actual complete guide to typescript monorepos TypeScript project references Template jkomyno/pnpm-monorepo-template bakeruk/modern-typescript-monorepo-example firxworx/fx-pnpm-monorepo-starter limuen/monorepo-project ixahmedxi/orbitkit ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-development---repository-structure---monorepo/","tags":["Software Development","monorepo"],"title":"Software Development - Repository Structure - monorepo"},{"contents":"Quick Chat rimraf 是一個用於遞迴刪除文件或目錄的 Node.js 庫，類似於 Unix 上的 rm -rf 命令。它的主要功能是跨平台刪除文件和文件夾，特別適合在 Windows 和 Unix 系統上使用。\nGuide isaacs/rimraf Rimraf详细介绍 Install pnpm add -D rimraf Usage 單個文件 pnpm rimraf file.txt 單個目錄 pnpm rimraf folder 複數目標 pnpm rimraf folder1 folder2 file.txt 匹配目標 pnpm rimraf --glob \u0026#34;./**/index.js\u0026#34; 透過 scripts command 執行 { \u0026#34;scripts\u0026#34;: { \u0026#34;clean\u0026#34;: \u0026#34;rimraf dist\u0026#34; } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---rimraf/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - rimraf"},{"contents":"Quick Chat 整合 Web Workers 與 worker_threads，因此支援瀏覽器和 Node.js。 API 設計直觀(管理工作線程、訊息傳遞和錯誤處理)。 實現 worker pool 管理功能。 支援 Promise 與 async/await。 Guide workerpool Vite Workerpool Example Other Nest.js - Worker threads 잘 사용해보기 NestJS Dependency Injection in Worker Threads https://github.com/vitest-dev/vitest/issues/5757#issuecomment-2146013141 https://github.com/nodejs/node/issues/47747 ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---workerpool/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - workerpool"},{"contents":"Quick Chat 以下範例為 :\n在 git push 後透過 Github Actions 將 tag + commit 訊息發送到指定的 Telegram 群組\n設置 Telegram Bot 在 Telegram 中搜尋 @BotFather 並建立一個新的 bot，記下 API token。 將 bot 加入群組並發送訊息給 bot 使用 https://api.telegram.org/bot\u0026lt;YourBotToken\u0026gt;/getUpdates 來獲取群組 ID。 設置 GitHub Secrets GitHub 專案中\nSettings -\u0026gt; Security -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository secrets\n新增以下 secrets :\nTELEGRAM_BOT_TOKEN : Telegram Bot Token TELEGRAM_CHAT_ID : Telegram 群組 ID 設置 GitHub Variables GitHub 專案中\nSettings -\u0026gt; Security -\u0026gt; Secrets and variables -\u0026gt; Actions -\u0026gt; Repository variables\n新增以下 variables :\nTELEGRAM_TAG : 格式為 #Word，多個 tags 用空白分割 建立 GitHub Actions Workflow .github/workflows/telegram-notify.yml name: Notify Telegram on Push on: workflow_dispatch: push: branches: - main jobs: notify: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 with: # Fetch only the last commit fetch-depth: 1 - name: Get latest commit message id: get_commit # Run a shell command to get the latest commit message and set it as an output run: echo \u0026#34;::set-output name=message::$(git log -1 --pretty=%B)\u0026#34; - name: Send notification to Telegram env: LAST_COMMIT: ${{ steps.get_commit.outputs.message }} TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }} TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }} TELEGRAM_TAG: ${{ vars.TELEGRAM_TAG }} run: | TELEGRAM_MESSAGE=\u0026#34;$TELEGRAM_TAG%0A$LAST_COMMIT\u0026#34; curl -s -X POST https://api.telegram.org/bot$TELEGRAM_TOKEN/sendMessage \\ -d chat_id=$TELEGRAM_CHAT_ID \\ -d text=\u0026#34;$TELEGRAM_MESSAGE\u0026#34; ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---send-messages-to-telegram-via-github-actions/","tags":["Workflow","git","Github","Telegram"],"title":"Workflow - Send messages to Telegram via GitHub Actions"},{"contents":"Quick Chat lint-staged 可以只對 git staged 的檔案執行 lint 處理，進而提升檢查效率。\nGuide lint-staged/lint-staged Notice ⚠️ 這裡與 simple-git-hooks 搭配使用 ⚠️ 跟 Prettier 搭配使用，必須確保 ESLint 在 Prettier 前面先執行 Install pnpm add -D lint-staged Config package.json { \u0026#34;lint-staged\u0026#34;: { \u0026#34;*.{js,json}\u0026#34;: [ \u0026#34;prettier --write\u0026#34; ], \u0026#34;*.ts?(x)\u0026#34;: [ \u0026#34;eslint --fix\u0026#34;, \u0026#34;prettier --parser=typescript --write\u0026#34; ] } } Usage pnpm lint-staged ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---lint-staged/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - lint-staged"},{"contents":"Quick Chat ESLint 是一個用來檢查和修復 JavaScript/TypeScript 程式碼風格和潛在錯誤的工具，幫助維持一致性和提高程式碼品質。它可以根據自訂規則或預設的最佳實踐規則來進行靜態分析。\nGuide eslint/eslint ESLint - Pluggable JavaScript Linter Using the New ESLint Flat Config 仕組みと嬉しさから理解するeslint FlatConfig対応 Notice ⚠️ ESLint 正逐步廢除格式化規則 - Deprecation of formatting rules。 ⚠️ 官方建議使用 Prettier 作為格式化方案。 Install pnpm create @eslint/config@latest Extension vscode extension .vscode/extension.json { \u0026#34;recommendations\u0026#34;: [\u0026#34;dbaeumer.vscode-eslint\u0026#34;] } Config eslint.config.js - 使用純 JavaScript 編寫配置，以便支持更好的導入導出。 使用一個純陣列來定義所有的規則和配置，避免了多層嵌套的問題。 後面出現的配置會覆蓋前面的配置。 eslint.config.js import pluginJs from \u0026#39;@eslint/js\u0026#39;; import tseslint from \u0026#39;typescript-eslint\u0026#39;; export default [ { name: \u0026#39;all\u0026#39;, files: [\u0026#39;**/*.{js,ts,vue}\u0026#39;], ignores: [ \u0026#39;**/node_modules/**\u0026#39;, \u0026#39;**/dist/**\u0026#39;, \u0026#39;**/coverage/**\u0026#39;, \u0026#39;**/*.min.js\u0026#39;, ], rules: { \u0026#39;no-console\u0026#39;: \u0026#39;warn\u0026#39;, \u0026#39;no-unused-vars\u0026#39;: \u0026#39;error\u0026#39;, }, }, { name: \u0026#39;frontend\u0026#39;, files: [\u0026#39;packages/app-frontend/**/*.{js,ts,vue}\u0026#39;], rules: { \u0026#39;no-debugger\u0026#39;: \u0026#39;error\u0026#39;, }, }, { name: \u0026#39;backend\u0026#39;, files: [\u0026#39;packages/app-backend/**/*.{js,ts}\u0026#39;], rules: { \u0026#39;no-console\u0026#39;: \u0026#39;off\u0026#39;, }, }, { name: \u0026#39;shared-library\u0026#39;, files: [\u0026#39;packages/shared-library/**/*.{js,ts}\u0026#39;], ignores: [\u0026#39;**/*.test.ts\u0026#39;], }, pluginJs.configs.recommended, ...tseslint.configs.recommended, ]; Extra - ESLint Config Inspector pnpx @eslint/config-inspector ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---eslint/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - ESLint"},{"contents":"Guide toplenboren/simple-git-hooks githooks Notice ⚠️ 更改命令後記得更新 git hook ⚠️ 不要添加 \u0026quot;postinstall\u0026quot;: \u0026quot;pnpx simple-git-hooks\u0026quot; 於 package.json，會影響 publish 行為 ⚠️ 個人不建議簡化 跳過 hook 行為，必須保持操作不適度 Install pnpm add -D simple-git-hooks Config package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;postinstall\u0026#34;: \u0026#34;simple-git-hooks\u0026#34; }, \u0026#34;simple-git-hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;pnpm lint-staged \u0026amp;\u0026amp; pnpm check\u0026#34;, \u0026#34;commit-msg\u0026#34;: \u0026#34;node scripts/verify-commit.js\u0026#34; } } Usage 更新 git hook pnpx simple-git-hooks 跳過 git hook - CI 這部分代補，目前沒有操作情境 doc 跳過 git hook - 三方 git client 開啟 git bash - git commit -m \u0026#34;你的 commit 訊息\u0026#34; --no-verify ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---simple-git-hooks/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - simple-git-hooks"},{"contents":"Quick Chat The simplest and fastest way to bundle your TypeScript libraries.\n設計的初衷是讓開發者能夠以最少的設定完成打包工作，內建許多合理的預設值。\nGuide egoist/tsup tsup 为什么是 tsup Dual Publishing ESM and CJS Modules with tsup and Are the Types Wrong? Install pnpm add -D tsup Config package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;tsup\u0026#34; }, } tsup.config.ts - only esm module import { defineConfig } from \u0026#39;tsup\u0026#39;; export default defineConfig({ // 指定入口文件 entry: [\u0026#39;src/index.ts\u0026#39;, \u0026#39;src/subpath/index.ts\u0026#39;, \u0026#39;src/internal/index.ts\u0026#39;], // ESM 格式 format: [\u0026#39;esm\u0026#39;], // 生成類型定義 dts: true, // 每次構建時清理輸出目錄 clean: true, }); ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---tsup/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - tsup"},{"contents":"Guide Package entry points Version selection with typesVersions Multiple exports with types in a Typescript Package 巧用 exports 和 typeVersions 提升 npm 包用户使用体验 Suggestion 以較新 Node.js 版本為目標的新包，建議使用 exports 欄位。 sample - vue/core Notice 當定義了 exports 欄位時\n⚠️ Node.js 會優先使用 exports 來決定如何載入模組，只有在 exports 中沒有相應定義時，才會使用 main、module 和 types 欄位。 ⚠️ 所有子路徑都會被封裝起來，除非明確導出，否則這些子路徑將無法供使用者訪問(會拋出一個 ERR_PACKAGE_PATH_NOT_EXPORTED 的錯誤)。 Fields main 當套件被作為 CommonJS 模組引入時，預設的入口點。\nmodule 當套件被作為 ES 模組引入時，預設的入口點。\ntypes TypeScript 的類型定義檔案位置，提供 TypeScript 支援。\nexports 用來細化和取代傳統的 main 和 module 欄位。 提高包的安全性：限制用戶可以訪問的內部文件，防止直接訪問內部未經授權的代碼。 更清晰的 API：只公開需要使用的部分代碼，簡化使用者的導入過程。 支持不同的模組格式：通過同時支持 require 和 import，可以在不同的環境中更靈活使用。 exports - Conditional Exports 目前指導出 esm 模組，未來需要雙入口再回補。\nexports - Subpath 多入口導出 { \u0026#34;name\u0026#34;: \u0026#34;my-package\u0026#34;, \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: { \u0026#34;types\u0026#34;: \u0026#34;./dist/index.d.ts\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;./dist/index.js\u0026#34; }, \u0026#34;./subpath\u0026#34;: { \u0026#34;types\u0026#34;: \u0026#34;./dist/subpath/index.d.ts\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;./dist/subpath/index.js\u0026#34; } } } 限制導出 { \u0026#34;name\u0026#34;: \u0026#34;my-package\u0026#34;, \u0026#34;exports\u0026#34;: { \u0026#34;./subpath/internal/*\u0026#34;: null } } Extras - 偷懶作法 (較不推薦) ⚠️ 利用 typeVersions 導引型別位置，但這偏離了 typeVersions 的原始用途(依據 TypeScript 版本的差異來區分型別檔案)。 { \u0026#34;exports\u0026#34;: { \u0026#34;./*\u0026#34;: \u0026#34;./dist/*.js\u0026#34; }, \u0026#34;typesVersions\u0026#34;: { \u0026#34;*\u0026#34;: { \u0026#34;*\u0026#34;: [ \u0026#34;./dist/*\u0026#34; ] } } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/node.js---package.json---export/","tags":["Node.js","npm"],"title":"Node.js - package.json - Export"},{"contents":"Guide pnpm 为什么现在我更推荐 pnpm 而不是 npm/yarn? pnpm、npm、yarn 包管理工具『优劣对比』及『环境迁移』 从pnpm工具了解整个npm包核心管理原理 為什麼 pnpm 比 npm 更快且更省空間？ pnpm实战教程 Install 全域安裝 npm install -g pnpm 環境配置 - Windows ⚠️ 使用 PowerShell 系統管理員 Get-ExecutionPolicy # 如果為 Restricted 則繼續進行 Set-ExecutionPolicy RemoteSigned Commands pnpm 本體 pnpm self-update : 將 pnpm 更新到最新版本。(建議重啟 ide) Node.js 的執行環境 pnpm env use \u0026ndash;global lts : 安裝並使用 LTS 版本 pnpm env use \u0026ndash;global {version} : 安裝並使用指定版本 pnpm env add \u0026ndash;global {version} : 僅安裝指定版本 pnpm env remove \u0026ndash;global {version} : 移除指定版本 pnpm env list \u0026ndash;remote : 列出線上可用的版本 packages pnpm add \u0026lt;pkg\u0026gt; : 添加依賴 pnpm remove \u0026lt;pkg\u0026gt; : 移除依賴 pnpm install : 安裝所有依賴 pnpm update : 在 package.json 限制的版本範圍內更新所有依賴 pnpm update \u0026ndash;latest : 強更新所有依賴至最新 pnpm outdated : 檢查套件是否有更新 pnpm store prune : 會清理掉不再被專案引用的包 pnpm run \u0026lt;commnad\u0026gt; : 執行命令 (run 基本) workspace -w : 為工作區參數 -wD : 組合使用 - 工作區依賴 \u0026ndash;filter \u0026lt;package_selector\u0026gt;: 對指定 package 操作 ","permalink":"https://HoshikawaRyuukou.github.io/posts/node.js---package-manager---pnpm/","tags":["Node.js","pnpm"],"title":"Node.js - Package Manager - pnpm"},{"contents":"Quick Chat 當目錄中出現了 tsconfig.json 文件，則表示該目錄是 TypeScript 專案的根目錄。tsconfig.json 檔案指定了編譯專案所需的根目錄下的檔案以及編譯選項。實務上在不同的開發情境中，準備不同的 tsconfig.json 是非常有必要的。\n開發環境中，可能希望啟用更多的錯誤檢查和調試資訊，以便更快地發現問題。 生產環境中，則可能希望關閉這些額外的檢查，以提升編譯速度並減少輸出檔案大小。 呼叫 tsc 時使用 --project 或 -p 選項來指定相應的配置檔案。\ntsc -p tsconfig.build.json Guide tsconfig.json 是什麼 TSConfig Reference tsc性能优化 \u0026ndash; Project References 基底 tsconfig Node 20 推薦的 tsconfig.json\n@tsconfig/node20 npm install -D @tsconfig/node20 可以繼承基底 tsconfig 並覆寫參數\n{ \u0026#34;extends\u0026#34;: \u0026#34;@tsconfig/node20/tsconfig.json\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;preserveConstEnums\u0026#34;: true }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*\u0026#34;], \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;**/*.spec.ts\u0026#34;] } 型別導出 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;declaration\u0026#34;: true, \u0026#34;declarationMap\u0026#34;: true, \u0026#34;emitDeclarationOnly\u0026#34;: true, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, }, \u0026#34;exclude\u0026#34;: [\u0026#34;tests/**/*\u0026#34;], \u0026#34;include\u0026#34;: [\u0026#34;src/**/*\u0026#34;] } declaration：是否生成對應的 .d.ts 檔案，用來描述編譯後的 JavaScript 的型別資訊。 declarationMap：會為 .d.ts 檔案生成對應的 .d.ts.map 檔案，使得編譯後的型別定義可以追溯到原始 TypeScript 代碼。 emitDeclarationOnly：TypeScript 只會生成 .d.ts 型別檔案，不會生成對應的 JavaScript 檔案。 outDir：指定了編譯器應該將生成的 JavaScript 和型別定義檔案輸出到的目錄。 exclude/include：控制哪些檔案會被包含在編譯過程中。這會間接影響型別的導出，因為只有被包含的檔案才會生成 .d.ts 型別定義檔。 Monorepo { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;incremental\u0026#34;: true, \u0026#34;composite\u0026#34;: true } } incremental 用於加速 TypeScript 的編譯過程，特別是當代碼庫很大或涉及多個子項目時。\n增量編譯：啟用後，TypeScript 會在編譯過程中生成 .tsbuildinfo 文件，該文件包含了上次編譯的狀態和信息。當進行下一次編譯時，TypeScript 只會編譯那些自上次編譯以來發生變化的文件，從而大幅縮短編譯時間。 composite 主要用於多個 TypeScript 項目之間的依賴管理，特別是在 monorepo 結構中，這個選項是開啟增量編譯和項目參考的前提\n強制啟用的檢查：啟用後，TypeScript 會強制檢查並要求一些配置：\nrootDir 和 outDir 必須明確設置。 必須有至少一個 tsconfig.json 中的文件包含在項目中（防止空的配置）。 生成中間構建文件：啟用 composite 後，TypeScript 會生成中間構建文件（如 .d.ts 文件和 .tsbuildinfo 文件），這些文件可以被其他依賴它的項目直接使用，避免重複編譯整個項目。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---typescript---tsconfig.json/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - TypeScript - tsconfig.json"},{"contents":"Structure project-root/ ├── pnpm-workspace.yaml ├── scripts/ ├── apps/ | ├── cli/ | ├── web/ (vue) | └── desktop/ (electron) └── packages/ ├── pkg01/ └── pkg02/ scripts 全域工作區命令。 apps 每個子資料夾代表一個最終的應用場景(終端)。 packages 專注於封裝和共享具體的功能模組，為各個終端應用提供支援。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---create-a-template-for-full-stack-monorepo/","tags":["Workflow","Template"],"title":"Workflow - Create a template for full-stack monorepo"},{"contents":"Quick Chat Electron 是一個使用 JavaScript、HTML 和 CSS + Native Api 做相容多個系統（Windows、Linux、Mac）的桌面應用程式構建框架 —— 不需要本地開發經驗。\nGuide Build cross-platform desktop apps with JavaScript, HTML, and CSS | Electron electron-builder Electron学习指引 awesome-electron awesome-electron-alternatives Suggestion 🤓 強烈建議第一次接觸 Electron 的開發者實際走一次官方 quick-start，會對 Electron 的本質有更純粹的認識。\nelectron/electron-quick-start 再逐步的嘗試以下機制 :\n用 BrowserWindow 再額外創建一個窗口。 用 ipcMain/ipcRenderer 來達到進程間交互。 Notice ⚠️ Electron 中的 ES 模塊 (ESM) 並未 100% 支援 ","permalink":"https://HoshikawaRyuukou.github.io/posts/electron---note/","tags":["Electron"],"title":"Electron - Note"},{"contents":"Guide Monorepo与pnpm：前端项目管理的完美搭档 为什么 pnpm+monorepo 是组件库项目的最佳实践 Monorepo？來聊聊另一種專案管理架構吧！ 从npm版本依赖到Monorepo大仓项目 MonoRepo实战：pnpm+nx搭建MonoRepo项目 Create a monorepo using PNPM workspace 从构建到发布：Monorepo 的最佳实践 TSTemplateMonorepo pnpm monorepo 搭建工具库 專案基本結構 project-root/ # 專案根目錄 ├── pnpm-workspace.yaml # pnpm 的工作區配置文件，用來定義哪些資料夾屬於工作區範圍 ├── package.json # 專案的全局配置文件，通常包括依賴、腳本和項目元數據 └── packages/ # 所有子包的資料夾，存放具體的子項目 ├── pkg01/ # 子包01，包含它自己的 package.json 文件和代碼 └── pkg02/ # 子包02，與 pkg01 結構相似，也擁有自己的 package.json 和代碼 新增 專案內全局配置 ./package.json # 產生一個基本的 package.json pnpm init monorepo 的全局 package.json 設置 \u0026quot;private\u0026quot;: true { \u0026#34;private\u0026#34;: true, } 新增 工作區配置文件 ./pnpm-workspace.yaml 該檔案聲明這是一個 Monorepo 專案。 pnpm install 自動安裝所有 package 的相依套件。 packages 字段列出了工作區包含的 package 位置。 工作區下的 package 會有各自的 package.json。 packages: - \u0026#39;packages/*\u0026#39; Extra - 在專案中限用 pnpm ⚠️ 但目前 npm hook - preinstall 未如預期運作。\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;preinstall\u0026#34;: \u0026#34;npx only-allow pnpm\u0026#34; } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---create-a-monorepo-with-pnpm-workspace/","tags":["Workflow","Node.js","pnpm","Monorepo"],"title":"Workflow - Create a monorepo with pnpm workspace"},{"contents":"Guide ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---optimize-a-monorepo-with-pnpm-and-turborepo/","tags":["Workflow","Node.js","pnpm","Monorepo"],"title":"Workflow - Optimize a monorepo with pnpm and Turborepo"},{"contents":"Steps 切換到 github 用戶號 (不是組織號) Settings/Developer Settings Personal access tokens (classic) 僅啟用 read:packagesDownload packages from GitHub Package Registry To-do 改用更推薦的 Fine-grained personal access tokens ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---generate-a-github-packages-access-token/","tags":["Workflow","Github"],"title":"Workflow - Generate a Github Packages Access Token"},{"contents":"Requirement ⚠️ 向 github 組織索取訪問用的 token ⚠️ 本範例使用 npm，之後會轉使用 pnpm Window 環境變數設置 token setx GITHUB_TOKEN ghp_xxxxxxxxxxxxxxxxxxxxxxxx ⚠️ 設置後必要時重啟終端機以確保環境變數被應用 初始化 project cd project-directory npm init -y 新增 ./.npmrc ⚠️ 這裡的第二行註解是正規寫法，有特殊用途 @xxx:registry=https://npm.pkg.github.com //npm.pkg.github.com/:_authToken=\u0026#34;${GITHUB_TOKEN}\u0026#34; 安裝 package npm install @ooxx/xxx ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---install-a-private-npm-package-from-github-packages/","tags":["Workflow","Github","Node.js"],"title":"Workflow - Install a private npm package from Github Packages"},{"contents":"Guide Publishing a Private Package on GitHub Packages 发布 Node.js 包 Notice ⚠️ 請先確保 repository 與 package 以配置為 private。 ⚠️ 本範例使用 pnpm。 package.json 的必要配置 { \u0026#34;name\u0026#34;: \u0026#34;@user-or-organization/package-name\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;repository\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/user-or-organization/package-name.git\u0026#34; }, \u0026#34;publishConfig\u0026#34;: { \u0026#34;registry\u0026#34;: \u0026#34;https://npm.pkg.github.com/\u0026#34; } } .github/workflows/publish-package.yml name: Publish package to GitHub Packages on: workflow_dispatch: release: types: [published] jobs: build: runs-on: ubuntu-latest permissions: contents: read packages: write steps: - uses: actions/checkout@v4 - uses: pnpm/action-setup@v4 with: version: 9 run_install: false - uses: actions/setup-node@v4 with: node-version: \u0026#39;20.x\u0026#39; registry-url: \u0026#39;https://npm.pkg.github.com\u0026#39; scope: \u0026#39;@user-or-organization\u0026#39; - name: Install dependencies run: pnpm install - name: Build package run: pnpm build - name: Publish package run: pnpm publish --access restricted env: NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }} ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---publish-a-private-package-to-github-packages/","tags":["Workflow","Github","pnpm"],"title":"Workflow - Publish a private package to Github Packages"},{"contents":"Quick Chat (⚠️ 實驗中) 當一個要開發一個同時支援 網頁端 與 桌面端 的應用時，該如何設計。以下範例說明使用\nUIFramework : Vue3 Desktop Framework : Electron Architecture project-root/ │ ├── core/ # 核心業務邏輯 │ ├── services/ # 服務層，包含業務邏輯 (e.g., FileManager) │ ├── models/ # 共享的資料模型和接口 │ └── interfaces/ # 定義服務的接口 (e.g., IFileService) │ ├── presentation/ # UI 表現層 (Vue3 應用) │ ├── components/ # Vue 組件 │ ├── views/ # Vue 頁面 │ ├── stores/ # Pinia 狀態管理 │ └── App.vue # Vue 入口文件 │ ├── web/ # 瀏覽器端特定實現 │ ├── services/ # 瀏覽器環境下的文件操作等服務實現 (e.g., BrowserFileService) │ ├── index.html # 網頁版的入口 │ └── main.js # 網頁版的啟動點，將核心業務注入 Vue │ ├── desktop/ # Electron 桌面端特定實現 │ ├── main/ # 主進程相關文件 │ │ ├── main.js # Electron 主進程入口 │ │ └── preload.js # 預加載腳本，用於將 Node API 注入到渲染進程 │ └── renderer.js # 渲染進程啟動點，將核心業務注入 Vue │ └── package.json # 項目配置文件 Thought 主體思想是基於 Clean Architecture，Clean Architecture 主張將業務邏輯與框架、UI 和其他技術細節分離，使得核心業務邏輯不依賴於特定的運行環境或框架。\n分層設計：核心業務邏輯（core）與表現層（presentation）分離，並由不同運行環境（web 和 desktop）提供具體的服務實現，這樣可以保持應用的可擴展性和靈活性。\npresentation 層無需關心環境：presentation 層（Vue 3）只負責展示和用戶交互，不關心具體業務邏輯的實現細節。通過 inject 使用注入的依賴，確保組件的可重用性。\n環境隔離：這種設計方式讓 web 和 desktop 各自維護自己的啟動邏輯和業務實現，從而保持清晰的架構分離。\nExtra - 映射 Vue 3 開發網頁：你可以繼續使用 Vue 3 和其他前端技術來開發你的應用，就像開發一個標準的網頁一樣。\nElectron vs 瀏覽器：把 Electron 視為桌面上的瀏覽器。它加載你的 Vue 3 應用，並提供 Node.js API，這就像瀏覽器提供的 Web API（例如 fetch、localStorage）一樣，只不過 Electron 提供的是桌面端相關的 API（例如文件系統操作、系統通知等）。\nNode API vs Web API：Node.js API 在 Electron 中充當桌面端的「操作系統層 API」，可以做很多網頁端無法做到的事情，例如文件讀取、進程控制等。而在網頁端，使用的是 Web API，例如 fetch、localStorage 等進行網頁內的操作。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---architecture---web--desktop-app/","tags":["Software Design","Architecture"],"title":"Software Design - Architecture - Web \u0026 Desktop app"},{"contents":"箱庭工作室 (Miniature Garden Studio) 這是筆者的工作室名。\n核心思想 每個應用程式都是一個精心構築的 箱庭/微型世界，在有限的環境中創造豐富且深度的體驗，讓使用者能夠沉浸其中。\n現實中的箱庭 箱庭（はこにわ，Hakoniwa），它是一種縮小版的庭園或景觀模型。這個概念源於日本，最早用來指代傳統日式庭園的迷你模型，但後來這個詞的應用範圍擴展到了各種縮小版的自然景觀創作。\n遊戲中的箱庭 箱庭設計在遊戲中已成為一種經典理念。\nIGN小课堂#49：箱庭 从沙盒和开放世界谈起，说说日本的箱庭设计理念 ","permalink":"https://HoshikawaRyuukou.github.io/posts/profile---studio/","tags":["Profile"],"title":"Profile - Studio"},{"contents":"假議題（pseudo-problem） 領域 非形式邏輯 謬誤學 簡述 \u0026ldquo;假議題\u0026rdquo; 是一種表面上看起來像是重要或值得討論的問題，但實際上並 不具有實質意義或無法帶來真正的解決 方案。這類議題通常會引導人們將精力和資源集中在並不重要或無法解決的事情上，從而忽視了真正需要關注的問題。\n特點：\n錯誤的前提：假議題常常基於錯誤或不正確的前提來構建，問題本身可能從一開始就沒有存在的必要性。 分散注意力：討論假議題可能會轉移人們對真正問題的注意，這樣的討論往往無法帶來實際的改變或有效的解決方案。 無解的爭論：假議題可能導致無休止的爭論，因為其核心問題本質上是無法解決的，或者答案根本不重要。 情境 技術討論中，有時某些看似關鍵的技術細節被過度強調，但實際上並不影響整體系統的效能或成效，這樣的爭論也可以被視為一種假議題。 討論「天使的性別是什麼？」這樣的問題，在哲學或神學中可能被認為是一個「假議題」，因為它無法被證實或否認，也沒有實際意義。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/logic---pseudo-problem/","tags":["Logic","Fallacy"],"title":"Logic - Pseudo-Problem"},{"contents":"攻擊稻草人（Straw man） 領域 非形式邏輯 謬誤學 簡述 「攻擊稻草人」（Strawman Fallacy）是一種邏輯謬誤，指的是 \u0026ldquo;故意曲解或誇大\u0026rdquo; 對方的論點，然後對這個被扭曲的論點進行反駁。這樣的辯論手法無法真正解決問題，因為它回避了對方的實際觀點，而是製造一個更容易攻擊的「稻草人」來取代對方的真實立場。\n這種謬誤在辯論中常見，特別是在政治或社會爭論中。避免這種謬誤的關鍵是要正確理解並直接回應對方的真實論點，而不是創造一個虛假的版本。\n情境 A: 「我們應該更多地投資於環保技術。」 B: 「他們想要讓我們放棄所有的經濟發展，回到石器時代！」 B 曲解了 A 的立場，然後攻擊這個扭曲的立場，而不是 A 的實際觀點。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/logic---straw-man/","tags":["Logic","Fallacy"],"title":"Logic - Straw man"},{"contents":"Step 1: 準備一個 Vite + Vue3 專案 使用 vite 指令創建空專案\npnpm create vite vve cd vve pnpm install pnpm dev Step 2: 配置 Electron 添加依賴 pnpm add -D electron pnpm add -D electron-builder pnpm add -D vite-plugin-electron pnpm add -D vite-plugin-electron-renderer 新增 ./electron/electron-env.d.ts declare namespace NodeJS { interface ProcessEnv { /** * The built directory structure * * ```tree * ├─┬─┬ dist * │ │ └── index.html * │ │ * │ ├─┬ dist-electron * │ │ ├── main.js * │ │ └── preload.js * │ * ``` */ APP_ROOT: string; VITE_PUBLIC: string; } } // Used in Renderer process, expose in `preload.ts` interface Window { ipcRenderer: import(\u0026#39;electron\u0026#39;).IpcRenderer; } 新增 ./electron/main.ts import { app, BrowserWindow } from \u0026#34;electron\u0026#34;; import { fileURLToPath } from \u0026#34;node:url\u0026#34;; import path from \u0026#34;node:path\u0026#34;; const __dirname = path.dirname(fileURLToPath(import.meta.url)); // The built directory structure // // ├─┬─┬ dist // │ │ └── index.html // │ │ // │ ├─┬ dist-electron // │ │ ├── main.js // │ │ └── preload.mjs // │ process.env.APP_ROOT = path.join(__dirname, \u0026#34;..\u0026#34;); // 🚧 Use [\u0026#39;ENV_NAME\u0026#39;] avoid vite:define plugin - Vite@2.x export const VITE_DEV_SERVER_URL = process.env[\u0026#34;VITE_DEV_SERVER_URL\u0026#34;]; export const MAIN_DIST = path.join(process.env.APP_ROOT, \u0026#34;dist-electron\u0026#34;); export const RENDERER_DIST = path.join(process.env.APP_ROOT, \u0026#34;dist\u0026#34;); process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path.join(process.env.APP_ROOT, \u0026#34;public\u0026#34;) : RENDERER_DIST; let win: BrowserWindow | null; function createWindow() { win = new BrowserWindow({ icon: path.join(process.env.VITE_PUBLIC, \u0026#34;electron-vite.svg\u0026#34;), webPreferences: { preload: path.join(__dirname, \u0026#34;preload.mjs\u0026#34;), }, }); // Test active push message to Renderer-process. win.webContents.on(\u0026#34;did-finish-load\u0026#34;, () =\u0026gt; { win?.webContents.send(\u0026#34;main-process-message\u0026#34;, new Date().toLocaleString()); }); if (VITE_DEV_SERVER_URL) { win.loadURL(VITE_DEV_SERVER_URL); } else { // win.loadFile(\u0026#39;dist/index.html\u0026#39;) win.loadFile(path.join(RENDERER_DIST, \u0026#34;index.html\u0026#34;)); } } // Quit when all windows are closed, except on macOS. There, it\u0026#39;s common // for applications and their menu bar to stay active until the user quits // explicitly with Cmd + Q. app.on(\u0026#34;window-all-closed\u0026#34;, () =\u0026gt; { if (process.platform !== \u0026#34;darwin\u0026#34;) { app.quit(); win = null; } }); app.on(\u0026#34;activate\u0026#34;, () =\u0026gt; { // On OS X it\u0026#39;s common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (BrowserWindow.getAllWindows().length === 0) { createWindow(); } }); app.whenReady().then(createWindow); 新增 ./electron/preload.ts import { ipcRenderer, contextBridge } from \u0026#39;electron\u0026#39; // --------- Expose some API to the Renderer process --------- contextBridge.exposeInMainWorld(\u0026#39;ipcRenderer\u0026#39;, { on(...args: Parameters\u0026lt;typeof ipcRenderer.on\u0026gt;) { const [channel, listener] = args return ipcRenderer.on(channel, (event, ...args) =\u0026gt; listener(event, ...args)) }, off(...args: Parameters\u0026lt;typeof ipcRenderer.off\u0026gt;) { const [channel, ...omit] = args return ipcRenderer.off(channel, ...omit) }, send(...args: Parameters\u0026lt;typeof ipcRenderer.send\u0026gt;) { const [channel, ...omit] = args return ipcRenderer.send(channel, ...omit) }, invoke(...args: Parameters\u0026lt;typeof ipcRenderer.invoke\u0026gt;) { const [channel, ...omit] = args return ipcRenderer.invoke(channel, ...omit) }, // You can expose other APTs you need here. // ... }) 修改 tsconfig.app.json { \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;, \u0026#34;src/**/*.vue\u0026#34;, \u0026#34;electron/**/*.ts\u0026#34;] } 修改 package.json { \u0026#34;main\u0026#34;: \u0026#34;dist-electron/main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build \u0026amp;\u0026amp; electron-builder\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; } } 新增 ./electron-builder.json5 { $schema: \u0026#39;https://raw.githubusercontent.com/electron-userland/electron-builder/master/packages/app-builder-lib/scheme.json\u0026#39;, appId: \u0026#39;YourAppID\u0026#39;, asar: true, productName: \u0026#39;YourAppName\u0026#39;, publish: null, directories: { output: \u0026#39;release/${version}\u0026#39;, }, files: [\u0026#39;dist\u0026#39;, \u0026#39;dist-electron\u0026#39;], mac: { target: [\u0026#39;dmg\u0026#39;], artifactName: \u0026#39;${productName}-Mac-${version}-Installer.${ext}\u0026#39;, }, win: { artifactName: \u0026#39;${productName}-Windows-${version}-Setup.${ext}\u0026#39;, target: [ { target: \u0026#39;dir\u0026#39;, arch: [\u0026#39;x64\u0026#39;], }, // { // target: \u0026#39;nsis\u0026#39;, // arch: [\u0026#39;x64\u0026#39;], // }, // { // target: \u0026#39;portable\u0026#39;, // arch: [\u0026#39;x64\u0026#39;], // }, // { // target: \u0026#39;zip\u0026#39;, // arch: [\u0026#39;x64\u0026#39;], // }, ], }, // nsis: { // oneClick: false, // perMachine: false, // allowToChangeInstallationDirectory: true, // deleteAppDataOnUninstall: true, // }, linux: { target: [\u0026#39;AppImage\u0026#39;], artifactName: \u0026#39;${productName}-Linux-${version}.${ext}\u0026#39;, }, } ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---vite-+-vue3-+-electron/","tags":["Workflow","Vite","Vue","Electron"],"title":"Workflow - Vite + Vue3 + Electron"},{"contents":"Context - 將現有的前端專案包裝成桌面端應用 情境： 已有一個完整的前端專案，但由於一些特定需求（例如離線操作的能力），決定將其包裝成桌面端應用。本質上，這個應用仍是一個網頁應用，因此基本上不會有額外的桌面端互動需求，也不需要特別增強和操作系統的整合。\n目的： 主要為了滿足離線存取與更佳的用戶體驗，但不需要深度的桌面端特性。\n技術重點： 專注於如何將現有的 Web 應用以 Electron 進行包裝，保持與原生前端相同的開發流程，並且避免過多改動。\n限制： 盡量維持輕量化，減少與桌面平台的耦合，僅利用 Electron 提供的框架和包裝功能。\nContext - 基於前端技術開發桌面端應用 情境： 目標是開發桌面端應用，只是基於前端技術來實現。這意味著應用程式將包含一些桌面應用所特有的特性，例如系統通知、檔案系統操作、離線儲存等。\n目的： 充分利用 Electron 提供的 API 來增強桌面應用的功能，使其可以提供超越單純網頁應用的體驗。\n技術重點： 基於前端技術棧（如 Vue、React 等），但需要使用 Electron 來實現與桌面系統的交互，包括檔案存取、系統托盤等。\n設計考量： 需要兼顧應用的桌面特性與前端開發的靈活性，保證兩者間的有效融合。\nContext - Electron 與 前端技術 僅是實作細節 情境： 設計理念以業務需求為核心，Electron 以及前端技術只是達成目標的手段和細節。\n業務為中心的設計： 設計時不局限於技術選型，而是先分析業務需求，再根據需求選擇最佳的技術方案。最終選擇的技術（Electron、前端技術）只是為了實現業務需求的手段。\n基於 Clean Architecture： 使用乾淨架構來分離業務邏輯與實作細節，確保應用程式具有良好的可擴展性與可維護性。Electron 與前端技術被隔離在具體的實作層，任何一方都可以被替換而不影響業務邏輯。\n技術重點： 強調框架的選擇與使用不應該影響到核心業務邏輯，業務邏輯應獨立於 UI、技術框架的變更，專注於系統的彈性與維護性。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/electron---design-context/","tags":["Electron","Software Design","Architecture"],"title":"Electron - Design Context"},{"contents":"Corporate culture QualiArtsのUnity開発を支える基盤の紹介 ","permalink":"https://HoshikawaRyuukou.github.io/posts/organization---note/","tags":["organization"],"title":"Organization - Note"},{"contents":"Skill 從已安裝 app 抽取出 apk How to Extract, Save and Share an APK of an Android Application 使用內建的 Files 應用並選擇分享 app 即可 ","permalink":"https://HoshikawaRyuukou.github.io/posts/android---note/","tags":["Android"],"title":"Android - Note"},{"contents":"錨定效應（Anchoring Effect） 領域 心理學 行為經濟學 簡敘 錨定效應是一種認知偏誤，指的是人們在做決策時，過度依賴於最先獲得的資訊（即「錨」），即便該資訊與後續的選擇或結論無直接相關。這個初始資訊會對後續的判斷產生重大影響。\n情境 例如，當你在購物時，看到某件商品的原價是 $500，但打折後是 $300，你會覺得這個折扣很吸引人，因為「500」這個數字成為了你的「錨」。即便這件商品實際價值可能是 $300 或更低，你仍然會覺得它比原價便宜很多。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/phenomena---anchoring-effect/","tags":["Phenomena","Psychology","Economics"],"title":"Phenomena - Anchoring Effect"},{"contents":"Process Electron 的進程機制主要由兩個部分組成：主進程(Main Process) 和 渲染進程(Renderer Process)。\n主進程 (Main Process) 每個 Electron 應用僅有一個主進程。 主進程負責創建應用的主窗口，並管理應用的生命周期。 主進程的權限非常高，它可以調用 Node.js 提供的所有 API，也可以與操作系統進行交互(例如：檔案系統操作、創建子進程、打開原生對話框) 。 主進程負責創建和管理應用中的所有窗口(BrowserWindow) ，並能夠與渲染進程進行通信。 渲染進程 (Renderer Process) 每個應用窗口都是一個獨立的渲染進程，負責渲染網頁內容(HTML、CSS、JavaScript) 。 渲染進程本質上是運行在 Chromium 引擎中的網頁環境，它擁有與一般瀏覽器類似的行為和限制。 渲染進程的權限較低，為了安全起見，它無法直接訪問 Node.js 的全部 API，但可以通過 Electron 的 contextBridge 和 ipcRenderer 與主進程通信。 渲染進程可以使用 Electron 提供的 preload 腳本，將一些 Node.js 模組或功能暴露給網頁。 進程間通信 (Inter-Process Communication, IPC) 主進程和渲染進程之間使用 IPC 進行數據傳遞。 渲染進程使用 ipcRenderer 發送消息給主進程，而主進程使用 ipcMain 接收和回應這些消息。反之，主進程也可以向渲染進程發送消息。 Electron 提供的 contextBridge 和 preload 腳本讓渲染進程能安全地與主進程進行通信，避免直接暴露過多的 Node.js API，從而提高應用的安全性。 Module app 主進程模組，用來控制整個應用的生命周期。它包含了一系列的事件和方法，用於管理應用的初始化、運行、退出等流程。 BrowserWindow 主進程模組，用來創建和管理應用窗口的模組。 每個 BrowserWindow 實例代表一個獨立的瀏覽器窗口，並且運行在自己的渲染進程中。 ipcMain 主進程模組，用來處理進程間通信的模組。 ipcRenderer 渲染進程模組，用來處理進程間通信的模組， 不要直接在網頁中使用 ipcRenderer，而是通過 preload 腳本中的 contextBridge 暴露安全的 API 給渲染進程。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/electron---basics/","tags":["Electron"],"title":"Electron - Basics"},{"contents":"Guide vite - 部署静态站点 [vite] 將 Vite 專案部署至 Github Pages vue3项目部署到Github 配置 - 基本 vite.config.js export default defineConfig({ base: \u0026#39;/{repo name}}/\u0026#39;, }); 配置 - SPA 如果是單頁應用（SPA）路由需做以下配置。\nvite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39;; export default defineConfig({ base: \u0026#39;/你的倉庫名稱/\u0026#39;, // 替換為你的 GitHub 倉庫名稱 }); index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;/mgproject-track-logic-game/\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; Vue Router import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39;; const router = createRouter({ history: createWebHistory(\u0026#39;/你的倉庫名稱/\u0026#39;), }); 本地測試 pnpm build pnpm preview 部屬 方式 1 - 使用 gh-pages 套件 安裝套件 pnpm add -D gh-pages 於 package.json 編寫命令 { \u0026#34;scripts\u0026#34;: { \u0026#34;deploy2ghpages\u0026#34;: \u0026#34;gh-pages -d dist\u0026#34; }, } 執行命令 pnpm deploy2ghpages 方式 2 - 使用 github actions 編寫 .github\\workflows\\gh-pages.yml # 將靜態內容部署到 GitHub Pages 的簡易工作流程 name: Deploy static content to Pages on: # 僅在推送到默認分支時運行。 push: branches: [\u0026#39;main\u0026#39;] # 這個選項可以使你手動在 Action tab 頁面觸發工作流 workflow_dispatch: # 設置 GITHUB_TOKEN 的權限，以允許部署到 GitHub Pages。 permissions: contents: read pages: write id-token: write # 允許一個併發的部署 concurrency: group: \u0026#39;pages\u0026#39; cancel-in-progress: true jobs: # 單次部署的工作描述 deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Set up pnpm uses: pnpm/action-setup@v4 with: version: 9 - name: Set up Node uses: actions/setup-node@v4 with: node-version: 20 cache: \u0026#39;pnpm\u0026#39; - name: Install dependencies run: pnpm install - name: Build run: pnpm run build - name: Setup Pages uses: actions/configure-pages@v4 - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: # Upload dist folder path: \u0026#39;./dist\u0026#39; - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 ","permalink":"https://HoshikawaRyuukou.github.io/posts/workflow---deploy-a-website-vite-+-vue3-to-github-pages/","tags":["Workflow","Vite","Vue","Github"],"title":"Workflow - Deploy a website (Vite + Vue3) to Github Pages"},{"contents":"使用馬可夫鏈來控制波動性 定義狀態 每個狀態代表玩家一次 spin 後的結果。根據遊戲中的贏獎情況將這些狀態定義為:\nNo Win (無贏) Small Win (小獎) Medium Win (中獎) Big Win (大獎) Free Game (免費遊戲) 設計轉換矩陣 Current State \\ Next State No Win Small Win Medium Win Big Win Free Game No Win 0.70 0.20 0.05 0.03 0.02 Small Win 0.50 0.30 0.10 0.05 0.05 Medium Win 0.60 0.20 0.10 0.05 0.05 Big Win 0.80 0.10 0.05 0.03 0.02 Free Game 0.50 0.25 0.10 0.10 0.05 調整波動性 要調整遊戲的波動性，可以對轉換矩陣進行修改：\n高波動性：增加從 No Win 到 Big Win 或 Free Game 的轉換機率，但也要同時增加從 Big Win 回到 No Win 的機率。 低波動性：減少極端贏獎的概率，讓玩家經常小贏或中贏，而大獎發生的頻率很低。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/slot-design---math-model/","tags":["Slot Design"],"title":"Slot Design - Math Model"},{"contents":"Quick Chat Prettier 是一個代碼格式化工具，用於保持代碼風格一致。\nGuide Prettier · Opinionated Code Formatter playground 如何配置 prettier Notice ⚠️ 跨平台協同的結尾符問題 [eslint] Delete CR eslint(prettier/prettier) issue 令人困擾的git autocrlf – Opass Life Install pnpm add -D prettier Extension vscode extension .vscode/extension.json { \u0026#34;recommendations\u0026#34;: [\u0026#34;esbenp.prettier-vscode\u0026#34;] } .vscode/setting.json { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;[typescript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[json]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; } } Plugin prettier-plugin-organize-imports : 排序/合併/移除未使用的 import 聲明 Integration - ESlint eslint-config-prettier ESLint 配置，用於關閉與 Prettier 產生衝突。 eslint-config-prettier - eslint.config.js (flat config) Config .prettierrc : Configuration File · Prettier .prettierignore : Ignoring Code · Prettier package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;format\u0026#34;: \u0026#34;prettier --write --cache .\u0026#34;, \u0026#34;format-check\u0026#34;: \u0026#34;prettier --check --cache .\u0026#34; } } .prettierrc { \u0026#34;semi\u0026#34;: true, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;printWidth\u0026#34;: 150, \u0026#34;endOfLine\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;singleAttributePerLine\u0026#34;: true, \u0026#34;vueIndentScriptAndStyle\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;ignore\u0026#34;, \u0026#34;plugins\u0026#34;: [\u0026#34;prettier-plugin-organize-imports\u0026#34;], \u0026#34;overrides\u0026#34;: [ { \u0026#34;files\u0026#34;: \u0026#34;.prettierrc\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;parser\u0026#34;: \u0026#34;json\u0026#34; } } ] } .prettierignore dist pnpm-lock.yaml CHANGELOG*.md eslint.config.js import eslintConfigPrettier from \u0026#39;eslint-config-prettier\u0026#39;; export default [ eslintConfigPrettier, ]; ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---prettier/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - Prettier"},{"contents":"Personality 免費性格測試、性格類型描述、人際關係和職業建議 | 16Personalities Human Nature 跟沒錢的人打交道，直接告訴他能賺多少\n跟底層的人打交道，要給他臉，給他尊重\n跟厲害的人打交道，不要浪費他時間，直奔主題\n","permalink":"https://HoshikawaRyuukou.github.io/posts/social---note/","tags":["Social"],"title":"Social - Note"},{"contents":" 从Balatro小丑牌的成功说起：浅谈rogue的核心体验与设计 什么驱使着人们玩游戏？【游戏设计知识分享-动机1】 人们一直玩是因为游戏好？【游戏设计知识分享-动机2】 ","permalink":"https://HoshikawaRyuukou.github.io/posts/game-design---introduction/","tags":["Game Design"],"title":"Game Design - Introduction"},{"contents":"apktool APKTool反编译 extract.bat ⚠️ 將 extract.bat, apktool.jar, apk 放在相同目錄。\n@echo off REM Set the directory where apktool.jar is located set APKTOOL_DIR=%~dp0 REM Enable delayed variable expansion setlocal enabledelayedexpansion REM Loop through all APK files in the same directory as apktool.jar for %%f in (\u0026#34;%APKTOOL_DIR%*.apk\u0026#34;) do ( REM Get the APK file name (without extension) set APK_NAME=%%~nf echo Decompiling APK: !APK_NAME! REM Decompile the APK java -jar \u0026#34;%APKTOOL_DIR%apktool.jar\u0026#34; d \u0026#34;%%f\u0026#34; -o \u0026#34;%APKTOOL_DIR%!APK_NAME!\u0026#34; ) echo All APK files have been decompiled! pause ","permalink":"https://HoshikawaRyuukou.github.io/posts/android---reverse-engineering-copy/","tags":["Android"],"title":"Android - Reverse Engineering"},{"contents":"Guide 一小時略懂 AI｜GPT、Sora、Diffusion model、類器官智慧OI、圖靈測試、人工智慧史 【人工智能】模型压缩四大方法概述 | 量化、剪枝、蒸馏和二值化 | 模型瘦身 | 降低精度 | 速度提升 | 知识蒸馏 | 温度参数 | XNOR | 优缺点 | 发展方向 News AIbase基地 - 让更多人看到未来 通往AGI之路 Audio Suno AI Chat Bot Chat With ChatGPT bot DAN fast and free | FlowGPT Document 新世代 AI 簡報神器 Gamma Translation GPT Translator SakuraLLM/SakuraLLM ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---note/","tags":["AI"],"title":"AI - Note"},{"contents":"Developer Community 稀土掘金 Zenn Qitta Developer Guide Refactoring and Design Patterns DevIQ Developer Blog CyberAgent Developers Blog | サイバーエージェント デベロッパーズブログ SELECK [セレック] |デジタル人材のためのメディア every Tech Blog tangly llc Blog | tangly Components CodeOpinion Khalil Stemmler | Become a confident crafter. Learn to write testable, scalable TypeScript. Developer Note 牧涯前端学习笔记 | 记录一些前端学习的知识 Company - Game Happy Elements Inactive jyt0532\u0026rsquo;s Blog Tomas Tulka\u0026rsquo;s Blog Entropy Wins - A blog on Software Architecture, Design and Craftsmanship ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-development---sites/","tags":["Software Development"],"title":"Software Development - Sites"},{"contents":"Guide Ollama UI Page Assist - A Web UI for Local AI Models Commands ollama list : 查看以配置本地模型 ollama run {model} : 下載/執行模型 ollama ps : 展示目前載入的模型、它們所佔的記憶體大小以及所使用的處理器類型（GPU 或 CPU） Use model from Ollama Ollama search Use GGUF model from Hugging Face Hub # Run Ollama with specified model # ollama run hf.co/{username}/{repository} ollama run hf.co/bartowski/Llama-3.2-3B-Instruct-GGUF # Run Ollama with specified model and desired quantization # ollama run hf.co/{username}/{repository}:{quantization} ollama run hf.co/bartowski/Llama-3.2-3B-Instruct-GGUF:IQ3_M Use GGUF model from local import_gguf_to_ollama.bat @echo off REM 設定本地環境，並切換到批次檔所在的目錄 setlocal cd /d %~dp0 REM 搜尋當前目錄中的 .gguf 檔案 for %%f in (*.gguf) do ( REM 創建 Modelfile.txt 並寫入模型檔案名稱 echo FROM %%~nf.gguf \u0026gt; Modelfile.txt REM 打印 Modelfile.txt 的內容以供確認 type Modelfile.txt REM 執行 ollama create 命令來包裝模型檔 ollama create %%~nf -f Modelfile.txt REM 刪除 Modelfile.txt del Modelfile.txt REM 如果有多個 gguf 檔案，只處理第一個找到的檔案 goto end ) :end REM 顯示完成訊息 echo done... REM 列出已經存在的模型 ollama list REM 等待用戶確認並關閉 pause \u0026gt;nul ","permalink":"https://HoshikawaRyuukou.github.io/posts/ai---ollama---note/","tags":["AI","Ollama"],"title":"AI - Ollama - Note"},{"contents":"Quick Chat 最近筆者在開發公司的共用套件時，踩了不少坑，尤其是在儲存庫結構方面。\n最初選擇了 polyrepo 的結構，但隨著開發的進展，碰到了一些問題：\n要確保這些獨立的 repo 配置能夠同步。 每次發佈都需要逐一更新每個套件，尤其是那些有兩三層依賴的，讓發佈變得非常繁瑣。 進行 code review 時，還要不停地在不同 repo 之間切換。 為了改善這些問題，開始研究 monorepo 的結構：\n使用 pnpm workspace 來構建。 雖然 monorepo 有一些權限控管的隱憂，但因為共用套件的開發人數不多，所以目前還不用太擔心協作上的衝突。 Guide monorepo-vs-polyrepo 你很常聽到 monorepo，但為什麼要用 monorepo? PolyrepoからMonorepoへ移行する 策略 monolith: 當專案需要保持單一應用程式的完整性，所有功能都被打包在一起，且較少外部依賴。 monorepo: 當多個專案需要高度共享資源或密切合作，如共用許多元件、工具或模組的情況下。 polyrepo: 功能差異大、專案之間關聯性不強或不需要彼此干擾的情況下。每個專案獨立運行，較少相互依賴。 monolith polyrepo monorepo Managing a full-stack, multipackage monorepo using pnpm Live types in a TypeScript monorepo Building a Typescript + NodeJS Monorepo in 2024 特色 👍 package 使用相同版本 依賴/設定檔/風格。 ⚠️ package 權限控管需仰賴其他工作流。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-development---repository-structure---note/","tags":["Software Development","monorepo"],"title":"Software Development - Repository Structure"},{"contents":"別名方法是一種眾所周知的演算法，用於從任意離散機率分佈中進行恆定時間採樣，該演算法依賴於簡單的預先計算的查找表。\nGuide Alias Method: 非均匀随机抽样算法 Darts, Dice, and Coins: Sampling from a Discrete Distribution Weighted Random: algorithms for sampling from discrete probability distributions mackysoft/Choice jgrapht-core/src/main/java/org/jgrapht/alg/util/AliasMethodSampler.java 務必先觀看\n第一篇文章的漸進思考與核心精神 第二篇文章最後的 Vose\u0026rsquo;s Alias Method 圖解 Example 給定的權重 [0.1, 0.2, 0.3, 0.4]。\n按均值縮放權重： 均值為 : 0.25 縮放後的權重：[0.4, 0.8, 1.2, 1.6] 分類權重到 large 和 small 隊列： 初始狀態：small = [], large = [] 權重 0.4 小於 1，放入 small：small = [0] 權重 0.8 小於 1，放入 small：small = [0, 1] 權重 1.2 大於 1，放入 large：large = [2] 權重 1.6 大於 1，放入 large：large = [2, 3] 構建別名表： 初始狀態：\nprobs = [0.4, 0.8, 1.2, 1.6] aliases = [null, null, null, null] small = [0, 1] large = [2, 3] 處理 small[0] = 0, large[0] = 2：\naliases[0] = 2 probs[2] = 1.2 + 0.4 - 1 = 0.6 small.shift() -\u0026gt; small = [1] 再次分類 probs[2] \u0026lt; 1 放入 small 更新狀態：\nprobs = [0.4, 0.8, 0.6, 1.6] aliases = [2, null, null, null] small = [1, 2] large = [3] 處理 small[0] = 1, large[0] = 3：\naliases[1] = 3 probs[3] = 1.6 + 0.8 - 1 = 1.4 small.shift() -\u0026gt; small = [2] 再次分類，probs[3] \u0026gt; 1 放回 large 更新狀態：\nprobs = [0.4, 0.8, 0.6, 1.4] aliases = [2, 3, null, null] small = [2] large = [3] 處理 small[0] = 2, large[0] = 3：\naliases[2] = 3 probs[3] = 1.4 + 0.6 - 1 = 1.0 small.shift() -\u0026gt; small = [] large.shift() -\u0026gt; large = [] 現在所有 small, large 隊列均已空，構建完成。\n結果： 最終權重：probs = [0.4, 0.8, 0.6, 1.0] 最終別名：aliases = [2, 3, 3, null] 操作： 第一個隨機值 i 用於選擇權重索引。 第二個隨機值 r 用於決定是否使用別名。 case ( i = 3 ) : aliases[3] 為 null，採樣結果為 3 case ( i = 1, r = 0.6 ) : aliases[1] 非 null，且 r \u0026lt; probs[1]，採樣結果為 1 case ( i = 1, r = 0.9 ) : aliases[1] 非 null，且 r \u0026gt; probs[1]，採樣結果為 3 (aliases[1]) Summary probs alias small large [0.4, 0.8, 1.2, 1.6] [null, null, null, null] [0, 1] [2, 3] [0.4, 0.8, 0.6, 1.6] [2, null, null, null] [2] [1, 3] [0.4, 0.8, 0.6, 1.4] [2, 3, null, null] [2] [3] [0.4, 0.8, 0.6, 1.0] [2, 3, 3, null] - - ","permalink":"https://HoshikawaRyuukou.github.io/posts/algorithm---sampling---alias-method/","tags":["Algorithm"],"title":"Algorithm - Sampling - Alias Method"},{"contents":"Factory 工厂模式？错！是工厂模式群！ Observer / Pub-Sub (Publisher-Subscriber) Observer vs Pub-Sub pattern Pub sub system pros and cons Observer 觀察者模式中的主題同時身為發布者，觀察者是知道發布者的，但發布者不知道觀察者。\nPub-Sub (Publisher-Subscriber) 發布者-訂閱者模式中的主題通常由消息代理或事件總線處理，發布者和觀察者不知道彼此的存在。發布者向主題發送訊息，主題再轉發給觀察者。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---note/","tags":["Software Design","Pattern"],"title":"Software Design - Pattern - Note"},{"contents":"Quick Chat 可以將 package.json 檔案新增到套件中，以便其他人可以輕鬆管理和安裝。發佈到註冊表的包必須包含一個 package.json 檔案。\nCreating a package.json file Quick Start 根據當前目錄產生預設 package.json\nnpm init -y\nFields name 必須是小寫字母和一個單詞，並且可以包含連字符和下劃線\nversion 遵循語義版本控制準則 x.x.x\ntype 指定 module system 要用\nES : \u0026ldquo;module\u0026rdquo; CommonJS : \u0026ldquo;commonjs\u0026rdquo; main 當套件被作為 CommonJS 模組引入時，預設的入口點。\nmodule 當套件被作為 ES 模組引入時，預設的入口點。\ntypes TypeScript 的類型定義檔案位置，提供 TypeScript 支援。\nexports 是一個較新的欄位，用來細化和取代傳統的 main 和 module 欄位。它允許你為不同的環境（例如 Node.js、ES 模組、瀏覽器）定義不同的入口點和模組格式。它還允許你控制哪些檔案可以被使用者匯入，提供更多的安全性和靈活性。\n如果有 exports 欄位，Node.js 會優先使用 exports 來決定如何載入模組，只有在 exports 中沒有相應定義時，才會回退到使用 main、module 和 types 欄位。\n{ \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: { \u0026#34;types\u0026#34;: \u0026#34;./build/types/lib.d.ts\u0026#34;, \u0026#34;require\u0026#34;: \u0026#34;./build/cjs/lib.js\u0026#34;, \u0026#34;import\u0026#34;: \u0026#34;./build/esm/lib.js\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;./build/esm/lib.js\u0026#34; } } } Multiple exports with types in a Typescript Package /my-package │ ├── /dist │ ├── index.js │ ├── utils.js │ └── internal.js │ └── /lib └── helper.js { \u0026#34;name\u0026#34;: \u0026#34;my-package\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: \u0026#34;./dist/index.js\u0026#34;, \u0026#34;./utils\u0026#34;: \u0026#34;./dist/utils.js\u0026#34;, \u0026#34;./lib/helper\u0026#34;: \u0026#34;./lib/helper.js\u0026#34; } } ⛨ 限制訪問\n如果 internal.js 沒有在 exports 中明確列出，使用者將無法通過 import \u0026ldquo;my-package/internal\u0026rdquo; 來訪問它，這樣保護了內部實現細節不被暴露給外部使用者。 engines { \u0026#34;engines\u0026#34;: { \u0026#34;node\u0026#34;: \u0026#34;\u0026gt;=20.1.0\u0026#34; } } files 指定當發布專案時應該包含在內的文件或資料夾，白名單。\n{ \u0026#34;files\u0026#34;: [ \u0026#34;dist/\u0026#34;, \u0026#34;index.js\u0026#34; ] } ⚠️ 黑名單的作法 .npmignore 文件，但建議使用 files 字段，顯式聲明較為安全。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/node.js---package.json/","tags":["Node.js"],"title":"Node.js - package.json"},{"contents":"Quick Chat commitlint 是一個用來檢查 git commit 信息格式的工具，它可以配合多種規範使用。\nGuide conventional-changelog/commitlint commitlint doc Commit-lint学习：新手入门指南 Commitlint vs Commitizen: Comparison for Better Git Commit Practices Notice ⚠️ 此處搭配 simple-git-hooks 使用。 Install pnpm add -D @commitlint/{cli,config-conventional} Config package.json { \u0026#34;simple-git-hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;pnpm lint-staged \u0026amp;\u0026amp; pnpm check\u0026#34;, \u0026#34;commit-msg\u0026#34;: \u0026#34;pnpx commitlint --edit $1\u0026#34; }, } commitlint.config.js export default { extends: [\u0026#39;@commitlint/config-conventional\u0026#39;], }; ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---commitlint/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - commitlint"},{"contents":"Guide Vitest Coverage 這些數值表示了測試覆蓋率的不同方面，具體如下：\n% Stmts (Statements Coverage)：\n說明：表示程式碼中所有執行語句的覆蓋率。這個百分比告訴你測試運行時執行了多少語句。 例如：如果程式碼中有 100 行執行語句，而測試覆蓋了其中的 80 行，則此覆蓋率為 80%。 % Branch (Branches Coverage)：\n說明：表示條件分支的覆蓋率（如 if/else、switch/case）。這個百分比告訴你程式碼中所有可能的邏輯分支是否被測試覆蓋。 例如：如果有 10 個 if/else 條件，但只有 7 個條件分支在測試中執行過，則此覆蓋率為 70%。 % Funcs (Functions Coverage)：\n說明：表示函數的覆蓋率。這個百分比告訴你測試運行時，程式碼中定義的函數中有多少被調用和覆蓋。 例如：如果程式碼中有 20 個函數，而測試覆蓋了其中的 15 個，則此覆蓋率為 75%。 % Lines (Lines Coverage)：\n說明：表示實際被執行的行數覆蓋率。這與 % Stmts 類似，但更精確地計算了具體的行數。 例如：如果程式碼中有 200 行代碼，而測試覆蓋了其中的 180 行，則此覆蓋率為 90%。 Uncovered Line #s：\n說明：列出未被測試覆蓋的具體行號。這些是測試未執行到的程式碼行，你可以根據這些行號來調整和增加測試用例，從而提高測試覆蓋率。 這些指標有助於你了解測試覆蓋率的具體情況，並確保你的程式碼在不同方面都得到充分的測試。\nExtra 必要時使用括 弧表示法 訪問屬性private expect(inst[\u0026#34;_somePrivateProp\u0026#34;]).toBe(\u0026#34;foo\u0026#34;); // OK ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---package---vitest/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Package - Vitest"},{"contents":"Channel FunInCode Case 【数之道 18】\u0026ldquo;马尔可夫链\u0026quot;是什么？ 三門問題 三個囚犯問題 ","permalink":"https://HoshikawaRyuukou.github.io/posts/mathematics---note/","tags":["Mathematics"],"title":"Mathematics - Note"},{"contents":"Package npm trends npx npx 常用於執行一次性操做，允許你在不安裝包到全局或本地的情況下直接運行該包中的可執行文件。且會檢查並執行最新版本的包，確保你不會因為本地包過時而遇到問題。\nBenchmark tinybench CLI chalk cli-table3 tsx: 替代 node 指令、支持运行 TypeScript \u0026amp; ESM 的 CLI 程序 console-table-printer Git degit degit简介 IO rimraf Rimraf详细介绍 IoC InversifyJS Multitasking workerpool Test Vitest Validation zod ","permalink":"https://HoshikawaRyuukou.github.io/posts/node.js---packages/","tags":["Node.js"],"title":"Node.js - Packages"},{"contents":"Bot - API Token 搜索 BotFather 並開始對話。 使用 /newbot 命令創建一個新的機器人，按提示操作。 創建完成後，你會獲得一個 API Token，將其保存下來。 Bot - Chat ID 將你創建的機器人添加到你想發訊息的群組中。 發送一條消息到該群組。 使用以下 URL 來獲取群組的更新: https://api.telegram.org/bot\u0026lt;YourBotToken\u0026gt;/getUpdates 查看返回的 JSON 數據，找到 chat 字段中的 id，這就是群組的 Chat ID。 { \u0026#34;ok\u0026#34;: true, \u0026#34;result\u0026#34;: [ { \u0026#34;update_id\u0026#34;: 123456789, \u0026#34;message\u0026#34;: { \u0026#34;message_id\u0026#34;: 1, \u0026#34;from\u0026#34;: {}, \u0026#34;chat\u0026#34;: { \u0026#34;id\u0026#34;: -1001234567890, \u0026#34;title\u0026#34;: \u0026#34;Your Group Title\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;supergroup\u0026#34; }, \u0026#34;date\u0026#34;: 1617821123, \u0026#34;text\u0026#34;: \u0026#34;Your Message\u0026#34; } } ] } Sticker Telegram 貼圖 DIY教學 ","permalink":"https://HoshikawaRyuukou.github.io/posts/telegarm---note/","tags":["Telegram"],"title":"Telegram - Note"},{"contents":"Quick Chat 最近筆者從 Unity 轉向了 Node.js，因此花了大量時間在 npm 上尋找合適的套件。大部分的 README 都寫得很清晰，但也有少數寫得難以理解。\nREADME 是 Repository 的門面，這是毋庸置疑的。創建一個好的自述文件，可以向用戶（包括使用者和開發者）顯示基本信息，但不應該用他們可能不需要的內容來淹沒他們。\n筆者認為應該從一開始就認真對待 README，而不是在最後(專案收尾之際)才一股腦地將資訊灌入，這樣會降低其品質。\nGuide 你知道對專案來說，README.md 有多麼重要嗎？ ── 工程師血淚史 README 的藝術 Markdown + Vscode Markdown All in One Markdown Preview Github Styling Template README-Template.md GitHub README Templates Strategy 為誰而寫 必須意識讀文件的人分成使用者和開發者，README 在佈局上要有明確的邊界。\n以使用者角度 Tutorial Reference 以開發者角度 環境設定/測試/部署/發布方法 開發流程/編碼規範等 避免 README 過長 這個視專案而定，當 README 內容越來越多時可以考慮將其拆分至其他文檔，而 README.md 則改做為文檔的索引頁。\nREADME.md RELEASELOG.md CHANGELOG.md CONTRIBUTING.md ./docs/Tutorials/xx.md ./docs/Examples/xx.md 避免 Header 過度使用 原本寫作時會下意識的使用不少的三級標題 ### Header\n## Header2 ### Header3 分段... ### Header3 分段... 但這次觀察 READMEs 的過程，看到不少以下這種不多做一些分段的寫法\n## Header2 直接承接本文段落... 原本以為會很難閱讀，但實際上閱讀時都是順著讀下來，所以好像不會有負面影響。反倒是原先 Header3 過多造成畫面有點割裂。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-development---readme/","tags":["Software Development"],"title":"Software Development - README"},{"contents":"Books fucking-algorithm hello-algo Repo The Algorithms ","permalink":"https://HoshikawaRyuukou.github.io/posts/algorithm---note/","tags":["Algorithm"],"title":"Algorithm - Note"},{"contents":"Guide 三十分钟正则表达式教程 Tools RegExr: Learn, Build, \u0026amp; Test RegEx ","permalink":"https://HoshikawaRyuukou.github.io/posts/regex---note/","tags":["Regex"],"title":"Regex - Note"},{"contents":"Guide Node.js究竟是什么？初学者指南 coreybutler/nvm-windows nvm-windows 管理 Windows Node.js 版本 [指令] npm cli \u0026amp; package.json 解决Node.js的命令行输出中文乱码问题（也适用于Electron） Module 什麼是前端模組化？ Multitasking Worker Threads in Node.JS Worker Threads : Multitasking in NodeJS Node.js Worker Threads Vs. Child Processes: Which one should you use? ","permalink":"https://HoshikawaRyuukou.github.io/posts/node.js---note/","tags":["Node.js"],"title":"Node.js - Note"},{"contents":"美術 坦輸療（坦克，輸出，治療師）的小冒險 Trickcal Re:vive MEMORICA 機制 ティンクルスターナイツ　種族交流会地獄級なんですが Webbed ハンマーハートデリバリ― Remembery – Memory game pairs 鬥技場的阿利娜 ","permalink":"https://HoshikawaRyuukou.github.io/posts/game-design---inspiration/","tags":["Game Design"],"title":"Game Design - Inspiration"},{"contents":"Guide SLOT設計王文章導讀 - SLOT設計王 Slots设计攻略导读 Know Your Slots 游戏中的伪随机 随机游走的赌徒是如何赔光的 How Slot Machines Work: Virtual Reel Mapping 抽卡体验设计：关于盲盒、抽卡、开箱的一切 Framework Publications | Slot Designer hankpan-dev/slotkit sta-ger/pokie Sample Casino Roulette Game Spotlight Pixel Farm by Twist Gaming ","permalink":"https://HoshikawaRyuukou.github.io/posts/slot-design---note/","tags":["Slot Design"],"title":"Slot Design - Note"},{"contents":"Community IGDSHARE | 獨立遊戲開發者分享會 Blog 飛鳥涼不涼的遊戲營運觀察小站 THAT GAME DESIGNER - 遊戲設計師 游戏葡萄 Dev Blog QualiArtsエンジニアブログ Happy Elements株式会社 カカリアスタジオ Rank APPLION UI Interface In Game | Collection of video games UI | Screenshots and videos ゲームUIブログ Interview Nexon 《蔚藍檔案》的作曲家們 - #1 Nexon 《蔚藍檔案》的作曲家們 - #2 Nexon 《蔚藍檔案》的作曲家們 - #3 [訪談] 蔚藍檔案的過去、現在和未來（上） [訪談] 蔚藍檔案的過去、現在和未來（下） 淺談《Celeste》的教學引導設計與機制設計 《Celeste》如何打造Madeline的優異動態感？ ","permalink":"https://HoshikawaRyuukou.github.io/posts/game-design---note/","tags":["Game Design"],"title":"Game Design - Note"},{"contents":" 達克效應（DK Effect）的美麗錯誤 — — 對無知的無法認知：愚昧之巔、絕望之谷 一山還有一山高：談眼鏡蛇效應（Cobra Effect） ","permalink":"https://HoshikawaRyuukou.github.io/posts/phenomena---note/","tags":["Phenomena"],"title":"Phenomena - Note"},{"contents":"Style Google JavaScript Style Guide Basic 作用域(scope)解說：let, const, var有什麼差？ Value與Reference的差異解說 async/await JavaScript 中的 async/await 是什麼？和 promise 有什麼差別？ Event Loop JavaScript Event Loop解說：單執行緒還能異步運算？ 請說明瀏覽器中的事件循環 (Event Loop) Object 為什麼推薦用 structureClone 在 JavaScript 做深拷貝? Promise Promise 是什麼？有什麼用途？ Others 前端 JavaScript 代码保护？！ ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---javascript-note/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - Javascript Note"},{"contents":"Style Google TypeScript Style Guide Tool JSON to TypeScript Basic TypeScript 物件中的 public, private, protected, static, readonly TypeScript – Using Disposable Coding guidelines 使用 undefined。不要使用 null。 tsc \u0026ndash;project tsconfig.json : 使用當前目錄下的 tsconfig.json \u0026ndash;showConfig : 檢視該目錄的 tsconfig.json (包含繼承的數值) ","permalink":"https://HoshikawaRyuukou.github.io/posts/javascript_typescript---typescript-note/","tags":["JavaScript","TypeScript"],"title":"Javascript_TypeScript - TypeScript Note"},{"contents":"Diagrams Draw.io Integration Software Diagrams - Plant UML vs Mermaid Mermaid Doc Encoding VS Code採用Code Runner遇到的 Output中文亂碼問題 (Python) Display Visual Studio Code ( VS Code) 切換成中文版 Extensions Code Runner :emojisense: Hot Keys (Windows) 打開快捷鍵設定 : Ctrl + K Ctrl + S ","permalink":"https://HoshikawaRyuukou.github.io/posts/vscode---note/","tags":["VScode"],"title":"VScode - Note"},{"contents":"Disk 如何在Windows 10中刪除Hiberfil.sys（休眠）檔案 Shortcut Windows 11 顯示與清除歷史記錄 Windows + Shift + S：這個組合鍵會啟動截圖工具，允許用戶選擇截取的區域 Other windows为什么有两个命令行工具？命令提示符与PowerShell有什么区别？ ","permalink":"https://HoshikawaRyuukou.github.io/posts/os---windows---note/","tags":["OS","Windows"],"title":"OS - Windows - Note"},{"contents":"Quick Chat 在構建過程中，Unity 通過稱為託管代碼剝離的過程刪除未使用或無法訪問的代碼，這可以顯著減小應用程式的最終大小。\nFile -\u0026gt; Build Settings -\u0026gt; Player Settings -\u0026gt; Optimization -\u0026gt; Managed Stripping Level\n⚠️ Managed Stripping Level 等級越高裁剪掉的代碼越多，包體也就越小，但是對應的風險也就更大。 藉由屬性或特殊 XML 配置檔的形式提供註釋，以指示 Unity 連結器要保留代碼庫的哪些部分。 Guide Unity - Manual: Managed code stripping KuraiAndras/LinkerGenerator IUnityLinkerProcessorでCodeStrippingからコードを守る Preserving Preserve attribute ⚠️ [Preserve] 屬性屬於“侵入式”的解決方案，不建議 class Foo { [Preserve] public void PreservedMethod(){} } link.xml 在專案的 Assets 目錄下創建個 link.xml \u0026lt;linker\u0026gt; \u0026lt;assembly fullname=\u0026#34;DOTween\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;Newtonsoft.Json\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;Assembly-CSharp\u0026#34; preserve=\u0026#34;all\u0026#34; /\u0026gt; \u0026lt;assembly fullname=\u0026#34;UnityEngine\u0026#34;\u0026gt; \u0026lt;type fullname=\u0026#34;UnityEngine.SpriteRenderer\u0026#34; preserve=\u0026#34;all\u0026#34;/\u0026gt; \u0026lt;type fullname=\u0026#34;UnityEngine.Rigidbody2D\u0026#34; preserve=\u0026#34;all\u0026#34;/\u0026gt; \u0026lt;/assembly\u0026gt; \u0026lt;/linker\u0026gt; ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---coding---managed-code-stripping/","tags":["Unity"],"title":"Unity - Coding - Warnings"},{"contents":"Games 28598519a/TSK_AssetDL ZM-Kimu/Blue-Archive-Asset-Downloader Extracting AssetRipper/AssetRipper ","permalink":"https://HoshikawaRyuukou.github.io/posts/game-analysis---assets/","tags":["Game Design","Assets","Art"],"title":"Game Analysis - Assets"},{"contents":"前述 UniTask - Unity 中實現效能最好的 async/await 的函式庫\nCysharp/UniTask Unity 中預設的非同步實現是 - Coroutine 協程，但協程有以下缺點\n無法使用回傳值，需使用 callback 來解決。 異常處理很困難，因為不能在 try-catch 區塊內使用 yield。 需透過 MonoBehaviour.StartCoroutine 才能啟動。 UniTask 相較於 C# 原生的 Task 做了以下改進\n刪除了 Task 在 Unity 不需要的功能。 非 MonoBehaviour 裡也能實現非同步。 記憶體/ GC / Unity PlayerLoop 等方面做最佳化。 UniTaskTracker 提供編輯器上可視化追蹤 await 狀態，這對於檢查是否有洩漏很有用。 UniTask 官方文件的基本功能寫得相當清楚，並附上一些入門介紹\nUniTaskを使おう！ UniTask機能紹介 以下紀錄幾個重點主題\nAwaiter UniTask 已經實作了相當豐富的 Awaiter 擴充，有需要自訂的可以參考以下規範\n.NET 中什么样的类是可使用 await 异步等待的？ Thread UniTask.SwitchToThreadPool 允許後續處理在執行緒池中進行。 UniTask.SwitchToMainThread 切換到主執行緒，不會等待下一幀。 也可以使用 UniTask.Yield 切換到主執行緒，但它總是等待一幀。 但目前尚未有使用到的情境，之後有遇到再嘗試。\nUniTaskを使えば並列処理で外部機器からデータを簡単に取得できますの紹介 此外使用執行緒池，將無法與 WebGL 等平台相容。未來應該也會避開使用。\nCancellation Cancel 算是在使用 Task-based 機制時最須留意的事項。UniTask 一旦被取消，且還在 await 的話，那麼 await 後面的程式碼就不會被執行。因此盡可能將 CancellationToken 傳遞給非同步方法。如果不能傳遞，則手動判斷。\nprivate async UniTask\u0026lt;string\u0026gt; ReadTxtAsync(string path, CancellationToken token) { return await UniTask.Run(() =\u0026gt; { // 執行前檢查 token.ThrowIfCancellationRequested(); var str = File.ReadAllText(path); // 執行後檢查 token.ThrowIfCancellationRequested(); return str; }); } 當 Cancel 跟 MonoBehaviour OnDestroy 時機掛勾時，能透過 GetCancellationTokenOnDestroy 來取得對應的 CancellationToken。\n在 WebGL 這種對性能要求比較高的情境，建議使用 SuppressCancellationThrow 函數，来避免 OperationCanceledException 抛出。\n這裡有詳細探討與建議作法\n【C#】async/awaitのキャンセル処理まとめ Completion 【UniTask】UniTaskCompletionSourceを使って好きなタイミングで結果を確定させるUniTaskを生成する(ついでにUniTask.Voidの紹介) Cancel a CompletionSource with a cancellation Timeout 建議使用 TimeoutController 不要忘記與現有的結合 CancellationToken 避免使用 AttachExternalCancellation Extra Unity 官方也將在 Unity 2023.1 之後逐步完善 async/await 機制\nAwait support 【Unity 2023.1】 C# async/await 正式サポート？ Awaitable を使ってみよう！ ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package---unitask/","tags":["Unity"],"title":"Unity - Package - UniTask"},{"contents":"Guide Unity 不通過Android studio 打包接SDK Settings gradleTemplate.properties : 專案的全域 Gradle 配置。 AndroidManifest.xml ：用於向 Android 構建工具、Android 作業系統和 Google Play 描述應用的基本資訊。 launcherManifest.xml 定義應用的啟動配置資訊 mainTemplate.gradle：自定義 Android 專案的 Gradle 構建過程，包括添加依賴項、修改編譯設定、配置簽名資訊等。 launcherTemolate.gradle ：包含有關如何構建 Android 應用程式的指令 baseProjectTemplate.gradle：所含的配置會在其他所有範本/Gradle 專案之間共用 Device Quickly preview your game on Android device | Unity tutorial ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---platform---android---build/","tags":["Unity","Android"],"title":"Unity - Platform - Android - Build"},{"contents":"前述 這次的業務需求是\n將 Google Play Install Referrer 接入 Unity\n目前有使用到 AndroidJNIModule 中的\nAndroidJavaClass AndroidJavaObject AndroidJavaProxy 但中途採了不少坑，特此紀錄一下。\n基本知識 UnityEngine.AndroidJNIModule How to Create Android Java Callbacks to C# in Unity UnityからAndroidのクラスや関数を呼び出す AndroidJavaClass 可以實例化 Java 類、調用 Java 類的靜態方法，以及訪問 Java 類的靜態屬性。 AndroidJavaObject 創建 Java 對象的實例。 AndroidJavaProxy 允許在 Unity C# 腳本中實現 Java 接口。 允許我們在 Java 中調用方法，這些方法將調用 C# 類上的 匹配 方法。 注意 函數名匹配 (建議直接看 source code 裡面的值，本此次就遇到 官方文件與 jar 為匹配) android.os.Build.VERSION 將意味著要到一個公開類 android.os.Build$VERSION 將意味著進入一個內部類 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---platform---android---androidjnimodule/","tags":["Unity","Android"],"title":"Unity - Platform - Android - AndroidJNIModule"},{"contents":"簡述 Play Install Referrer\nPlay Install Referrer API : 非 Kotlin / Java 用戶使用 Play Install Referrer Library : 將上者封裝更方便 Kotlin / Java 使用 透過該服務能對 App 的下載與使用者進行歸因分析，用於評估推廣服務得成效，進而提升推廣效果與報酬率。\n舊版 Play Install Referrer 在使用者下載應用程式後透過廣播傳送包含歸因參數的訊息。然而廣播的不可靠性和安全性問題，目前不再建議使用這個版本。 新版 Play Install Referrer 直接訪問本機 Google Play 應用程式商店中的記錄，索取 referrer 值，因此更加可靠。 快速上手 Unity 專案: 將依賴加在 maintemplate.gradle\ndependencies { implementation(\u0026#34;com.android.installreferrer:installreferrer:2.2\u0026#34;) } 因為官方 API 文件寫的不全，建議到以下網站直接下載 aar 查看 jar 來對接 API\nGoogle\u0026rsquo;s Maven Repository Maven Repository 使用服務的工作流為如下\n建立連線 等待 callback 連線成功 索取 referrer 關閉連線 Referrer 格式 https://play.google.com/store/apps/details?id=${package name}\u0026amp;referrer=${parameter} Play Campaign URL Builder 廣告活動參數 Referrer 狀態 將手機連著 android studio 開啟 Logcat，透過連結前往商店發現有 4 種情境\n未安裝 點連結 Finsky com.android.vending Capture referrer for package name\n已安裝 點連結 Finsky com.android.vending Dropped referrer for package name because dropped_already_captured\n已安裝 但有版本差異 Finsky com.android.vending Dropped referrer for package name because dropped_already_installed\n移除app 會移除 referrer 但沒有 Finsky 相關 log\n模擬測試 透過Google Play Console 封閉式測試是比較正規的測法，但如果沒有現成的產品，也可以借別人(架上的)的 package name 來測試\n下載別人的產品但不要載完(要取消)，這時 referrer 還會保留 將本地測試的專案 package name 改成別人的 package name，就能使用到保留的 referrer Ref Android 下載歸因— GA與Play Install Referrer庫 android 整合Play Install Referrer uerceg/play-install-referrer-unity (obsolete) ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---service---google-play-install-referrer/","tags":["Unity"],"title":"Unity - Service - Google Play Install Referrer"},{"contents":"簡述 VIPER (View-Interactor-Presenter-Entity-Router)\niOS VIPER架構實踐(一)：從MVC到MVVM到VIPER VIPER，更清晰的架构，解决复用和测试问题的利器系列1：VIPER架构演进史 有很多種實作流派，下圖是我比較偏好的模式呈現\nVIPER 借鏡了 CA (Clean Architecture) 的思想為 MVC 提供一個新的設計方案\nEntity 對應原本的 Model Controller 責任過重 -\u0026gt; 將業務邏輯移至 Interactor 並提高重用性 Controllers 之間耦合 -\u0026gt; 將導航邏輯移至 Router Presenter 作為 Binder 將 View / Interactor / Router 整合 啟發 VIPER 是筆者學習架構路上很重要的一個過渡，有以下兩點的思想轉變\n顆粒度更細的單一職責 Interactor 封裝業務的概念在純 MVX 中是無法直接體會到，因此對之後學習 CA 時起了很大的緩衝，不然對於 Usecase 的設計應該會很不適應。\n重視 Navigation 在學習 CA 中始終沒題到 feature/componet module 之間是如何互動的，也是在回頭複習 VIPER 時才重新意識到 Router 的重要性。當沒有特別規劃 Navigation 時很容易會造成 module 之間的耦合。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---architecture---viper/","tags":["Software Design","Architecture"],"title":"Software Design - Architecture - VIPER"},{"contents":"簡述 Official Home Page Official Doc 監控崩潰和異常報告 測試人員和應用使用者能直接提供用戶報告 啟用成本極低且非侵入式 有免費套餐，Personal 常規操作應該是沒問題，一旦超出了免費額度，系統將要求添加付款方式以繼續使用服務 快速上手 Cloud Diagnostics エラーやクラッシュを記録し、バグ特定の手助けになるUnity公式の無料サービス Unity Cloud Diagnostics UnityエディタやUnityで作ったゲームを強制的にクラッシュさせる方法 注意 Apple\u0026rsquo;s privacy survey Google Play data safety disclosures for Cloud Diagnostics ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---service---cloud-diagnostics/","tags":["Unity"],"title":"Unity - Service - Cloud Diagnostics"},{"contents":"Quick Chat 有需要客製化 Unity 官方 / git 直接導入 的 Package 時\nGuide How can I modify built-in packages? Unity - 如何修改一个 Package 或是如何将 Package Local化 Steps 至 ProjrctRoot\\Library\\PackageCache 找到目標的 Package 剪下貼上至 ProjrctRoot\\Packages 即可 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package-manager---modify-a-package/","tags":["Unity","Package Manager"],"title":"Unity - Package Manager - Modify a package"},{"contents":"前言 Google 停止維護 Game Package Registry (GPR) 導致不能直接使用 Package Manager 導入包。必須到封存檔網站下載「.tgz」手動導入。\nGoogle Unity 套件 Install a package from a local tarball file 其他的相關的 Google Service 依賴(AR/Firebase/Google Play等)也可以用此方法導入。\n設定 Assets \u0026gt; External Dependency Manager \u0026gt; Android Resolver \u0026gt; Settings 啟用這三個 Patch 並至 Player Settings \u0026gt; Publishing Settings 啟用以下選項 Auto resolution Assets \u0026gt; External Dependency Manager \u0026gt; Android Resolver \u0026gt; Force Resolve 後會去收集專案所有 Editor 資料夾下的 *Dependencies.xml 加到 mainTemplate 中\n","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package---external-dependency-manager-for-unity-edm4u/","tags":["Unity","Google Service"],"title":"Unity - Package - External Dependency Manager for Unity (EDM4U)"},{"contents":"前述 此篇的實作參考到以下文件 (提到不少 Presentation layer 設計原則)\nAndroid Developers 文件/指南/UI 層\n該文件的更新頻率算高且會與時俱進，筆者印象中其架構設計從 MVVM -\u0026gt; Domain/Application Driven 設計，可以看出主流架構有產生變化。之後的討論雖然使用 ViewModel 但不會詳細介紹 MVVM 的細節，如果對 MVX 系列不熟，可以先讀筆者之前的文章 \u0026laquo;通用設計 - Pattern - MVP\u0026raquo; 裡面的 References。\n探索 回到正題，筆者在最近的業務上遇到\n如何在 服務端未完成 的情況下，讓 Client 獲得完整的體驗流 ?\n以下用交叉反問的方式來分析問題\nQ: 沒有服務端那資料來源哪來 ? A: 使用假資料\nQ: 當表現層依賴的是 IService Interface 使用假資料時需要實作什麼 ? A: 只需要實作一個 FakeService 來產生假資料即可\nQ: 當想要將業務與表現解耦時，很常使用中介者的手法來黏合兩者，如果使用標準的 MVP 實做，Presenter 實際做了哪些事呢 ? A: 監聽 View 事件/ 與 Service 互動/ 管理畫面狀態/ 呼叫 View 刷新\nQ: Presenter 似乎有點多事情 ! A: 其實需要視情況而定，情況簡單時直接向 View 倒資料也是完全可以接受的。但當情況複雜時可以選擇導入 ViewModel 來管理狀態。事實上表現層所要呈現的 UI 狀態未必是只跟 Service 的回傳有關，可能需要這樣的控制 條件A(Service) + 條件B(Local) + 條件C(User Runtime) -\u0026gt; 狀態D\nQ: 也就是將 UI 狀態封裝於 ViewModel 裡管理 ! A: 對於畫面需求可以定義於 IVewModel 介面，這樣就隔離了 Service(隱藏於 ViewModel 實作中)，畫面就可以獨立於 Service 開發，細節將於下一結討論\nMediator ✽ FlowController 這裡視為進入點即可\n(左邊)\n採用標準的 MVP FlowController/Presenter 需做狀態管理 (右邊)\n採用 MVP 混用 ViewModel ViewModel 代替 Presenter 作為邏輯與畫面的中介 FlowController/Presenter 依賴同為 Presentaion 的 IViewModel，這樣表現層邏輯就可以不依賴 Service 獨立開發，等之後在實作對應的 ViewModel 且能根據不同的狀態源(體驗版/正式版) ViewModel 的優勢情境\n單一職責: 明確的狀態管理單位 單向資料流: 排除了對 View/IView 的依賴，使用觀察者模式，供外部訂閱數據/變化 能對應狀態需要被共用的狀態: 得力於狀態被獨立出來，可被多個單位給使用 Example ✽ 觀察者模式採用 UniRx 實作\n以一個井字遊戲為例，情境如下\n定義 IAppViewModel\npublic interface IAppViewModel { // 選單/設定/遊戲 的啟動狀態 IReactiveProperty\u0026lt;bool\u0026gt; MenuActiveRP { get; } IReactiveProperty\u0026lt;bool\u0026gt; SettingActiveRP { get; } IReactiveProperty\u0026lt;bool\u0026gt; GameActiveRP { get; } } 定義 IGamePlayViewModel\npublic interface IGamePlayViewModel { // 回合數狀態 IReactiveProperty\u0026lt;int\u0026gt; TurnRP { get; } // 點選成功事件 IObservable\u0026lt;SelectResult\u0026gt; Selected { get; } // 點選失敗事件 IObservable\u0026lt;string\u0026gt; SelectFailed { get; } } 使用 AppFlowController 根據 IAppViewModel 去開關對應的 Presenter\npublic class AppFlowController : IDisposable { private readonly IAppViewModel appVM; private readonly GamePlayPresenter gamePlayPresenter; ... private readonly CompositeDisposable disposables = new(); public AppFlowController(IAppViewModel appVM, GamePlayPresenter gamePlayPresenter, ...) { this.appVM = appVM; this.gamePlayPresenter = gamePlayPresenter; ... } public void Start() { disposables.Clear(); appVM.GameActiveRP.Subscribe(OnGameActiveRP).AddTo(disposables); ... } public void Dispose() { disposables.Clear(); } } 使用 GamePlayPresenter 根據 IGamePlayViewModel 去更新遊戲畫面\npublic class GamePlayPresenter { private readonly IGamePlayViewModel vm; private readonly GamePlayView view; private readonly CompositeDisposable disposables = new(); public GamePlayPresenter(IGamePlayViewModel vm, GamePlayView view) { this.vm = vm; this.view = view; } public void Enable() { disposables.Clear(); vm.TurnRP.Subscribe(OnTurnNumberChanged).AddTo(disposables); vm.Selected.Subscribe(OnSelected).AddTo(disposables); vm.SelectFailed.Subscribe(OnSelectFailed).AddTo(disposables); view.Show(); } public void Disable() { view.Close(); disposables.Clear(); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---viewmodel/","tags":["Software Design","Pattern"],"title":"Software Design - Pattern - ViewModel"},{"contents":"注意 由於Unity 無法將性能分析器本身佔用的記憶體與運行模式的記憶體完全分開。要獲得應用程序的更精確數字和記憶體使用情況，應在要運行應用程序的目標設備和操作系統上分析應用程序。 如果需要在記憶體受限的平台上運行應用程序，設備上的總駐留量對於檢查低記憶體警告和由於記憶體耗盡而強制關閉非常有用。作為一般規則，它不應超過設備上可用總物理內存的 70%。 偵測 Leaked Managed Shell 的功能在 Memory Profiler 1.1.0-pre.1 Ref Memory Profiler Memory Profiler | 1.1.0-pre.1 - Unity - Manual Unity でメモリリーク？ Memory Profiler で Leaked Managed Shell をチェックしてみよう！ Inspecting memory with the new Memory Profiler package Memory Profiler로 애플리케이션의 물리적 메모리 사용량 분석 Unity内存分析与优化实践(1.1版本前) ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---performance---memory-profiler/","tags":["Unity","Performance"],"title":"Unity - Performance - Memory Profiler"},{"contents":" 之前筆者一直以為 rebase 是進行類似 剪下貼上 的操作，但實際上是 複製貼上\n情境 合併時不會像 merge 時會有 commit 的節點 想整理 還沒推出去 的 commit 可以使用 避免修改已經推出去的歷史 如何取消操作 使用 reflog 列印出所有「歷史紀錄」找到 rebase 的前一個 commit id，並進行 reset 即可\ngit reflog git reset XXXXXXX --hard 此外當進行比較危險操作時 git 會額外紀錄前一個 head 於 ORIG_HEAD，因此也可以直接執行以下，來達到同樣效果\ngit reset ORIG_HEAD --hard Ref 另一種合併方式（使用 rebase） git rebase 用法 git rebase -i (drop) git rebase -i (pick) git rebase -i (reword) ","permalink":"https://HoshikawaRyuukou.github.io/posts/git---rebase/","tags":["Git"],"title":"Git - Rebase"},{"contents":"Quick Chat 有的環境也稱 Merge Request\n開發產品時一般會挑選固定一個分支做為可以上線的正式版本分支(master)，需注意的是在進行多人協同開發時，讓每個人都可以 Commit 到專案正式上線的分支不是個好的做法。\n可以透過 pull request 方式控管權限，由負責管理這個專案的人收到其他開發者的 pull request 並確認無誤後便可進行合併，來確保產品分支處於隨時都是可上線的狀態。\n參與開源專案時，在創建 pull request 之前，建議先在本地分支上運行 git rebase 命令，確保你的更改基於最新的進度以降低審查者的理解難度。\nGuide 與其它開發者的互動 - 使用 Pull Request（PR） ","permalink":"https://HoshikawaRyuukou.github.io/posts/git---pull-request/","tags":["Git"],"title":"Git - Pull Request"},{"contents":"前述 中文稱作 : 前置處理器指示詞\n筆者最近接觸到的遺舊專案中發現裡面大量地使用 條件式編譯\n#if DEBUG Console.WriteLine(\u0026#34;Debug version\u0026#34;); #endif 筆者之前有使用也基本只使用 定義區域 (排版效果)\n#region MyClass definition public class MyClass { static void Main(){...} } #endregion Unity 在處理平台裝置時也蠻常會出現的\npublic class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(\u0026#34;Unity Editor\u0026#34;); #endif #if UNITY_IOS Debug.Log(\u0026#34;iOS\u0026#34;); #endif #if UNITY_STANDALONE_OSX Debug.Log(\u0026#34;Standalone OSX\u0026#34;); #endif #if UNITY_STANDALONE_WIN Debug.Log(\u0026#34;Standalone Windows\u0026#34;); #endif } } 問題 那前置處理器指示詞有什麼問題呢? (參考日文那個 Ref 有比較明確的 Case)\n編譯版本至少會是 2^(指示詞的分類數)種，持續的調試和測試變得非常困難。 Unit Test 中難以使用。 編譯檢查不起作用。 當巢狀結構出現時可讀性將大為降低。 上述這些狀況都會導致 延後發現問題的時間 !\n方案 這個前置處理器指示詞一直是個蠻有爭議的作法，有一派人士是不使用的(通過使用條件分支、策略模式或依賴注入等其他方式，更可以清晰地表達了代碼的邏輯，提高了程式的可維護性)。\n筆者也傾向不使用(業務邏輯不用，其餘的看狀況)。\nCase. Editor 有時後會有需要客製編輯器時，會這樣跟 MonoBehaviour 寫在一起並用 UNITY_EDITOR 處理。但事實上獨立一個檔案放在 Editor 資料夾 應該會更好。\n#if UNITY_EDITOR ... #endif Case. RuntimePlatform public void Run() { if (Application.platform == RuntimePlatform.Android) { new ClassForAndroid().Execute(); } else if ... } Case. 減少指示詞的影響範圍(非得使用指示詞) ConditionalAttribute 官方文件也有推薦此作法。\n[Conditional(\u0026#34;DEBUG\u0026#34;)] private void DebugLog(string message) { Debug.Log(message); } 透過定義介面(需求上允許的話)，來讓影響範圍控制在實例化階段。\n#if UNITY_EDITOR var runner = new EditorRunner(); #elif UNITY_IOS var runner = new IOSRunner(); #elif UNITY_ANDROID var runner = new AndroidRunner(); #endif Ref C# 前置處理器指示詞 macroのカジュアル多用は危険 Conditional Compilation ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---preprocessor-directives/","tags":["Unity","CSharp"],"title":"Unity - Basic - Preprocessor Directives"},{"contents":"前述 這次的業務需求是\n取得 ios 實機的 \u0026ldquo;地區\u0026rdquo;，並讓 C# 能拿到 Swift 所返回的字串\n因為在 ios 的環境下 unity / C# 拿到的值並不正確。此外筆者對 Swift / Objective-C 幾乎零基礎，目前只針對一些教學文件做些修改，之後有機會更熟再回頭深究。\n實作 SwiftDeviceInfoPlugin.swift 須放置於 Plugins\\iOS 之下 import Foundation public class SwiftDeviceInfoPlugin { public static func getRegion() -\u0026gt; String { return Locale.current.regionCode ?? \u0026#34;Unknown\u0026#34; } } @_cdecl(\u0026#34;getRegion\u0026#34;) public func getRegion() -\u0026gt; UnsafePointer\u0026lt;CChar\u0026gt;? { let region = strdup(SwiftDeviceInfoPlugin.getRegion()) return UnsafePointer(region) } @_cdecl(\u0026ldquo;getRegion\u0026rdquo;)：這是一個 Swift 標記，表示下面的函數將使用cdecl樣式的名稱綁定。您只需知道此屬性向 C 公開了一個 Swift 函數 UnsafePointer\u0026lt;CChar\u0026gt;?，它是一個可為空的指向 C 風格字串（CChar）的指標。這使得 Swift 能夠以與 C 相容的方式提供訪問區域資訊的介面。 strdup() 用於創建預返回的字串的副本，並在堆上分配其記憶體。 public sealed class IOSDeviceInfoProvider : IDeviceInfoProvider { public string GetRegion() { return new System.Globalization.RegionInfo(GetRegionFromDevice()).ThreeLetterISORegionName.ToUpper(); } [DllImport(\u0026#34;__Internal\u0026#34;, EntryPoint = \u0026#34;getRegion\u0026#34;)] static extern string GetRegionFromDevice(); } [DllImport] : 是一個 System.Runtime.InteropServices 命名空間中的屬性，它告訴 C# 編譯器這個函數是在外部插件中定義的，並且需要從外部導入。 EntryPoint = \u0026ldquo;getRegion\u0026rdquo; 表示在外部插件中將使用名為 callSwift 的函數作為入口點。 extern 關鍵字表示該函數的實現不是在 C# 代碼中，而是在外部的原生插件中實現的。 待補 記憶體管理的知識點 這次沒用到委派，須找時間理解 Ref Building plug-ins for iOS C# から直接 Swift コードを呼び出す Setting Up iOS Framework for Unity From Swift to C# ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---platform---ios---plug-in/","tags":["Unity","iOS"],"title":"Unity - Platform - iOS - plug-in"},{"contents":"前述 Service Locator 確實也是 IoC 的一種實作方式，不過採用的是 依賴尋找(Dependency Lookup) 的設計。 筆者之前有一陣子蠻常使用這 pattern，那時對 DI 與 IoC 的概念並不熟悉，只覺得這樣使用依賴變得很方便。\n因為我可以在任何地方直接這樣取用資源\nvar target = ServiceLocator.Resovle\u0026lt;Target\u0026gt;(); 這樣的寫法有以下問題 :\n透過 ServiceLocator 因為這個取用資源的過程是隱性的，不容易被直接發現。 想用誰就拿誰這件事也有點危險，Ex: View 可以拿到不屬於 Presentation layer 該碰的對象。 所以當 DI 與 IoC 的概念熟悉後，並且使用 DI / IoC Container 後就漸漸不使用這 pattern 了。\n應用 但這次工作上反而覺得 Service Locator 可以勝任從 Singleton 過渡到 DI / IoC Container 的中繼階段。\n因為這次接觸到的專案嚴重依賴 Singleton，且組員也已習慣 Singleton 的寫法了，要直切換到 DI / IoC Container 會有不小的陣痛期(當然實務上能不能切又是另一個故事了)。\n於是筆者想起了 Service Locator，有以下理由\n因為在使用上就很像是 Singleton 筆者希望組員能快速感受到 IoC 所帶來的紅利 集中管理依賴 實作 此模式使用稱為「服務定位器」的中央註冊表，它根據請求返回執行特定任務所需的對象。\n以下是一種變體實作\n註冊的對象不強制要實作介面 基本上只當是個容器 因為不使用反射，需要搭配一個 Installer (組合根) // 這裡透過 static 來達到全域使用 public class ServiceLocator { private static readonly Dictionary\u0026lt;Type, object\u0026gt; instances = new Dictionary\u0026lt;Type, object\u0026gt;(); public static void Register\u0026lt;T\u0026gt;(T instance) { instances[typeof(T)] = instance; } public static T Resolve\u0026lt;T\u0026gt;() { if (instances.TryGetValue(typeof(T), out var instance)) { return (T)instance; } throw new Exception($\u0026#34;Service of type {typeof(T)} is not registered.\u0026#34;); } public static void Release\u0026lt;T\u0026gt;() { if (instances.ContainsKey(typeof(T))) { instances.Remove(typeof(T)); } } } // 由 Installer 來對容器註冊對象 public class DemoBasicServiceLocatorsInstaller : MonoBehaviour { public DemoBasicMoneyUI moneyUI; public MoneyType moneyType; public int moneyValue = 100; void Start() { switch (moneyType) { case MoneyType.Real: ServiceLocator.Register\u0026lt;IMoneyFormatConverter\u0026gt;(new RealMoneyFormatConverter()); break; case MoneyType.Coin: ServiceLocator.Register\u0026lt;IMoneyFormatConverter\u0026gt;(new CoinMoneyFormatConverter()); break; default: throw new System.NotImplementedException(); } moneyUI.Show(moneyValue); } } // 並在需要的地方跟容器取用 public class DemoBasicMoneyUI : MonoBehaviour { [SerializeField] private TMP_Text text; private IMoneyFormatConverter moneyFormatConverter; public void Show(int moneyValue) { moneyFormatConverter ??= ServiceLocator.Resolve\u0026lt;IMoneyFormatConverter\u0026gt;(); text.text = moneyFormatConverter.Convert(moneyValue); } } ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---service-locator/","tags":["Software Design","Pattern"],"title":"Software Design - Pattern - Service Locator"},{"contents":"設計目標 Google 以縮減線上影像的檔案大小為目標，同時維持不輸 JPEG、PNG、GIF 格式的圖片品質。\n網站的瀏覽與速度不僅影響使用者的耐心，也會影響 SEO 的排名與檢索，透過顯著縮減相片和圖形大小，網頁就能加快載入速度，提供更優質的使用者體驗。\n並持續在優化 WebP 2: experimental successor of the WebP image format\n壓縮方式 有損壓縮 無失真壓縮 Ref WebP 檔案 Now in REALITY Tech #6 画像をWebP形式に対応した話 Now in REALITY Tech #37 UnityでWebPを扱えるようにした話 ","permalink":"https://HoshikawaRyuukou.github.io/posts/network---webp/","tags":["Network"],"title":"Network - WebP"},{"contents":"以下觀點不一定適用於各專案，請因地制宜。\n在開始寫 code 之前 測試文化: 底下的人願意寫，上面的人願意給時間。 測試的順位: 從商業價值最高的功能開始。 較低的測試價值 需求尚未明朗又必須交付成果。 取決於經營者對價值的認定，其實跟程式沒多大關係。 不是所有的程式都可以測試，有時候為了測試，程式需要先重構成可以測試的樣子。 Unit Test 手動測試 慢 不穩定 脆弱 不方便 問題出在不可控\n希望是可控的 可重現一樣結果 以整體專案的角度來看單元測試 專案內分為 不可控 與 可控 兩部分\n不可控: 檔案/資料庫/第三方套件 可控: 除不可控以外自己所寫的部分 可控內分為 不可測 與 可測 兩部分\n不可測: 與不可控接觸的部分，因此會希望這部分越單純越好。 可測: 為專案內價值較高，須小心維護的部分。 目標: 可測範圍盡量大，不可測盡量小。\n單元測試相較於手動測試的優勢 ? 可以輕鬆的跑完多個 Test Cases Static 要不要測 ? 直接使用真實行為 透過測試框架強測 重構/隔離/依賴注入 Ref 一次搞懂單元測試、整合測試、端對端測試之間的差異 一起設計出可被單元測試的程式碼吧！ [Day 2]Unit Testing 簡介 .NET Core 和 .NET Standard 的單元測試最佳做法 ","permalink":"https://HoshikawaRyuukou.github.io/posts/test---note/","tags":["Test"],"title":"Test - Note"},{"contents":"用途 使用 C# 為 Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。 注意 Scripted Importer 無法處理已由 Unity 本身處理的文件擴展名。 Example 這裡將 .lua 以 TextAsset\nusing UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, \u0026#34;lua\u0026#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( \u0026#34;text\u0026#34;, subAsset ); ctx.SetMainObject( subAsset ); } } Ref Scripted Importers [Unity] 资源工作流程 - ScriptedImporter ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---editor---scriptedimporter/","tags":["Unity"],"title":"Unity - Editor - ScriptedImporter"},{"contents":"Package Samples 對應有些模組的操作比較複雜繁瑣，有時需要有一些 Sample 做參考。官方 Package Manager 有個 \u0026ldquo;半套\u0026rdquo; Sample 工作流，讓人不是很舒服。\n官方文件\nSample 資料夾後面加了波浪號 () 告訴 Unity 忽略 Samples 文件夾中的內容，此類文件夾不使用.meta文件進行跟踪。忽略 Samples~ 對 Package 使用者是好的，畢竟不是每個人都需要。\n但對 Package 開發者，畢竟 Samples 也是要進版控的，而這樣改名的作法會徒增一些重命名的提交也有點煩躁(除非在修改 Sample 的過程中完全不提交)。原先想說寫個 Samples ↔ Samples~ 切換的腳本就好，會一直有 meta 檔的警告(刪掉/改名都還是在)。\n官方作法 論壇中的某篇討論才記載他們的做法(倒是加到文件中阿\u0026hellip;)\n在內部確實使用了名為 Samples 的文件夾 (沒有 Samples~ ) 在推送新包版本之前通過腳本對其進行重命名(透過 CI ) OpenUPM 的作者也是使用類似的工作流，總之筆者也調整為上述的方式。\n透過 GitHub Actions Workflow 調整目錄名 筆者不熟 GitHub Actions/ YAML/ 文件操作，但這種初階的操作就交由 chatgpt 代勞，幫我省去不少實驗成本。這裡的操作只是堪用，應該有更好的方式。\n以下是筆者要求的條件\n想透過 GitHub Actions 中的 workflow 完成 如果 forPackage 分支已存在則將其刪除 從 main 建立新的 forPackage 分支 Assets/Modules 的所有子目錄(同時有 \u0026ldquo;package.json\u0026rdquo; 與 \u0026ldquo;Samples\u0026quot;資料夾)，將該子目錄的 \u0026ldquo;Samples資料夾\u0026rdquo; 重新命名 為 \u0026ldquo;Samples~資料夾\u0026rdquo; 並提交更新 將產出的 yml 做一點微調即可。主要文件操作的出錯率很高，find 指令似乎是有些眉角，等有空再回頭研究。\n想要連接到存儲庫的特定分支並下載特定目錄下的內容 最後調整一下訪問的格式即可。\n透過 Add package from git URL\nHTTPS_URL_Address?path=Target_Path#Branch\nHTTPS_URL_Address : https://github.com/user/repo.git Target_Path : Assets/Modules/Core 該目錄就是有 package.json 那層 #Branch : 指定分支是可選的 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package-manager---create-a-sample/","tags":["Unity","Package Manager"],"title":"Unity - Package Manager - Sample Workflow"},{"contents":"先備知識 Assembly Definition (Asmdef) Unity 2017.3 以上版本的提供功能，主要解決龐大的程序集編譯時效率問題。\n具體內容建議閱讀 Doc - Assembly definitions\nAssembly-CSharp.dll Unity 預設整合的 dll，專案內未被自定義 Asmdef 劃分的腳本都會被整合到 Assembly-CSharp.dll\n簡述 HybridCLR focus-creative-games/hybridclr focus-creative-games/hybridclr_trial HybridCLR 筆者已經應用於工作環境好一陣子了(從 2.X 版本開始)，其最讓人驚豔的地方在於，過往的開發流幾乎不用更動(當然要好 Asmdef 的規劃)，僅在打包時調整一下工作流即可。\n其極大簡化過往麻煩且效率不彰的熱更流程。xLua 和 ILRuntime 在筆者看來最難受的事是「侵入性」極強，搞得綁手綁腳。大家也都抱怨很久了，但也沒有其他可靠方案，直到 HybridCLR 出現。\n快速上手 3.0 版本後流程優化得更順暢了，照著 文件 可以很快地感受到其威力。\n注意 请问，Generate All、补充元数据的DLL更新的执行时机的最佳实践？ 怎么卸载热更dll CLI 規範中只能以 AppDomain 形式卸載所有 dll，不支持卸載單獨的 dll。而 il2cpp 是單例 AppDomain，因此這個要求是不符合規範的。要採用 HybridCLR DHE 的商業方案。不過筆者倒是不太擔心，畢竟 Unity client 通常不是需要常駐的應用，使用者也不太會把應用的每一個功能都點一遍，初估是還可以接受的。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---package---hybridclr/","tags":["Unity"],"title":"Unity - Package - HybridCLR"},{"contents":"用例 被標記為 DontDestroyOnLoad 的物件場景更改時不會被破壞。\n全域管理器：因為整個遊戲期間一直存在。例如，音效管理器、遊戲設定管理器或玩家數據管理器等物件可以在場景切換時保留，以確保它們的功能和數據在各個場景中持續存在。 持久性數據：如果你有需要在多個場景中共享的持久性數據，可以將存儲這些數據的物件標記為 DontDestroyOnLoad。例如，玩家的遊戲進度或全域的配置設置等數據可以在場景切換時保留，以便在不同場景中訪問和更新。 UI 元素：某些UI元素，如遊戲狀態面板、計時器或得分顯示，可能需要在多個場景中保留。通過將這些UI元素物件標記為 DontDestroyOnLoad，可以確保它們在場景切換時不會被銷毀，以便在不同場景中持續顯示和更新。 問題 記憶體管理問題：使用 DontDestroyOnLoad 將遊戲物件保留在多個場景中可能會導致記憶體洩漏。如果你的遊戲物件不再需要，但沒有被正確銷毀，它們將繼續存在於記憶體中，佔用系統資源，可能導致性能下降。 場景管理問題：DontDestroyOnLoad 會打破場景之間的清晰界限。場景是 Unity 中組織和管理遊戲邏輯的基本單位，每個場景都應該是相對獨立的。通過在多個場景之間保持物件，會增加場景之間的耦合性，導致代碼難以維護和測試。 Ref Object.DontDestroyOnLoad ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basic---dontdestroyonload/","tags":["Unity"],"title":"Unity - Basic - DontDestroyOnLoad"},{"contents":"Color 如何找出好配色？照著這個步驟做，讓你的設計更具吸引力！！ 什么是更好的渐变？ Color Tools Stocksy Adobe Color Canva VIVID GRADIENT GENERATOR TOOL ","permalink":"https://HoshikawaRyuukou.github.io/posts/visual-design---note/","tags":["Visual Design"],"title":"Visual Design - Note"},{"contents":"新手村 给画画爱好者的入门经验分享，当初有人告诉我该多好！ Community Pinterest Channel taco1704 hide channel【顔と体の描き方講座】 曲奇放克 Practice Line of Action Book ミニキャラの描き方　「ちまっとかわいい」を描く基本＆表現テクニック 分析 【舊版獵人】的美術真的強到爆嗎？用插畫家的角度來分析看看。 / HUNTER x HUNTER (1999) ","permalink":"https://HoshikawaRyuukou.github.io/posts/art---drawing---note/","tags":["Art"],"title":"Art - Drawing - Note"},{"contents":"Build repositories.cfg could not be loaded. Unable to find player assembly: XXXX\\Temp\\StagingArea\\Data\\Managed\\UnityEngine.TestRunner.dll Cocoapodsの更新にハマった【Unity】 Publish Privacy policy for your game? No problem! (generate and publish) Publish your UNITY game on Google Play Store - 2023 guide Misc Library not loaded: @rpath/FBAEMKit.framework/FBAEMKit ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---workflow---build--publish/","tags":["Unity"],"title":"Unity - WorkFlow - Build \u0026 Publish"},{"contents":"前述 首先幾篇文章是基於 Clean Architecture 的基礎，建議先閱讀以下連結已具備基礎知識\nThe missing chapter CA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture 連結 34章摘要心得，請先觀看裡面的圖表(重要) CA Modularization Multiple ways of defining Clean Architecture layers Package by Component with Clean Modules in Java Package by feature or component Vertical Slice Slices vs. Layers Restructuring to a Vertical Slice Architecture Vertical Slice Architecture, not Layers! Modular Monolith Majestic Modular Monoliths (強烈建議) Modular Monolith architecture (強烈建議讀完這個系列) 各 Package 策略的圖請參考上方連結 34 章摘要心得\nPackage By Layer 筆者在剛接觸 CA 時有一個很大的迷思是以為 CA Layers 一圈就是一個模組(如果應用程式複雜度不高，確實適用)，所以整個應用程式分三個模組。\nDomain Application Adapter 一開始功能不多時確實運作得很好，隨著功能的增加，出現了一個問題 共用，UseCase 可以操作所有的 Domain 與 Input/Output Port，責任開始變得紊亂(UseCase 知道太多細節)。我們需要一種更能反映業務功能的模組分法，使讓專案能夠重新 Screaming，以下是筆者比較常用的兩個演化方向。\nPackage By Component 僅提供服務，沒有 UI 操作。 定義 API 以隔離實作細節。 Package By Feature 負責提供使用者互動情境 (垂直切片)。 包含 UI 操作。 筆者在一個應用程式中多是這樣分成以下三類模組\nCore Module 一般以 Package By Component 的方式實作。 提供應用程式 內 共用的服務。 Core 可以是包含業務的 CA 分層，如下圖左邊。 Core 可以是僅將外部服務轉換至內部服務，如下圖右邊。 Feature Module 一般以 Package By Feature 的方式實作。 負責提供使用者體驗流。 可以使用 Core 提供的操作，必要時也可以引入所需的外部服務(仍需做 DIP)。 可能會有一個疑問是\nUseCase 中使用的介面( Core API )不是 Application 所定義的，這樣的依賴是否為有效 DIP ?\nDIP 的重點在於依賴於抽象(穩定)，因此只要 Feature 的活動範圍仍在此專案中，依賴 Core API 就是穩定的，外部變化會被擋於 Core 的內部實現中。\n實務上甚至可以考慮依賴組織級的 Core Module，是整個部門或者公司所共用的功能，基本上是比較泛用的功能才會這樣使用(聲音/廣告/日誌\u0026hellip;)。\nApp Module 依賴於所有模組。 應用程式的入口。 提供模組間的導航。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---modularization/","tags":["Software Design"],"title":"Software Design - Modularization"},{"contents":"Analysis Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Animation Introduction to 3D Animation Systems Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity Build repositories.cfg could not be loaded. unity Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Canvas Designing UI for Multiple Resolutions Unity Canvas Scaler 组件的使用 Unity分辨率适配方案设置 Editor 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them? EditorBuildSettings Example Material Unity中，UI反向Mask效果（图片挖洞） Screen How to capture the screen in Unity (3 methods) Text 【Unity编辑器扩展】艺术字/自定义图片字体生成工具 【Unity】自作フォントを作成してTextで表示する方法 Unity中自制UGUI艺术字体（位图字体）（Bitmap Font Generator） TextMeshPro TextMeshPro Anatomy [Unity干货]使用TextMeshPro动态字体节省时间 【Unity】TextMesh Proで数字をスプライト表示する UI 【Unity】3つだけでいい!?覚えるべきUIアンカー 【Unity基礎】スマホ向けゲームUIの作り方！基本的なUI配置から複数解像度対応まで解説 Master your Unity UI Buttons! - Unity UI tutorial How to scale Unity UI objects for every screen - Unity UI tutorial ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---basics/","tags":["Unity"],"title":"Unity - Basics"},{"contents":"Blog Yucchiy\u0026rsquo;s Note コガネブログ 老刘@开发笔记 (:3[kanのメモ帳] Game Dev Beginner - Everyone Can Make Games LIGHT11 PG日誌 きゅぶろぐ やらなイカ？ はなちるのマイノート くものす ピクセルブログ ねこじゃらシティ YAMADA TAISHI’s diary 原カバンは鞄のお店ではありません。 L\u0026rsquo;s Blog Raspberlyのブログ 渋谷ほととぎす通信 LianBai Real-Man Lightjiao的博客 unityでいってみよう！ 偵錯桐人 - unity Blog (Enterprise) CyberAgent Developers Blog | サイバーエージェント デベロッパーズブログ REALITY｜note Mirrativ Tech Blog QualiArtsエンジニアブログ Channel Code Monkey M Studio Coco Code Collection XINCGer/Unity3DTraining Forum Qiita|Unity Zenn|Unity Unity Learning Materials Unity3d - 幻想社区 「unity」の人気の記事一覧｜note Unityゲーム開発者ギルド Events Unity Meetup Unity Advent Calendar Unityユースクリエイターカップ Community unityroom ","permalink":"https://HoshikawaRyuukou.github.io/posts/unity---sites/","tags":["Unity"],"title":"Unity - Sites"},{"contents":"以下 Clean Architecture 簡稱 CA\n這裡還是先引用 Uncle Bob 的分層圖 The Clean Code Blog - The Clean Architecture 筆者認爲可擴展性是系統架構的重要考量。畢竟應用程式會演化，必須不斷更新與修改系統以滿足新的需求，而 CA 是其中一種實現方針。筆者在這裡不會寫出詳細的介紹，想了解的可以參考 Ref 整理的連結或是 CA 相關書籍。\n本文著重於促使筆者思考方式改變的幾個重要觀念。\n依賴關係 相依性: 向內圈依賴，且盡量避免跨層依賴 (有些例外之後說明)。 Dependency Inversion Principle (DIP): 內圈定義介面，外圈實作。 基於這兩個規則所帶來的是\n單向依賴流 : 紊亂的依賴流可能造成牽一髮動全身的窘境。尤其是當 Domain 去依賴到細節時。 延後實作 : UseCase/Adapter 都是依賴於應用層所開出的介面。因此業務/畫面能獨立開發，不用互相等待(理想狀態)。 而筆者在實作時的基本型架構通常如下圖(比較接近 CA 書中的另外一張圖，我這裡做了簡化)，Adapter 只分成 Input/Output Port。 Domain: 領域邏輯 UseCase: 應用邏輯 Domain + UseCase: 業務邏輯 InputPort: 用例功能使用方介面 OutputPort: 用例功能支援方介面 Adapter: 將外部與用例功能接合的膠水代碼 不過架構會針對不同情況做調整，細節參考另一篇文章\n架構設計 - Clean Architecture and Modularization\n此外在原著中的定義描述\nEntities 使用 enterprise wide business rules UseCases 使用 application specific business rules 業務邏輯 | 商業邏輯 | 領域邏輯，如果你常在爬文，這幾個詞彙被混用的非常厲害，不同專業領域都有自己的一套說法。筆者的分法是參考 Link。\n依賴關係 (跨層) 發生於 Data Access 的部分，DataAccess 介面簽名上是看的到 Entity 的。筆者參考很多評論覺得這是可以接受的，因為 \u0026ldquo;上下文單純\u0026rdquo;，Data Access Impl 只處理持久化物件與 Entity 之間的轉換，不做其他操作。\nUse Case 用例是應用程式的說明書，可以很清楚的看到整個應用程式能做那些事，設種設計風格也稱作 尖叫的架構 (Screaming Architecture)。\n筆者直接感受到的好處是當業務發生變化時可以很快知道要改哪裡。\n定義 做什麼 而不是 如何做，透過介面隱藏實作細節 業務流集中於一個地方，決定輸入/輸出 以下有一些 FAQ\n用例可以依賴其他用例嗎?\n可以但盡量避免，共用的用例筆者會盡量保持 Internal。 用例與領域的界線開始變得很模糊，且彼此滲透。\n隨者應用需求不斷演化，也需重新評估 Domain(分割或合併)。此外當業務複雜度足夠高時，可以考慮導入 DDD(Domain-Driven Design)，領域事件/聚合也許能幫助 Domain 更加內聚。 InputPort 有必要嗎? 依賴方向本來就向內\n當用例需要被抽象時是需要的，如果沒有那種需求不做也無妨。但為了統一般筆者基本上還是會寫。 用例似乎有很多種風格的寫法\n確實常見的有 2 種: Service方法集 / CQRS風格 Adapter 筆者之前對套件更換這件事是感到非常棘手的，好像每次更換都有劇烈的不適，直到知道透過 DIP + Adapter 可以把不安定要素(Presentation/Database/Service)安置在應用程式的最外緣。完全改變實現是非常容易的，因為它對業務邏輯沒有影響。\nRef Overview 概述，這些文章在對於從未知入門的人來說，圖表與條列項，可以為他們先指出一些方向。\nSoftware Architecture - Clean Architecture Clean Architecture Guide 以下參考著重在觀念引導，再加上實例輔助，必須說這些參考文都要包含\u0026quot;自己的理解\u0026quot;閱讀價值才得以顯現。\nGetting Started With Clean Architecture for Android [Part 1] Clean Architecture on Frontend Clean Architecture の勘所は『鎖国』だ。 Unityを利用した大規模なゲーム開発にクリーンアーキテクチャを採用した話 Discussion 以下參考著重觀念釐清，初期探索採坑的地方與一些討論串。\nClean Architecture Guide (with tested examples): Data Flow != Dependency Rule Why data layer has a dependency on the domain layer? Do Interactors in \u0026ldquo;clean architecture\u0026rdquo; violate the Single Responsibility Principle? Layer for Managers and Services that require Android Context Why you need Use Cases/Interactors What is the use of DTO instead of Entity? Clean Architecture: Use case containing the presenter or returning data? How to make the controller framework independent in Clean Architecture? Clean architecture - where to put input validation logic? How to pass the android dependent data from data-layer to presentation-layer Notes 一些 CA 的閱讀心得。\nClean architecture for the rest of us Clean Architecture - notebook serodriguez68/clean-architecture Repo igorwojda/android-showcase ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---architecture---clean-architecture/","tags":["Software Design","Architecture"],"title":"Software Design - Architecture - Clean Architecture"},{"contents":"GUI Clients Fork Common 两小时Git教程 Git忽略规则.gitignore不生效 配置 Git 处理行结束符 Workflow 如何做好分支管理，保证高效CI/CD？ 【GeekHour教程】分支管理和工作流模型 Git 進階應用 Submodule 與 Subtree，使用它們來拆分專案 Operation git revert 是如何让你丢失代码的？ 十分钟学会常用git撤销操作，全面掌握git的时光机 How effectively delete a git submodule. Git cherry pick a commit to another repo git hook git hook 是每次執行 git 操作時都會運行的命令或腳本。 如果 git hook 的執行失敗，則 git 操作將中止。 ","permalink":"https://HoshikawaRyuukou.github.io/posts/git---note/","tags":["Git"],"title":"Git - Note"},{"contents":"Profile 如何建立獨一無二的 GitHub Profile！與三個很酷的設計及應用 tandpfun/skill-icons Collaboration 十分钟学会正确的github工作流，和开源作者们使用同一套流程 GitHub Copilot VS Code 中的 GitHub Copilot GitHub Actions GitHub Actions 文档 GitHub Marketplace GitHub Actions: Limit which branches can deploy to an environment GitHub Packages GitHub Packages 文档 ","permalink":"https://HoshikawaRyuukou.github.io/posts/github---note/","tags":["Github"],"title":"Github - Note"},{"contents":"目的 符合 Fail Fast 的原則，驗證條件並在不滿足條件時立即停止執行。 增加可讀性(更扁平)，減少了巢狀判斷。 例子請參考 Guard Clause Extra - Guard Class 將通用的保護子句封裝在一個專門的類是一種很好的做法，可重用邏輯並編寫更具可讀性的保護子句。\n可參考這個庫 GuardClauses Extra - Value Object Stop using trivial Guard Clauses! Try this instead\n文章作者避免瑣碎 Guard 的方式，是使用 Value Object，來避免域接受到無效參數。這個作法在筆者看來才是真正意義上的 Fail Fast。(YT評論區也建議閱讀，有許多不錯的討論)\n但不可否認的 Guard Clause 作法在大多情況下是有益的。\nRef Guard Clause Implementation Patterns: Guard Clause GuardClauses Stop using trivial Guard Clauses! Try this instead ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---guard-clauses/","tags":["Software Design","Pattern"],"title":"Software Design - Pattern - Guard Clauses"},{"contents":"語法 C# 的一些冷知识（其一） C# 的一些冷知识（其二） 捨棄 - C# 基本概念 C#中 ??、 ?、 ?: 、?.、?[ ] 问号 Type C# 4.0：Covariance 與 Contravariance 觀念入門 Data Different ways to return data in C# ValueTuple ValueTuple 是 value type，所以它使用的記憶體空間使用在 program stack，因此使用不會有 garbage collection\nFormat 內插字串 Collection C# 回傳內部資料集合的幾種方式，考慮封裝與設計需求 Iterate over two collections of equal length foreach (var (cell, id) in cells.Zip(randomizedIDs, (key, value) =\u0026gt; (Cell: key, ID: value))) { idDict[cell] = id; cell.selectCallback = Select; } Utils Random var random_list = list.OrderBy(i =\u0026gt; Guid.NewGuid()).ToList(); Other C# 記憶體管理 Value Type 與 Reference Type 工作十余年，还是一直被问 委托和事件 有什么区别？ 真是够了 ","permalink":"https://HoshikawaRyuukou.github.io/posts/csharp---note/","tags":["CSharp"],"title":"CSharp - Note"},{"contents":" 【白话科普】域名？网址？原来域名是这么个玩意啊！ DNS工作原理 | 什么是DNS 它如何工作 CDN是什么 | CDN的工作机制 数字签名和CA数字证书的核心原理和作用 VPN概念，技术原理和误区 哈希究竟代表什么？哈希表和哈希函数的核心原理 交换机的核心工作原理 | 集线器、2层交换机和3层交换机的主要区别 你管这破玩意叫网络？ 从设计者的思考角度出发理解网络，合理、靠谱！ ","permalink":"https://HoshikawaRyuukou.github.io/posts/network---note/","tags":["Network"],"title":"Network - Note"},{"contents":"必須先聲明筆者仍在學習中，以下屬個人觀點\n動機 筆者發現在使用 Clean Architecture (CA) 時越來越力不從心，因此開始研究 Domain-Driven Design (DDD)，事出有因，列出幾點問題與對應方式。\n重複的程式碼 主因是 貧血域模型 (Anemic Domain Model)，表示模型中幾乎只有 Get/Set，這導致了 Domain層 (業務邏輯) 滲透到 Application層 (應用邏輯)，某些對 Domain 的操作重複出現在多個的 Usecase (應用邏輯)。 重新分析系統，區分出不同上下文，設計充血域模型，將業務邏輯設計進去。 域模型的一致性問題 Domain 面對四面八方的操作，顯得很亂且充滿不確定(會不會模型之間的關係因為更改而被破壞) 引入聚合(Aggregate)來維持保護邊界內的不變條件。 Primitive Obsession 這會造成對模型的不信任，進而寫出一些防禦性程式設計。 引入值物件(Value Object)來確保不變性與自我驗證(即不正確就不應該存在)。 以上這幾點是筆者比較有感的。\n概述與想法 Domain-Driven Design (DDD)，出自 Eric Evans 2003 年出版的一本書，以領域模型為中心來進行系統的分析設計。不是架構也不是技術，是一種方法論，可以搭配不同類型的架構來實現\nLayered Architecture Hexagonal Architecture Clean Architecture (以下稱 CA ) Command Query Responsibility Segregation (CQRS) 原著中是使用 Layered Architecture 的架構作為示範，但該章的重點是在隔離 Domain，在 Google 的時候有所謂 \u0026ldquo;DDD 架構圖\u0026rdquo;，但筆者覺得不太精確，因為 DDD 主要的發力點是在 Domain，應該稱作 \u0026ldquo;OO架構以DDD實作Domain\u0026rdquo; 會比較合適。\nDDD 的設計流程又分成兩的階段\n戰略設計 (Strategic Design) 與\u0026quot;領域專家\u0026quot;積極交流分析的時候。先來個狀況劇:\n根據 Q1 這個需求開發人員們 開發人員 A: 應該 這樣-\u0026gt;這樣-\u0026gt;那樣-\u0026gt;那樣-\u0026gt;那樣 開發人員 B: 應該 這樣-\u0026gt;那樣-\u0026gt;那樣-\u0026gt;這樣 \u0026hellip; 領域專家: 喔喔 這個阿 就-\u0026gt; 那樣-\u0026gt;這樣 然後簡訊通知就好了，畢竟發生頻率很低\n領域專家是每天都在處理這類事務或最瞭解這類情境的人，因此有疑問時詢問領域專家是很重要的，免得外行在那邊猜半天徒增複雜度。開發人員與領域專家互動的終極目標就是共同語言(Uniquitous Language)，透過這個語言進行交流。確保最終設計出來的東西，有達到雙方想要的結果。\n戰術設計 (Tactical Design) 架構師/工程師展現設計工法的時候\nEntity Value Object Aggregate Domain Event Service Design Patterns 總結 但產品是會演化的，需求會改變，Domain 會改變，所以戰略設計與戰術設計這兩階段是會不斷迭代。\n筆者覺得 戰略設計/戰術設計 完全符合 80/20法則，之前完全不去分析域，一股腦地將戰術設計套進專案中，但還是覺得卡卡的。解決發散的域邏輯，還是較為優先。\n開發出來的軟體是能夠準確表達業務規則，以達到程式\u0026lt;=\u0026gt;業務是同構的。筆者感覺這個是 DDD 的根本價值。\nRef [Domain-Driven Design: Tackling Complexity in the Heart of Software] 理解領域驅動設計 DDD is not architecture ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---domain-driven-design/","tags":["Software Design"],"title":"Software Design - Domain-Driven Design 初探"},{"contents":"什麼是 DTO？ Data Transfer Object (數據傳輸對象) 是定義如何在應用程序之間發送數據的對象。它僅用於發送和接收數據，本身不包含任何業務邏輯。\n為什麼使用 DTO？ 輕鬆收發 在沒有任何邏輯的基礎上，可以僅使用序列化與反序列化就保證對象的完整性和可傳遞性。\n避免過度暴露訊息 對分層或模組來說，彼此間應盡量降低耦合。下圖以公園廁所報修為案例。\n這個資料流由鄉公所傳到基層人員手上，中間經過兩個邊界\n鄉公所 | 工程公司 =\u0026gt; DTO (公文) 工程公司 | 基層人員 =\u0026gt; DTO (簡訊) 每個單位的關注點不同，在意的資料也會不同，DTO 做為邊界兩方做最小程度的媒介，隱藏的不該被關注(敏感)的事\n印章對工程公司並不是必要資訊 詳細的時間格式是對基層人員並不是必要資訊 在實作上常被用於轉換 DomainModol -\u0026gt; DomainDto\n注意事項 類別數量增加，請自行評估使用情形\nRef Cutting Edge - Pros and Cons of Data Transfer Objects The DTO (Data Transfer Object) Data Transfer Objects Clean Architecture : why not using the entity as request model of the use case (interactor) Difference between Entity and DTO ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---data-transfer-object-dto/","tags":["Software Design","Pattern"],"title":"Software Design - Pattern - Data Transfer Object (DTO)"},{"contents":"前述 關注點分離（Separation of Concerns，SoC）: 在軟體開發中，一個模組或組件應該專注於解決特定的問題，而不是同時處理多個功能。每個組件都有自己的職責範圍，並且與其他組件盡可能解耦合。\n而 MVC / MVP / MVVM 是關注點分離於前端的經典應用，網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對此感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列的發展。\n界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 【Unity】MV(R)Pパターンのすすめ Unravelling MVC, MVP and MVVM 以下則對筆者實作中比較常用的 MVP 多做一些討論\n關注點(責任) 在 MVP 的構成下分成三個部分\nModel: 應用程式的核心邏輯。 View: 應用程式的使用者介面，負責呈現數據和接收使用者的輸入。 Presenter: View 和 Model 之間的中介。 Passive View 這是 MVP 的一種實作風格，也是筆者主要使用的風格。\nPresenter 對 View 有完全控制權 View 提供方法與事件給 Presenter 使用 View 對 Presenter 一無所知 以猜拳遊戲的 View 為例\npublic class View : MonoBehaviour { [SerializeField] private Text messageText; [SerializeField] private Button[] playerChoices; [SerializeField] private Button nextButton; private readonly Subject\u0026lt;Choice\u0026gt; playerChoiceSelected = new Subject\u0026lt;Choice\u0026gt;(); private readonly CompositeDisposable disposables = new CompositeDisposable(); public IObservable\u0026lt;Choice\u0026gt; PlayerChoiceSelected =\u0026gt; playerChoiceSelected; public IObservable\u0026lt;Unit\u0026gt; PlayerNextRequested =\u0026gt; nextButton.onClick.AsObservable(); void Awake() { disposables.Clear(); playerChoices[0].onClick.AsObservable().Subscribe(_ =\u0026gt; SelecteChoice(Choice.Rock)).AddTo(disposables); playerChoices[1].onClick.AsObservable().Subscribe(_ =\u0026gt; SelecteChoice(Choice.Paper)).AddTo(disposables); playerChoices[2].onClick.AsObservable().Subscribe(_ =\u0026gt; SelecteChoice(Choice.Scissors)).AddTo(disposables); } void OnDestroy() { disposables.Clear(); } public void SetReady(string message) { messageText.text = message; nextButton.gameObject.SetActive(false); } public void SetResult(string message) { messageText.text = message; nextButton.gameObject.SetActive(true); } private void SelecteChoice(Choice choice) { playerChoiceSelected.OnNext(choice); } } 依賴關係 依據不同的情境有兩種依賴關係\n(左) 定義 IView 介面\n著重在保持 Presenter 的控制邏輯 Presenter 依賴於 IView 介面 主要應用於有換皮需求的 View (右) 直接使用 View\n著重在保持 View 的獨立性(可能有跨專案需求) Presenter 直接依賴 View Presenter 基本與 View 綁定 ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---pattern---model-view-presenter-mvp/","tags":["Software Design","Pattern"],"title":"Software Design - Pattern - Model View Presenter (MVP)"},{"contents":"Audio 魔王魂 効果音ラボ フリーBGM（音楽素材）無料ダウンロード｜DOVA-SYNDROME フリー効果音素材・無料効果音 Color Coolors Palettable Feature Graphics Google Play Feature Graphics Font 中文免費字體 Google Fonts 2022/0113更新# 36個合法免費高品質字體 fontget Icon ICOOON MONO iconmonstr Flaticon IconKitchen Game-icons.net Image Unsplash Image API | Free HD Photo API Lorem Picsum Photosku 2023 熱門 47 個可商用無版權免費圖庫懶人包（圖片、圖示、圖標、素材、背景） OKUMONO Misc Opengameart Kenney かわいいフリー素材集 いらすとや Textures Poly Haven Tools 網路資源列表| DeTools Repo itch.io ","permalink":"https://HoshikawaRyuukou.github.io/posts/assets---note/","tags":["Assets"],"title":"Assets - Note"},{"contents":"以下 Feature 指的是一個功能獨立的模組，Feature A 將簡稱 A。\n問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任?\n以下先討論 2 種狀況。\nA 直接依賴 B 簡單粗暴的強耦合破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。\nFeature A -\u0026gt; Feature B A 引入導航器間接依賴 B 這作法將導航操作收斂到某個類中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。\nFeature A -\u0026gt; INavigator.Route(View.FeatureB) // Enum or Feature A -\u0026gt; INavigator.Route(\u0026#34;FeatureB\u0026#34;) // 魔術字串 or Feature A -\u0026gt; INavigator.RouteFeatureB() 重新思考導航這件事\nFeature 應該知道自己是能夠 被導航 或是 能導航到哪 嗎? 到底 A 能導航到 B 這件事是誰決定的? 應該隱約地感覺到了吧，導航並不屬於 A 也不屬於 B，導航是一個獨立操作，需要一個額外的單位來負責。此外這個單位多是屬於 App 級別的(因為該層級有對其他模組的正當訪問性，畢竟是負責做統合的)。\nNavigation 有以下核心概念\nFeature 對導航一無所知 (因此也不知道其他 Feature 的存在) Feature 只是向外告知自己的狀態(透過介面/觀察者/事件\u0026hellip;) 並使用 中介者模式 (Mediator pattern) 來處理 Features 之間的關係 也就是將模組的依賴關係轉成下方這張圖 以 FeatureA 定義介面並呼叫，Navigator 實作介面為例 (觀察者/事件 相對好實作，相信大家有能力自己應用。介面的寫法比較繞，所以特別寫出來)\n//注意命名空間! namespace App.Features.FeatureA.Presentation { public interface IClassicGameNavigator { UniTaskVoid NavigateBack(); } public class GameController { private readonly IFeatureANavigator navigator; ... private void Exit() { navigator.NavigateBack(); } } } //注意命名空間! 導航是自己獨立的模組 namespace App.Navigators { public class FeatureANavigator : IFeatureANavigator { private readonly IFeatureLoader featureLoader; ... public async UniTaskVoid NavigateBack() { await featureLoader.Unload(FeatureKeys.FeatureA); await featureLoader.Load(FeatureKeys.Lobby); } } } Extra 有注意到 Loading Screen (Transition 也是導航的一部分) 是誰在控制的嗎? 如果是 A 或 B，那現在也許有個更適合的位置!\nnamespace App.Navigators { public class AppNavigator { private readonly IFeatureLoader featureLoader; private readonly ILoadingScreen loadingScreen; public AppNavigator(IFeatureLoader featureLoader, ILoadingScreen loadingScreen) { this.featureLoader = featureLoader; this.loadingScreen = loadingScreen; } public async UniTaskVoid NavigateToLobby() { await loadingScreen.FadeInAsync(); await featureLoader.Load(App.FeatureKeys.Lobby); await loadingScreen.FadeOutAsync(); } } } 總結 找一個單位為導航負責 流程發生變化時易於修改(集中/可組合) 建議配合 DI 操作，將實例化複雜度排除在流程控制外 Repo 使用相同概念的庫，星數都破千可以安心嘗試/觀摩。\nRxFlow XCoordinator Reference 這種模式有很多名字 Coordinator/ FlowController/ Navigator，但觀念都雷同。連結都值得閱讀，多半都有作者們的想法與反思，也許閱讀後會有新的理解。此外大家的開發環境不同，需要自行做些調整(精簡或強化)。建議照順序閱讀以下連結。\nThe Coordinator In-App Navigation with Coordinators Architecting iOS apps: Coordinators Coordinator and FlowController Coordinators Essential tutorial. Part I Coordinators on Android: how to build flows quickly with reusable screens MVVM + Coordinators + RxSwift and sample iOS application with authentication How to pass data between views using Coordinator pattern in Swift Navigators Part 1: a Flow-Based Architecture for Android 【画面遷移はUIKitに】SwiftUIにおけるFlowControllerを解説！ Extra Introducing Nibel: A Navigation Library for Adopting Jetpack Compose in Fragment-Based Apps ","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---navigation/","tags":["Software Design"],"title":"Software Design - Navigation"},{"contents":"依賴倒置原則 Dependency Inversion Principle，以下皆簡稱 DIP。\n為什麼需要 先來看定義\n高層次的模塊不應該依賴於低層次的模塊，兩者都應該依賴於抽象接口 抽象接口不應該依賴於具體實現。而具體實現則應該依賴於抽象接口 文謅謅的，但重點似乎是抽象。不如直接看個狀況劇:\n有一個 Project A 需要使用播廣告的功能。分別採 2 個做法\n直接依賴 直覺的做法。Project A 直接依賴於廣告模組(UnityAds)，這裡模組 Project A 被迫去了解 UnityAds 的實作細節(怎麼初始化/下載廣告/播廣告)。\n目前沒甚麼問題，運作得很好\u0026hellip; 但很快問題就來了。UnityAds 因為某些原因不能用了! (假設後臺被打了什麼的)。於是找了另一個廣告模組(AdMob)，想要如法炮製，但有幾點可能會不好受。\n要改的地方很分散 (廣告被 Project A 多處使用) Project A 需要處理不同的 API格式 (了解細節，單例、Callback、事件\u0026hellip;) 導致原先依賴 UnityAds 的模組需要重新編譯 (造成浪費時間) 原因是直接依賴外部模組導致的，相對於你的系統 UnityAds 是個外人，是不穩定的，去依賴一個不穩定的東西，也會導致自己變得不穩定。\n依賴倒置 仔細想一下，Project A 直接依賴 UnityAds 是必要的嗎? 需求是播 UnityAds 的廣告? 還是播廣告? 為了實現穩定廣告服務的依賴源，我們將其抽象化\npublic interface IAdService { void Initialize(); void Load(); void Show(); } 但 UnityAds 與 AdMob 又不能直接實作這個介面怎麼辦，可以用配接器模式(Adapter Pattern)寫個轉接頭，想辦法讓外部細節符合 IAdService 的需求。現在需要廣告服務的部分均透過 IAdService來操作，不需再知道外部廣告模組的細節。\n無效的 DIP 雖然 Project A 依賴了介面，但那介面是 Ad Module 所提供的，仍然是直接使用外部細節。這個陷阱在於 Interface 的位置，這在學習前期坑了我好大一跤，當時倒置了一堆無用接口\u0026hellip;\n注意 做 DIP 是為了未來替換時降低傷害，如果沒有替換需求則未必要採用。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/software-design---principle---dependency-inversion-principle-dip/","tags":["Software Design","Principle"],"title":"Software Design - Principle - Dependency Inversion Principle (DIP)"},{"contents":"RPC (Remote Procedure Call，遠端程序呼叫) 是一種通信協定，多用於分佈式系統的通信。\n目的 讓客戶端呼叫遠程函式就像呼叫本地函式一樣。將網路通信封裝成函式來使用，那麼客戶端將不需要關心網路協定/模型。\n流程 client 客戶端通過本地呼叫的方式呼叫服務 client stub 接收到請求後將參數序列化成能夠進行網路傳輸的訊息體 client stub 找到服務地址，並將訊息發送給服務端 server stub 收到訊息後進行反序列化 server stub 根據反序列化結果呼叫本地服務 本地服務執行並將處理結果返回給 server stub server stub 將結果序列化並發送至 client stub client stub 接收到訊息，並進行反序列化 client 得到最終結果 Ref 怎么理解rpc，既然有http请求了为啥还要用rpc？ 谁能用通俗的语言解释一下什么是 RPC 框架？ ","permalink":"https://HoshikawaRyuukou.github.io/posts/network---rpc/","tags":["Network"],"title":"Network - RPC"},{"contents":"問題 - 忒修斯之船 1世紀時的希臘作家普魯塔克問到\n如果忒修斯的船上的木頭逐漸被替換，直到所有的木頭都不是原來的木頭，那這艘船還是原來的那艘船嗎？\n思考 這艘船在被賦予存在意義之前，就不過是一堆木頭與金屬，如果沒有使用他的人，那麼船將沒有他的意義。因此只要賦予它存在意義的人還在，或者說這份存在意義能夠被繼承下去，無論它變成什麼樣子，它還是那艘船。\n","permalink":"https://HoshikawaRyuukou.github.io/posts/philosophy---ship-of-theseus/","tags":["Philosophy"],"title":"Philosophy - Ship of Theseus"},{"contents":"Github: HoshikawaRyuukou\n","permalink":"https://HoshikawaRyuukou.github.io/about/","tags":null,"title":"About me"},{"contents":"This is the search page, type keywords to search among my articles.\n","permalink":"https://HoshikawaRyuukou.github.io/search/","tags":null,"title":"Search"}]