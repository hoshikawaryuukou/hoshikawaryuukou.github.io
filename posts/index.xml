<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/posts/</link><description>Recent content in Posts on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Tue, 29 Oct 2024 13:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>HackMD - Note</title><link>https://HoshikawaRyuukou.github.io/posts/hackmd-note/</link><pubDate>Tue, 29 Oct 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/hackmd-note/</guid><description>Quick Chat HackMD 的核心思想是
輕鬆使用 Markdown 協作文件的工具
符合的筆者的使用需求
免費方案適合輕度用戶 跨平台兼容性（桌面/移動設備） 支援 Markdown 格式 文件管理（標籤/搜索功能） 分享控制（私人/公開） 支援遠端同步 付費方案差異
多人協作人數 文件大小限制 版本控制 API 接入 Guide HackMD：協作 Markdown 文件，分享知識的平台 HackMD 使用教學 HackMD 快速入門教學 用 HackMD 做簡報 Slide-example</description></item><item><title>exiftool - Note</title><link>https://HoshikawaRyuukou.github.io/posts/exiftool-note/</link><pubDate>Sun, 27 Oct 2024 21:13:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/exiftool-note/</guid><description>Case - source 覆蓋 target exiftool -overwrite_original -all= target.png exiftool -tagsFromFile source.png -all:all target.png</description></item><item><title>Tools</title><link>https://HoshikawaRyuukou.github.io/posts/tools/</link><pubDate>Sun, 27 Oct 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/tools/</guid><description>Antivirus DefenderUI Diagram 只會用 Office 畫流程圖？許多人試用過這個後直呼回不去了 👍 | Draw.io 教學 Document HackMD：協作 Markdown 文件，分享知識的平台 File-Sharing HFS: HTTP File Server (version 3) Media VLC media player 如何安裝FFmpeg ScreenToGif Twitter 影片下載器 Tyrrrz/YoutubeDownloader mifi/lossless-cut Message Emojipedia Translation Saladict 沙拉查词 BallonsTranslator Speech to Text jianchang512/stt Simulation taojy123/KeymouseGo Others 史上最簡單「一頁式網站」建置工具！ | Google Sites 協作平台快速上手 Code Image Spritesheet Cutter</description></item><item><title>Game Design - System</title><link>https://HoshikawaRyuukou.github.io/posts/game-design-system/</link><pubDate>Fri, 25 Oct 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/game-design-system/</guid><description>戰鬥 探讨服务端回合制战斗系统 技能 一种易扩展游戏技能系统的实现方案 如何设计技能系统 場景 樓梯是如何成為遊戲界難題的？拆解鳴潮和絕區零的解決方案</description></item><item><title>Software Development - Repository Structure - monorepo</title><link>https://HoshikawaRyuukou.github.io/posts/software-development-repository-structure-monorepo/</link><pubDate>Wed, 23 Oct 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-development-repository-structure-monorepo/</guid><description>Guide Monorepo：让你的项目脱胎换骨，既能代码复用，又能独立部署！ Config Boost your productivity with TypeScript project references An actual complete guide to typescript monorepos TypeScript project references Template jkomyno/pnpm-monorepo-template bakeruk/modern-typescript-monorepo-example firxworx/fx-pnpm-monorepo-starter limuen/monorepo-project ixahmedxi/orbitkit</description></item><item><title>Javascript_TypeScript - Package - rimraf</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-rimraf/</link><pubDate>Tue, 22 Oct 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-rimraf/</guid><description>Quick Chat rimraf 是一個用於遞迴刪除文件或目錄的 Node.js 庫，類似於 Unix 上的 rm -rf 命令。它的主要功能是跨平台刪除文件和文件夾，特別適合在 Windows 和 Unix 系統上使用。
Guide isaacs/rimraf Rimraf详细介绍 Install pnpm add -D rimraf Usage 單個文件 pnpm rimraf file.txt 單個目錄 pnpm rimraf folder 複數目標 pnpm rimraf folder1 folder2 file.txt 匹配目標 pnpm rimraf --glob &amp;#34;./**/index.js&amp;#34; 透過 scripts command 執行 { &amp;#34;scripts&amp;#34;: { &amp;#34;clean&amp;#34;: &amp;#34;rimraf dist&amp;#34; } }</description></item><item><title>Javascript_TypeScript - Package - workerpool</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-workerpool/</link><pubDate>Tue, 22 Oct 2024 08:12:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-workerpool/</guid><description>Quick Chat 整合 Web Workers 與 worker_threads，因此支援瀏覽器和 Node.js。 API 設計直觀(管理工作線程、訊息傳遞和錯誤處理)。 實現 worker pool 管理功能。 支援 Promise 與 async/await。 Guide workerpool Vite Workerpool Example Other Nest.js - Worker threads 잘 사용해보기 NestJS Dependency Injection in Worker Threads https://github.com/vitest-dev/vitest/issues/5757#issuecomment-2146013141 https://github.com/nodejs/node/issues/47747</description></item><item><title>Workflow - Send messages to Telegram via GitHub Actions</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-send-messages-to-telegram-via-github-actions/</link><pubDate>Sat, 19 Oct 2024 19:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-send-messages-to-telegram-via-github-actions/</guid><description>Quick Chat 以下範例為 :
在 git push 後透過 Github Actions 將 tag + commit 訊息發送到指定的 Telegram 群組
設置 Telegram Bot 在 Telegram 中搜尋 @BotFather 並建立一個新的 bot，記下 API token。 將 bot 加入群組並發送訊息給 bot 使用 https://api.telegram.org/bot&amp;lt;YourBotToken&amp;gt;/getUpdates 來獲取群組 ID。 設置 GitHub Secrets GitHub 專案中
Settings -&amp;gt; Security -&amp;gt; Secrets and variables -&amp;gt; Actions -&amp;gt; Repository secrets
新增以下 secrets :
TELEGRAM_BOT_TOKEN : Telegram Bot Token TELEGRAM_CHAT_ID : Telegram 群組 ID 設置 GitHub Variables GitHub 專案中</description></item><item><title>Javascript_TypeScript - Package - lint-staged</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-lint-staged/</link><pubDate>Fri, 18 Oct 2024 08:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-lint-staged/</guid><description>Quick Chat lint-staged 可以只對 git staged 的檔案執行 lint 處理，進而提升檢查效率。
Guide lint-staged/lint-staged Notice ⚠️ 這裡與 simple-git-hooks 搭配使用 ⚠️ 跟 Prettier 搭配使用，必須確保 ESLint 在 Prettier 前面先執行 Install pnpm add -D lint-staged Config package.json { &amp;#34;lint-staged&amp;#34;: { &amp;#34;*.{js,json}&amp;#34;: [ &amp;#34;prettier --write&amp;#34; ], &amp;#34;*.ts?(x)&amp;#34;: [ &amp;#34;eslint --fix&amp;#34;, &amp;#34;prettier --parser=typescript --write&amp;#34; ] } } Usage pnpm lint-staged</description></item><item><title>Javascript_TypeScript - Package - ESLint</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-eslint/</link><pubDate>Thu, 17 Oct 2024 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-eslint/</guid><description>Quick Chat ESLint 是一個用來檢查和修復 JavaScript/TypeScript 程式碼風格和潛在錯誤的工具，幫助維持一致性和提高程式碼品質。它可以根據自訂規則或預設的最佳實踐規則來進行靜態分析。
Guide eslint/eslint ESLint - Pluggable JavaScript Linter Using the New ESLint Flat Config 仕組みと嬉しさから理解するeslint FlatConfig対応 Notice ⚠️ ESLint 正逐步廢除格式化規則 - Deprecation of formatting rules。 ⚠️ 官方建議使用 Prettier 作為格式化方案。 Install pnpm create @eslint/config@latest Extension vscode extension .vscode/extension.json { &amp;#34;recommendations&amp;#34;: [&amp;#34;dbaeumer.vscode-eslint&amp;#34;] } Config eslint.config.js - 使用純 JavaScript 編寫配置，以便支持更好的導入導出。 使用一個純陣列來定義所有的規則和配置，避免了多層嵌套的問題。 後面出現的配置會覆蓋前面的配置。 eslint.config.js import pluginJs from &amp;#39;@eslint/js&amp;#39;; import tseslint from &amp;#39;typescript-eslint&amp;#39;; export default [ { name: &amp;#39;all&amp;#39;, files: [&amp;#39;**/*.</description></item><item><title>Javascript_TypeScript - Package - simple-git-hooks</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-simple-git-hooks/</link><pubDate>Tue, 15 Oct 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-simple-git-hooks/</guid><description>Guide toplenboren/simple-git-hooks githooks Notice ⚠️ 更改命令後記得更新 git hook ⚠️ 不要添加 &amp;quot;postinstall&amp;quot;: &amp;quot;pnpx simple-git-hooks&amp;quot; 於 package.json，會影響 publish 行為 ⚠️ 個人不建議簡化 跳過 hook 行為，必須保持操作不適度 Install pnpm add -D simple-git-hooks Config package.json { &amp;#34;scripts&amp;#34;: { &amp;#34;postinstall&amp;#34;: &amp;#34;simple-git-hooks&amp;#34; }, &amp;#34;simple-git-hooks&amp;#34;: { &amp;#34;pre-commit&amp;#34;: &amp;#34;pnpm lint-staged &amp;amp;&amp;amp; pnpm check&amp;#34;, &amp;#34;commit-msg&amp;#34;: &amp;#34;node scripts/verify-commit.js&amp;#34; } } Usage 更新 git hook pnpx simple-git-hooks 跳過 git hook - CI 這部分代補，目前沒有操作情境 doc 跳過 git hook - 三方 git client 開啟 git bash - git commit -m &amp;#34;你的 commit 訊息&amp;#34; --no-verify</description></item><item><title>Javascript_TypeScript - Package - tsup</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-tsup/</link><pubDate>Sun, 13 Oct 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-tsup/</guid><description>Quick Chat The simplest and fastest way to bundle your TypeScript libraries.
設計的初衷是讓開發者能夠以最少的設定完成打包工作，內建許多合理的預設值。
Guide egoist/tsup tsup 为什么是 tsup Dual Publishing ESM and CJS Modules with tsup and Are the Types Wrong? Install pnpm add -D tsup Config package.json { &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;tsup&amp;#34; }, } tsup.config.ts - only esm module import { defineConfig } from &amp;#39;tsup&amp;#39;; export default defineConfig({ // 指定入口文件 entry: [&amp;#39;src/index.ts&amp;#39;, &amp;#39;src/subpath/index.ts&amp;#39;, &amp;#39;src/internal/index.ts&amp;#39;], // ESM 格式 format: [&amp;#39;esm&amp;#39;], // 生成類型定義 dts: true, // 每次構建時清理輸出目錄 clean: true, });</description></item><item><title>Node.js - package.json - Export</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-package.json-export/</link><pubDate>Sun, 13 Oct 2024 09:11:01 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-package.json-export/</guid><description>Guide Package entry points Version selection with typesVersions Multiple exports with types in a Typescript Package 巧用 exports 和 typeVersions 提升 npm 包用户使用体验 Suggestion 以較新 Node.js 版本為目標的新包，建議使用 exports 欄位。 sample - vue/core Notice 當定義了 exports 欄位時
⚠️ Node.js 會優先使用 exports 來決定如何載入模組，只有在 exports 中沒有相應定義時，才會使用 main、module 和 types 欄位。 ⚠️ 所有子路徑都會被封裝起來，除非明確導出，否則這些子路徑將無法供使用者訪問(會拋出一個 ERR_PACKAGE_PATH_NOT_EXPORTED 的錯誤)。 Fields main 當套件被作為 CommonJS 模組引入時，預設的入口點。
module 當套件被作為 ES 模組引入時，預設的入口點。
types TypeScript 的類型定義檔案位置，提供 TypeScript 支援。
exports 用來細化和取代傳統的 main 和 module 欄位。 提高包的安全性：限制用戶可以訪問的內部文件，防止直接訪問內部未經授權的代碼。 更清晰的 API：只公開需要使用的部分代碼，簡化使用者的導入過程。 支持不同的模組格式：通過同時支持 require 和 import，可以在不同的環境中更靈活使用。 exports - Conditional Exports 目前指導出 esm 模組，未來需要雙入口再回補。</description></item><item><title>Node.js - Package Manager - pnpm</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-package-manager-pnpm/</link><pubDate>Sat, 12 Oct 2024 21:16:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-package-manager-pnpm/</guid><description>Guide pnpm 为什么现在我更推荐 pnpm 而不是 npm/yarn? pnpm、npm、yarn 包管理工具『优劣对比』及『环境迁移』 从pnpm工具了解整个npm包核心管理原理 為什麼 pnpm 比 npm 更快且更省空間？ pnpm实战教程 Install 全域安裝 npm install -g pnpm 環境配置 - Windows ⚠️ 使用 PowerShell 系統管理員 Get-ExecutionPolicy # 如果為 Restricted 則繼續進行 Set-ExecutionPolicy RemoteSigned Commands pnpm 本體 pnpm self-update : 將 pnpm 更新到最新版本。(建議重啟 ide) Node.js 的執行環境 pnpm env use &amp;ndash;global lts : 安裝並使用 LTS 版本 pnpm env use &amp;ndash;global {version} : 安裝並使用指定版本 pnpm env add &amp;ndash;global {version} : 僅安裝指定版本 pnpm env remove &amp;ndash;global {version} : 移除指定版本 pnpm env list &amp;ndash;remote : 列出線上可用的版本 packages pnpm add &amp;lt;pkg&amp;gt; : 添加依賴 pnpm remove &amp;lt;pkg&amp;gt; : 移除依賴 pnpm install : 安裝所有依賴 pnpm update : 在 package.</description></item><item><title>Javascript_TypeScript - TypeScript - tsconfig.json</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-typescript-tsconfig.json/</link><pubDate>Sat, 12 Oct 2024 08:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-typescript-tsconfig.json/</guid><description>Quick Chat 當目錄中出現了 tsconfig.json 文件，則表示該目錄是 TypeScript 專案的根目錄。tsconfig.json 檔案指定了編譯專案所需的根目錄下的檔案以及編譯選項。實務上在不同的開發情境中，準備不同的 tsconfig.json 是非常有必要的。
開發環境中，可能希望啟用更多的錯誤檢查和調試資訊，以便更快地發現問題。 生產環境中，則可能希望關閉這些額外的檢查，以提升編譯速度並減少輸出檔案大小。 呼叫 tsc 時使用 --project 或 -p 選項來指定相應的配置檔案。
tsc -p tsconfig.build.json Guide tsconfig.json 是什麼 TSConfig Reference tsc性能优化 &amp;ndash; Project References 基底 tsconfig Node 20 推薦的 tsconfig.json
@tsconfig/node20 npm install -D @tsconfig/node20 可以繼承基底 tsconfig 並覆寫參數
{ &amp;#34;extends&amp;#34;: &amp;#34;@tsconfig/node20/tsconfig.json&amp;#34;, &amp;#34;compilerOptions&amp;#34;: { &amp;#34;preserveConstEnums&amp;#34;: true }, &amp;#34;include&amp;#34;: [&amp;#34;src/**/*&amp;#34;], &amp;#34;exclude&amp;#34;: [&amp;#34;node_modules&amp;#34;, &amp;#34;**/*.spec.ts&amp;#34;] } 型別導出 { &amp;#34;compilerOptions&amp;#34;: { &amp;#34;declaration&amp;#34;: true, &amp;#34;declarationMap&amp;#34;: true, &amp;#34;emitDeclarationOnly&amp;#34;: true, &amp;#34;outDir&amp;#34;: &amp;#34;.</description></item><item><title>Workflow - Create a template for full-stack monorepo</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-create-a-template-for-full-stack-monorepo/</link><pubDate>Fri, 11 Oct 2024 09:13:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-create-a-template-for-full-stack-monorepo/</guid><description>Structure project-root/ ├── pnpm-workspace.yaml ├── scripts/ ├── apps/ | ├── cli/ | ├── web/ (vue) | └── desktop/ (electron) └── packages/ ├── pkg01/ └── pkg02/ scripts 全域工作區命令。 apps 每個子資料夾代表一個最終的應用場景(終端)。 packages 專注於封裝和共享具體的功能模組，為各個終端應用提供支援。</description></item><item><title>Electron - Note</title><link>https://HoshikawaRyuukou.github.io/posts/electron-note/</link><pubDate>Fri, 11 Oct 2024 09:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/electron-note/</guid><description>Quick Chat Electron 是一個使用 JavaScript、HTML 和 CSS + Native Api 做相容多個系統（Windows、Linux、Mac）的桌面應用程式構建框架 —— 不需要本地開發經驗。
Guide Build cross-platform desktop apps with JavaScript, HTML, and CSS | Electron electron-builder Electron学习指引 awesome-electron awesome-electron-alternatives Suggestion 🤓 強烈建議第一次接觸 Electron 的開發者實際走一次官方 quick-start，會對 Electron 的本質有更純粹的認識。
electron/electron-quick-start 再逐步的嘗試以下機制 :
用 BrowserWindow 再額外創建一個窗口。 用 ipcMain/ipcRenderer 來達到進程間交互。 Notice ⚠️ Electron 中的 ES 模塊 (ESM) 並未 100% 支援</description></item><item><title>Workflow - Create a monorepo with pnpm workspace</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-create-a-monorepo-with-pnpm-workspace/</link><pubDate>Sun, 06 Oct 2024 20:31:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-create-a-monorepo-with-pnpm-workspace/</guid><description>Guide Monorepo与pnpm：前端项目管理的完美搭档 为什么 pnpm+monorepo 是组件库项目的最佳实践 Monorepo？來聊聊另一種專案管理架構吧！ 从npm版本依赖到Monorepo大仓项目 MonoRepo实战：pnpm+nx搭建MonoRepo项目 Create a monorepo using PNPM workspace 从构建到发布：Monorepo 的最佳实践 TSTemplateMonorepo pnpm monorepo 搭建工具库 專案基本結構 project-root/ # 專案根目錄 ├── pnpm-workspace.yaml # pnpm 的工作區配置文件，用來定義哪些資料夾屬於工作區範圍 ├── package.json # 專案的全局配置文件，通常包括依賴、腳本和項目元數據 └── packages/ # 所有子包的資料夾，存放具體的子項目 ├── pkg01/ # 子包01，包含它自己的 package.json 文件和代碼 └── pkg02/ # 子包02，與 pkg01 結構相似，也擁有自己的 package.json 和代碼 新增 專案內全局配置 ./package.json # 產生一個基本的 package.json pnpm init monorepo 的全局 package.json 設置 &amp;quot;private&amp;quot;: true { &amp;#34;private&amp;#34;: true, } 新增 工作區配置文件 .</description></item><item><title>Workflow - Optimize a monorepo with pnpm and Turborepo</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-optimize-a-monorepo-with-pnpm-and-turborepo/</link><pubDate>Sun, 06 Oct 2024 20:31:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-optimize-a-monorepo-with-pnpm-and-turborepo/</guid><description>Guide</description></item><item><title>Workflow - Generate a Github Packages Access Token</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-generate-a-github-packages-access-token/</link><pubDate>Sun, 06 Oct 2024 20:13:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-generate-a-github-packages-access-token/</guid><description>Steps 切換到 github 用戶號 (不是組織號) Settings/Developer Settings Personal access tokens (classic) 僅啟用 read:packagesDownload packages from GitHub Package Registry To-do 改用更推薦的 Fine-grained personal access tokens</description></item><item><title>Workflow - Install a private npm package from Github Packages</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-install-a-private-npm-package-from-github-packages/</link><pubDate>Sun, 06 Oct 2024 20:12:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-install-a-private-npm-package-from-github-packages/</guid><description>Requirement ⚠️ 向 github 組織索取訪問用的 token ⚠️ 本範例使用 npm，之後會轉使用 pnpm Window 環境變數設置 token setx GITHUB_TOKEN ghp_xxxxxxxxxxxxxxxxxxxxxxxx ⚠️ 設置後必要時重啟終端機以確保環境變數被應用 初始化 project cd project-directory npm init -y 新增 ./.npmrc ⚠️ 這裡的第二行註解是正規寫法，有特殊用途 @xxx:registry=https://npm.pkg.github.com //npm.pkg.github.com/:_authToken=&amp;#34;${GITHUB_TOKEN}&amp;#34; 安裝 package npm install @ooxx/xxx</description></item><item><title>Workflow - Publish a private npm package to Github Packages</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-publish-a-private-package-to-github-packages/</link><pubDate>Sun, 06 Oct 2024 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-publish-a-private-package-to-github-packages/</guid><description>Requirement ⚠️ 請先確保 package 本身已是合規的配置(exports/typesVersions/files/&amp;hellip;)。 ⚠️ 本範例使用 npm，之後會轉使用 pnpm。 package.json 的必要配置 name : 需配置 @scope version : 版本號 { &amp;#34;name&amp;#34;: &amp;#34;@xxx/oooo&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.1.0&amp;#34;, } 新增 ./.npmrc @xxx:registry=https://npm.pkg.github.com 編寫 ./.github/workflows/publish-package.yml name: Publish Package on: workflow_dispatch: push: branches: - main jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: &amp;#39;20&amp;#39; registry-url: &amp;#39;https://npm.pkg.github.com/&amp;#39; - run: npm ci - run: npm run build - run: npm publish env: NODE_AUTH_TOKEN: ${{ secrets.</description></item><item><title>Software Design - Architecture - Web &amp; Desktop app</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-architecture-web-desktop-app/</link><pubDate>Sat, 05 Oct 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-architecture-web-desktop-app/</guid><description>Quick Chat (⚠️ 實驗中) 當一個要開發一個同時支援 網頁端 與 桌面端 的應用時，該如何設計。以下範例說明使用
UIFramework : Vue3 Desktop Framework : Electron Architecture project-root/ │ ├── core/ # 核心業務邏輯 │ ├── services/ # 服務層，包含業務邏輯 (e.g., FileManager) │ ├── models/ # 共享的資料模型和接口 │ └── interfaces/ # 定義服務的接口 (e.g., IFileService) │ ├── presentation/ # UI 表現層 (Vue3 應用) │ ├── components/ # Vue 組件 │ ├── views/ # Vue 頁面 │ ├── stores/ # Pinia 狀態管理 │ └── App.</description></item><item><title>Profile - Studio</title><link>https://HoshikawaRyuukou.github.io/posts/profile-studio/</link><pubDate>Wed, 02 Oct 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/profile-studio/</guid><description>箱庭工作室 (Miniature Garden Studio) 這是筆者的工作室名。
核心思想 每個應用程式都是一個精心構築的 箱庭/微型世界，在有限的環境中創造豐富且深度的體驗，讓使用者能夠沉浸其中。
現實中的箱庭 箱庭（はこにわ，Hakoniwa），它是一種縮小版的庭園或景觀模型。這個概念源於日本，最早用來指代傳統日式庭園的迷你模型，但後來這個詞的應用範圍擴展到了各種縮小版的自然景觀創作。
遊戲中的箱庭 箱庭設計在遊戲中已成為一種經典理念。
IGN小课堂#49：箱庭 从沙盒和开放世界谈起，说说日本的箱庭设计理念</description></item><item><title>Logic - Pseudo-Problem</title><link>https://HoshikawaRyuukou.github.io/posts/logic-pseudo-problem/</link><pubDate>Tue, 01 Oct 2024 21:22:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/logic-pseudo-problem/</guid><description>假議題（pseudo-problem） 領域 非形式邏輯 謬誤學 簡述 &amp;ldquo;假議題&amp;rdquo; 是一種表面上看起來像是重要或值得討論的問題，但實際上並 不具有實質意義或無法帶來真正的解決 方案。這類議題通常會引導人們將精力和資源集中在並不重要或無法解決的事情上，從而忽視了真正需要關注的問題。
特點：
錯誤的前提：假議題常常基於錯誤或不正確的前提來構建，問題本身可能從一開始就沒有存在的必要性。 分散注意力：討論假議題可能會轉移人們對真正問題的注意，這樣的討論往往無法帶來實際的改變或有效的解決方案。 無解的爭論：假議題可能導致無休止的爭論，因為其核心問題本質上是無法解決的，或者答案根本不重要。 情境 技術討論中，有時某些看似關鍵的技術細節被過度強調，但實際上並不影響整體系統的效能或成效，這樣的爭論也可以被視為一種假議題。 討論「天使的性別是什麼？」這樣的問題，在哲學或神學中可能被認為是一個「假議題」，因為它無法被證實或否認，也沒有實際意義。</description></item><item><title>Logic - Straw man</title><link>https://HoshikawaRyuukou.github.io/posts/logic-straw-man/</link><pubDate>Tue, 01 Oct 2024 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/logic-straw-man/</guid><description>攻擊稻草人（Straw man） 領域 非形式邏輯 謬誤學 簡述 「攻擊稻草人」（Strawman Fallacy）是一種邏輯謬誤，指的是 &amp;ldquo;故意曲解或誇大&amp;rdquo; 對方的論點，然後對這個被扭曲的論點進行反駁。這樣的辯論手法無法真正解決問題，因為它回避了對方的實際觀點，而是製造一個更容易攻擊的「稻草人」來取代對方的真實立場。
這種謬誤在辯論中常見，特別是在政治或社會爭論中。避免這種謬誤的關鍵是要正確理解並直接回應對方的真實論點，而不是創造一個虛假的版本。
情境 A: 「我們應該更多地投資於環保技術。」 B: 「他們想要讓我們放棄所有的經濟發展，回到石器時代！」 B 曲解了 A 的立場，然後攻擊這個扭曲的立場，而不是 A 的實際觀點。</description></item><item><title>Workflow - Vite + Vue3 + Electron</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-vite-+-vue3-+-electron/</link><pubDate>Sat, 28 Sep 2024 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-vite-+-vue3-+-electron/</guid><description>Step 1: 準備一個 Vite + Vue3 專案 使用 vite 指令創建空專案
pnpm create vite vve cd vve pnpm install pnpm dev Step 2: 配置 Electron 添加依賴 pnpm add -D electron pnpm add -D electron-builder pnpm add -D vite-plugin-electron pnpm add -D vite-plugin-electron-renderer 新增 ./electron/electron-env.d.ts declare namespace NodeJS { interface ProcessEnv { /** * The built directory structure * * ```tree * ├─┬─┬ dist * │ │ └── index.html * │ │ * │ ├─┬ dist-electron * │ │ ├── main.</description></item><item><title>Electron - Design Context</title><link>https://HoshikawaRyuukou.github.io/posts/electron-design-context/</link><pubDate>Fri, 27 Sep 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/electron-design-context/</guid><description>Context - 將現有的前端專案包裝成桌面端應用 情境： 已有一個完整的前端專案，但由於一些特定需求（例如離線操作的能力），決定將其包裝成桌面端應用。本質上，這個應用仍是一個網頁應用，因此基本上不會有額外的桌面端互動需求，也不需要特別增強和操作系統的整合。
目的： 主要為了滿足離線存取與更佳的用戶體驗，但不需要深度的桌面端特性。
技術重點： 專注於如何將現有的 Web 應用以 Electron 進行包裝，保持與原生前端相同的開發流程，並且避免過多改動。
限制： 盡量維持輕量化，減少與桌面平台的耦合，僅利用 Electron 提供的框架和包裝功能。
Context - 基於前端技術開發桌面端應用 情境： 目標是開發桌面端應用，只是基於前端技術來實現。這意味著應用程式將包含一些桌面應用所特有的特性，例如系統通知、檔案系統操作、離線儲存等。
目的： 充分利用 Electron 提供的 API 來增強桌面應用的功能，使其可以提供超越單純網頁應用的體驗。
技術重點： 基於前端技術棧（如 Vue、React 等），但需要使用 Electron 來實現與桌面系統的交互，包括檔案存取、系統托盤等。
設計考量： 需要兼顧應用的桌面特性與前端開發的靈活性，保證兩者間的有效融合。
Context - Electron 與 前端技術 僅是實作細節 情境： 設計理念以業務需求為核心，Electron 以及前端技術只是達成目標的手段和細節。
業務為中心的設計： 設計時不局限於技術選型，而是先分析業務需求，再根據需求選擇最佳的技術方案。最終選擇的技術（Electron、前端技術）只是為了實現業務需求的手段。
基於 Clean Architecture： 使用乾淨架構來分離業務邏輯與實作細節，確保應用程式具有良好的可擴展性與可維護性。Electron 與前端技術被隔離在具體的實作層，任何一方都可以被替換而不影響業務邏輯。
技術重點： 強調框架的選擇與使用不應該影響到核心業務邏輯，業務邏輯應獨立於 UI、技術框架的變更，專注於系統的彈性與維護性。</description></item><item><title>Organization - Note</title><link>https://HoshikawaRyuukou.github.io/posts/organization-note/</link><pubDate>Thu, 26 Sep 2024 14:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/organization-note/</guid><description>Corporate culture QualiArtsのUnity開発を支える基盤の紹介</description></item><item><title>Android - Note</title><link>https://HoshikawaRyuukou.github.io/posts/android-note/</link><pubDate>Thu, 26 Sep 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/android-note/</guid><description>Skill 從已安裝 app 抽取出 apk How to Extract, Save and Share an APK of an Android Application 使用內建的 Files 應用並選擇分享 app 即可</description></item><item><title>Phenomena - Anchoring Effect</title><link>https://HoshikawaRyuukou.github.io/posts/phenomena-anchoring-effect/</link><pubDate>Mon, 23 Sep 2024 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/phenomena-anchoring-effect/</guid><description>錨定效應（Anchoring Effect） 領域 心理學 行為經濟學 簡敘 錨定效應是一種認知偏誤，指的是人們在做決策時，過度依賴於最先獲得的資訊（即「錨」），即便該資訊與後續的選擇或結論無直接相關。這個初始資訊會對後續的判斷產生重大影響。
情境 例如，當你在購物時，看到某件商品的原價是 $500，但打折後是 $300，你會覺得這個折扣很吸引人，因為「500」這個數字成為了你的「錨」。即便這件商品實際價值可能是 $300 或更低，你仍然會覺得它比原價便宜很多。</description></item><item><title>Electron - Basics</title><link>https://HoshikawaRyuukou.github.io/posts/electron-basics/</link><pubDate>Mon, 23 Sep 2024 21:19:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/electron-basics/</guid><description>Process Electron 的進程機制主要由兩個部分組成：主進程(Main Process) 和 渲染進程(Renderer Process)。
主進程 (Main Process) 每個 Electron 應用僅有一個主進程。 主進程負責創建應用的主窗口，並管理應用的生命周期。 主進程的權限非常高，它可以調用 Node.js 提供的所有 API，也可以與操作系統進行交互(例如：檔案系統操作、創建子進程、打開原生對話框) 。 主進程負責創建和管理應用中的所有窗口(BrowserWindow) ，並能夠與渲染進程進行通信。 渲染進程 (Renderer Process) 每個應用窗口都是一個獨立的渲染進程，負責渲染網頁內容(HTML、CSS、JavaScript) 。 渲染進程本質上是運行在 Chromium 引擎中的網頁環境，它擁有與一般瀏覽器類似的行為和限制。 渲染進程的權限較低，為了安全起見，它無法直接訪問 Node.js 的全部 API，但可以通過 Electron 的 contextBridge 和 ipcRenderer 與主進程通信。 渲染進程可以使用 Electron 提供的 preload 腳本，將一些 Node.js 模組或功能暴露給網頁。 進程間通信 (Inter-Process Communication, IPC) 主進程和渲染進程之間使用 IPC 進行數據傳遞。 渲染進程使用 ipcRenderer 發送消息給主進程，而主進程使用 ipcMain 接收和回應這些消息。反之，主進程也可以向渲染進程發送消息。 Electron 提供的 contextBridge 和 preload 腳本讓渲染進程能安全地與主進程進行通信，避免直接暴露過多的 Node.js API，從而提高應用的安全性。 Module app 主進程模組，用來控制整個應用的生命周期。它包含了一系列的事件和方法，用於管理應用的初始化、運行、退出等流程。 BrowserWindow 主進程模組，用來創建和管理應用窗口的模組。 每個 BrowserWindow 實例代表一個獨立的瀏覽器窗口，並且運行在自己的渲染進程中。 ipcMain 主進程模組，用來處理進程間通信的模組。 ipcRenderer 渲染進程模組，用來處理進程間通信的模組， 不要直接在網頁中使用 ipcRenderer，而是通過 preload 腳本中的 contextBridge 暴露安全的 API 給渲染進程。</description></item><item><title>Workflow - Vite + Vue3 + Github Pages</title><link>https://HoshikawaRyuukou.github.io/posts/workflow-vite-+-vue3-+-github-pages/</link><pubDate>Fri, 20 Sep 2024 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/workflow-vite-+-vue3-+-github-pages/</guid><description>Guide vite - 部署静态站点 [vite] 將 Vite 專案部署至 Github Pages vue3项目部署到Github 前置動作 設置 vite.config.js 中設定 Base URL export default defineConfig({ base: &amp;#39;/{repo name}}/&amp;#39;, plugins: [vue()], }); 確保靜態網頁內容無誤 pnpm build pnpm preview 部屬 方式 1 - 使用 gh-pages 套件 安裝套件 pnpm add -D gh-pages 於 package.json 編寫命令 { &amp;#34;scripts&amp;#34;: { &amp;#34;deploy2ghpages&amp;#34;: &amp;#34;gh-pages -d dist&amp;#34; }, } 執行命令 pnpm deploy2ghpages 方式 2 - 使用 github actions 編寫 .github\workflows\gh-pages.yml # 將靜態內容部署到 GitHub Pages 的簡易工作流程 name: Deploy static content to Pages on: # 僅在推送到默認分支時運行。 push: branches: [&amp;#39;main&amp;#39;] # 這個選項可以使你手動在 Action tab 頁面觸發工作流 workflow_dispatch: # 設置 GITHUB_TOKEN 的權限，以允許部署到 GitHub Pages。 permissions: contents: read pages: write id-token: write # 允許一個併發的部署 concurrency: group: &amp;#39;pages&amp;#39; cancel-in-progress: true jobs: # 單次部署的工作描述 deploy: environment: name: github-pages url: ${{ steps.</description></item><item><title>Slot Design - Math Model</title><link>https://HoshikawaRyuukou.github.io/posts/slot-design-math-model/</link><pubDate>Mon, 09 Sep 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/slot-design-math-model/</guid><description>使用馬可夫鏈來控制波動性 定義狀態 每個狀態代表玩家一次 spin 後的結果。根據遊戲中的贏獎情況將這些狀態定義為:
No Win (無贏) Small Win (小獎) Medium Win (中獎) Big Win (大獎) Free Game (免費遊戲) 設計轉換矩陣 Current State \ Next State No Win Small Win Medium Win Big Win Free Game No Win 0.70 0.20 0.05 0.03 0.02 Small Win 0.50 0.30 0.10 0.05 0.05 Medium Win 0.60 0.20 0.10 0.05 0.05 Big Win 0.80 0.10 0.05 0.03 0.02 Free Game 0.50 0.25 0.10 0.10 0.</description></item><item><title>Javascript_TypeScript - Package - Prettier</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-prettier/</link><pubDate>Thu, 05 Sep 2024 08:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-prettier/</guid><description>Quick Chat Prettier 是一個代碼格式化工具，用於保持代碼風格一致。
Guide Prettier · Opinionated Code Formatter playground 如何配置 prettier Notice ⚠️ 跨平台協同的結尾符問題 [eslint] Delete CR eslint(prettier/prettier) issue 令人困擾的git autocrlf – Opass Life Install pnpm add -D prettier Extension vscode extension .vscode/extension.json { &amp;#34;recommendations&amp;#34;: [&amp;#34;esbenp.prettier-vscode&amp;#34;] } .vscode/setting.json { &amp;#34;editor.formatOnSave&amp;#34;: true, &amp;#34;[typescript]&amp;#34;: { &amp;#34;editor.defaultFormatter&amp;#34;: &amp;#34;esbenp.prettier-vscode&amp;#34; }, &amp;#34;[javascript]&amp;#34;: { &amp;#34;editor.defaultFormatter&amp;#34;: &amp;#34;esbenp.prettier-vscode&amp;#34; }, &amp;#34;[json]&amp;#34;: { &amp;#34;editor.defaultFormatter&amp;#34;: &amp;#34;esbenp.prettier-vscode&amp;#34; } } Plugin prettier-plugin-organize-imports : 排序/合併/移除未使用的 import 聲明 prettier-plugin-packagejson : 格式化 package.json Integration - ESlint eslint-config-prettier ESLint 配置，用於關閉與 Prettier 產生衝突。 eslint-config-prettier - eslint.</description></item><item><title>Social - Note</title><link>https://HoshikawaRyuukou.github.io/posts/social-note/</link><pubDate>Sun, 01 Sep 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/social-note/</guid><description>Personality 免費性格測試、性格類型描述、人際關係和職業建議 | 16Personalities Human Nature 跟沒錢的人打交道，直接告訴他能賺多少
跟底層的人打交道，要給他臉，給他尊重
跟厲害的人打交道，不要浪費他時間，直奔主題</description></item><item><title>Game Design - Introduction</title><link>https://HoshikawaRyuukou.github.io/posts/game-design-introduction/</link><pubDate>Sun, 01 Sep 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/game-design-introduction/</guid><description> 从Balatro小丑牌的成功说起：浅谈rogue的核心体验与设计 什么驱使着人们玩游戏？【游戏设计知识分享-动机1】 人们一直玩是因为游戏好？【游戏设计知识分享-动机2】</description></item><item><title>Android - Reverse Engineering</title><link>https://HoshikawaRyuukou.github.io/posts/android-reverse-engineering-copy/</link><pubDate>Fri, 30 Aug 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/android-reverse-engineering-copy/</guid><description>apktool APKTool反编译 extract.bat ⚠️ 將 extract.bat, apktool.jar, apk 放在相同目錄。
@echo off REM Set the directory where apktool.jar is located set APKTOOL_DIR=%~dp0 REM Enable delayed variable expansion setlocal enabledelayedexpansion REM Loop through all APK files in the same directory as apktool.jar for %%f in (&amp;#34;%APKTOOL_DIR%*.apk&amp;#34;) do ( REM Get the APK file name (without extension) set APK_NAME=%%~nf echo Decompiling APK: !APK_NAME! REM Decompile the APK java -jar &amp;#34;%APKTOOL_DIR%apktool.jar&amp;#34; d &amp;#34;%%f&amp;#34; -o &amp;#34;%APKTOOL_DIR%!</description></item><item><title>AI - Note</title><link>https://HoshikawaRyuukou.github.io/posts/ai-note/</link><pubDate>Thu, 29 Aug 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-note/</guid><description>Guide 一小時略懂 AI｜GPT、Sora、Diffusion model、類器官智慧OI、圖靈測試、人工智慧史 News AIbase基地 - 让更多人看到未来 通往AGI之路 Audio Suno AI Chat Bot Chat With ChatGPT bot DAN fast and free | FlowGPT Document 新世代 AI 簡報神器 Gamma Translation GPT Translator SakuraLLM/SakuraLLM</description></item><item><title>Software Development - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/software-development-sites/</link><pubDate>Wed, 28 Aug 2024 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-development-sites/</guid><description>Developer Community 稀土掘金 Zenn Qitta Developer Guide Refactoring and Design Patterns DevIQ Developer Blog CyberAgent Developers Blog | サイバーエージェント デベロッパーズブログ SELECK [セレック] |デジタル人材のためのメディア every Tech Blog tangly llc Blog | tangly Components CodeOpinion Khalil Stemmler | Become a confident crafter. Learn to write testable, scalable TypeScript. Developer Note 牧涯前端学习笔记 | 记录一些前端学习的知识 Company - Game Happy Elements Inactive jyt0532&amp;rsquo;s Blog Tomas Tulka&amp;rsquo;s Blog Entropy Wins - A blog on Software Architecture, Design and Craftsmanship</description></item><item><title>AI - Ollama</title><link>https://HoshikawaRyuukou.github.io/posts/ai-ollama/</link><pubDate>Mon, 19 Aug 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-ollama/</guid><description>Guide Ollama Ngrok + Ollama | 在世界任何地方与localhost开源大模型聊天 Free Inference Is All I Need: How to Run Large Language Models for Free Using Google Colab UI Page Assist - A Web UI for Local AI Models Model Hugging Face qwen2 internlm2 mradermacher/mini-magnum-12b-v1.1-GGUF Roleplay, Creative Writing, Uncensored, NSFW Commands ollama list : 查看以配置本地模型 ollama run {model} : 下載/執行模型 ollama ps : 展示目前載入的模型、它們所佔的記憶體大小以及所使用的處理器類型（GPU 或 CPU） Extra import_gguf_to_ollama.bat @echo off REM 設定本地環境，並切換到批次檔所在的目錄 setlocal cd /d %~dp0 REM 搜尋當前目錄中的 .</description></item><item><title>Cocos - Note</title><link>https://HoshikawaRyuukou.github.io/posts/cocos-note/</link><pubDate>Fri, 16 Aug 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/cocos-note/</guid><description>Guide cocos creator零基础教学 Cocos-siki学院 Framework oops-framework MKFramework QuickFramework XForge ccc-tnt-framework CocosCreator-GG-Framework FairyGUI-cocoscreator Rescource awesome-CocosCreator</description></item><item><title>Software Development - Repository Structure</title><link>https://HoshikawaRyuukou.github.io/posts/software-development-repository-structure-note/</link><pubDate>Mon, 12 Aug 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-development-repository-structure-note/</guid><description>Quick Chat 最近筆者在開發公司的共用套件時，踩了不少坑，尤其是在儲存庫結構方面。
最初選擇了 polyrepo 的結構，但隨著開發的進展，碰到了一些問題：
要確保這些獨立的 repo 配置能夠同步。 每次發佈都需要逐一更新每個套件，尤其是那些有兩三層依賴的，讓發佈變得非常繁瑣。 進行 code review 時，還要不停地在不同 repo 之間切換。 為了改善這些問題，開始研究 monorepo 的結構：
使用 pnpm workspace 來構建。 雖然 monorepo 有一些權限控管的隱憂，但因為共用套件的開發人數不多，所以目前還不用太擔心協作上的衝突。 Guide monorepo-vs-polyrepo 你很常聽到 monorepo，但為什麼要用 monorepo? PolyrepoからMonorepoへ移行する 策略 monolith: 當專案需要保持單一應用程式的完整性，所有功能都被打包在一起，且較少外部依賴。 monorepo: 當多個專案需要高度共享資源或密切合作，如共用許多元件、工具或模組的情況下。 polyrepo: 功能差異大、專案之間關聯性不強或不需要彼此干擾的情況下。每個專案獨立運行，較少相互依賴。 monolith polyrepo monorepo Managing a full-stack, multipackage monorepo using pnpm Live types in a TypeScript monorepo Building a Typescript + NodeJS Monorepo in 2024 特色 👍 package 使用相同版本 依賴/設定檔/風格。 ⚠️ package 權限控管需仰賴其他工作流。</description></item><item><title>Gambling - Note</title><link>https://HoshikawaRyuukou.github.io/posts/gambling-note/</link><pubDate>Tue, 06 Aug 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/gambling-note/</guid><description>Volatility 高波動性具有高風險，中獎率低，可是萬一運氣來了獲得的獎金會非常巨大。 低波動性的老虎機就是來玩開心的，只是想打發時間毫無疑問這是最佳選擇。 keywords 隨機過程</description></item><item><title>Algorithm - Sampling - Alias Method</title><link>https://HoshikawaRyuukou.github.io/posts/algorithm-sampling-alias-method/</link><pubDate>Sun, 04 Aug 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/algorithm-sampling-alias-method/</guid><description>別名方法是一種眾所周知的演算法，用於從任意離散機率分佈中進行恆定時間採樣，該演算法依賴於簡單的預先計算的查找表。
Guide Alias Method: 非均匀随机抽样算法 Darts, Dice, and Coins: Sampling from a Discrete Distribution Weighted Random: algorithms for sampling from discrete probability distributions mackysoft/Choice jgrapht-core/src/main/java/org/jgrapht/alg/util/AliasMethodSampler.java 務必先觀看
第一篇文章的漸進思考與核心精神 第二篇文章最後的 Vose&amp;rsquo;s Alias Method 圖解 Example 給定的權重 [0.1, 0.2, 0.3, 0.4]。
按均值縮放權重： 均值為 : 0.25 縮放後的權重：[0.4, 0.8, 1.2, 1.6] 分類權重到 large 和 small 隊列： 初始狀態：small = [], large = [] 權重 0.4 小於 1，放入 small：small = [0] 權重 0.8 小於 1，放入 small：small = [0, 1] 權重 1.</description></item><item><title>Software Design - Pattern - Note</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-note/</link><pubDate>Thu, 01 Aug 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-note/</guid><description>Factory 工厂模式？错！是工厂模式群！ Observer / Pub-Sub (Publisher-Subscriber) Observer vs Pub-Sub pattern Pub sub system pros and cons Observer 觀察者模式中的主題同時身為發布者，觀察者是知道發布者的，但發布者不知道觀察者。
Pub-Sub (Publisher-Subscriber) 發布者-訂閱者模式中的主題通常由消息代理或事件總線處理，發布者和觀察者不知道彼此的存在。發布者項主題發送訊息，主題再轉發給觀察者。</description></item><item><title>Node.js - package.json</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-package.json/</link><pubDate>Fri, 26 Jul 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-package.json/</guid><description>Quick Chat 可以將 package.json 檔案新增到套件中，以便其他人可以輕鬆管理和安裝。發佈到註冊表的包必須包含一個 package.json 檔案。
Creating a package.json file Quick Start 根據當前目錄產生預設 package.json
npm init -y
Fields name 必須是小寫字母和一個單詞，並且可以包含連字符和下劃線
version 遵循語義版本控制準則 x.x.x
type 指定 module system 要用
ES : &amp;ldquo;module&amp;rdquo; CommonJS : &amp;ldquo;commonjs&amp;rdquo; main 當套件被作為 CommonJS 模組引入時，預設的入口點。
module 當套件被作為 ES 模組引入時，預設的入口點。
types TypeScript 的類型定義檔案位置，提供 TypeScript 支援。
exports 是一個較新的欄位，用來細化和取代傳統的 main 和 module 欄位。它允許你為不同的環境（例如 Node.js、ES 模組、瀏覽器）定義不同的入口點和模組格式。它還允許你控制哪些檔案可以被使用者匯入，提供更多的安全性和靈活性。
如果有 exports 欄位，Node.js 會優先使用 exports 來決定如何載入模組，只有在 exports 中沒有相應定義時，才會回退到使用 main、module 和 types 欄位。
{ &amp;#34;exports&amp;#34;: { &amp;#34;.</description></item><item><title>Javascript_TypeScript - Package - commitlint</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-commitlint/</link><pubDate>Fri, 12 Jul 2024 08:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-commitlint/</guid><description>Quick Chat commitlint 是一個用來檢查 git commit 信息格式的工具，它可以配合多種規範使用。
Guide conventional-changelog/commitlint commitlint doc Commit-lint学习：新手入门指南 Commitlint vs Commitizen: Comparison for Better Git Commit Practices Notice ⚠️ 此處搭配 simple-git-hooks 使用。 Install pnpm add -D @commitlint/{cli,config-conventional} Config package.json { &amp;#34;simple-git-hooks&amp;#34;: { &amp;#34;pre-commit&amp;#34;: &amp;#34;pnpm lint-staged &amp;amp;&amp;amp; pnpm check&amp;#34;, &amp;#34;commit-msg&amp;#34;: &amp;#34;pnpx commitlint --edit $1&amp;#34; }, } commitlint.config.js export default { extends: [&amp;#39;@commitlint/config-conventional&amp;#39;], };</description></item><item><title>Gambling - Basic - Odds</title><link>https://HoshikawaRyuukou.github.io/posts/gambling-basic-odds/</link><pubDate>Sat, 06 Jul 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/gambling-basic-odds/</guid><description>Decimal Odds（小數/歐式/國際賠率） 賠率含本金
2.00: 表示如果您下注 1 單位，將總共得到 2 單位(包含本金)。 Fractional Odds（分數/英式/傳統賠率） 賠率不含本金
3/2: 表示如果下注 2 單位，並且贏了，將贏得 3 單位，外加本金，即總共得到 5 單位。 American odds (美式賠率) 賠率不含本金
正賠率: 表示的是如果下注 100 單位 您能獲得多少利潤。 負賠率: 表示的是需要下注多少才能贏得 100 單位。</description></item><item><title>Javascript_TypeScript - Package - Vitest</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-vitest/</link><pubDate>Tue, 02 Jul 2024 08:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-package-vitest/</guid><description>Guide Vitest Coverage 這些數值表示了測試覆蓋率的不同方面，具體如下：
% Stmts (Statements Coverage)：
說明：表示程式碼中所有執行語句的覆蓋率。這個百分比告訴你測試運行時執行了多少語句。 例如：如果程式碼中有 100 行執行語句，而測試覆蓋了其中的 80 行，則此覆蓋率為 80%。 % Branch (Branches Coverage)：
說明：表示條件分支的覆蓋率（如 if/else、switch/case）。這個百分比告訴你程式碼中所有可能的邏輯分支是否被測試覆蓋。 例如：如果有 10 個 if/else 條件，但只有 7 個條件分支在測試中執行過，則此覆蓋率為 70%。 % Funcs (Functions Coverage)：
說明：表示函數的覆蓋率。這個百分比告訴你測試運行時，程式碼中定義的函數中有多少被調用和覆蓋。 例如：如果程式碼中有 20 個函數，而測試覆蓋了其中的 15 個，則此覆蓋率為 75%。 % Lines (Lines Coverage)：
說明：表示實際被執行的行數覆蓋率。這與 % Stmts 類似，但更精確地計算了具體的行數。 例如：如果程式碼中有 200 行代碼，而測試覆蓋了其中的 180 行，則此覆蓋率為 90%。 Uncovered Line #s：
說明：列出未被測試覆蓋的具體行號。這些是測試未執行到的程式碼行，你可以根據這些行號來調整和增加測試用例，從而提高測試覆蓋率。 這些指標有助於你了解測試覆蓋率的具體情況，並確保你的程式碼在不同方面都得到充分的測試。
Extra 必要時使用括 弧表示法 訪問屬性private expect(inst[&amp;#34;_somePrivateProp&amp;#34;]).toBe(&amp;#34;foo&amp;#34;); // OK</description></item><item><title>Mathematics - Note</title><link>https://HoshikawaRyuukou.github.io/posts/mathematics-note/</link><pubDate>Sun, 30 Jun 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/mathematics-note/</guid><description>Channel FunInCode Case 【数之道 18】&amp;ldquo;马尔可夫链&amp;quot;是什么？ 三門問題 三個囚犯問題</description></item><item><title>Node.js - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-packages/</link><pubDate>Sat, 22 Jun 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-packages/</guid><description>Package npm trends npx npx 常用於執行一次性操做，允許你在不安裝包到全局或本地的情況下直接運行該包中的可執行文件。且會檢查並執行最新版本的包，確保你不會因為本地包過時而遇到問題。
Benchmark tinybench CLI chalk cli-table3 tsx: 替代 node 指令、支持运行 TypeScript &amp;amp; ESM 的 CLI 程序 console-table-printer Git degit degit简介 IO rimraf Rimraf详细介绍 IoC InversifyJS Multitasking workerpool Test Vitest Validation zod</description></item><item><title>Telegarm - Note</title><link>https://HoshikawaRyuukou.github.io/posts/telegarm-note/</link><pubDate>Sat, 22 Jun 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/telegarm-note/</guid><description>Bot - API Token 搜索 BotFather 並開始對話。 使用 /newbot 命令創建一個新的機器人，按提示操作。 創建完成後，你會獲得一個 API Token，將其保存下來。 Bot - Chat ID 將你創建的機器人添加到你想發訊息的群組中。 發送一條消息到該群組。 使用以下 URL 來獲取群組的更新: https://api.telegram.org/bot&amp;lt;YourBotToken&amp;gt;/getUpdates 查看返回的 JSON 數據，找到 chat 字段中的 id，這就是群組的 Chat ID。 { &amp;#34;ok&amp;#34;: true, &amp;#34;result&amp;#34;: [ { &amp;#34;update_id&amp;#34;: 123456789, &amp;#34;message&amp;#34;: { &amp;#34;message_id&amp;#34;: 1, &amp;#34;from&amp;#34;: {}, &amp;#34;chat&amp;#34;: { &amp;#34;id&amp;#34;: -1001234567890, &amp;#34;title&amp;#34;: &amp;#34;Your Group Title&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;supergroup&amp;#34; }, &amp;#34;date&amp;#34;: 1617821123, &amp;#34;text&amp;#34;: &amp;#34;Your Message&amp;#34; } } ] } Sticker Telegram 貼圖 DIY教學</description></item><item><title>Documentation - README</title><link>https://HoshikawaRyuukou.github.io/posts/documentation-readme/</link><pubDate>Tue, 18 Jun 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/documentation-readme/</guid><description>Quick Chat 最近筆者從 Unity 轉向了 Node.js，因此花了大量時間在 npm 上尋找合適的套件。大部分的 README 都寫得很清晰，但也有少數寫得難以理解。
README 是 Repository 的門面，這是毋庸置疑的。創建一個好的自述文件，可以向用戶（包括使用者和開發者）顯示基本信息，但不應該用他們可能不需要的內容來淹沒他們。
筆者認為應該從一開始就認真對待 README，而不是在最後(專案收尾之際)才一股腦地將資訊灌入，這樣會降低其品質。
Guide 你知道對專案來說，README.md 有多麼重要嗎？ ── 工程師血淚史 README 的藝術 Markdown + Vscode Markdown All in One Markdown Preview Github Styling Template README-Template.md GitHub README Templates Strategy 為誰而寫 必須意識讀文件的人分成使用者和開發者，README 在佈局上要有明確的邊界。
以使用者角度 Tutorial Reference 以開發者角度 環境設定/測試/部署/發布方法 開發流程/編碼規範等 避免 README 過長 這個視專案而定，當 README 內容越來越多時可以考慮將其拆分至其他文檔，而 README.md 則改做為文檔的索引頁。
README.md RELEASELOG.md CHANGELOG.md CONTRIBUTING.md ./docs/Tutorials/xx.md ./docs/Examples/xx.md 避免 Header 過度使用 原本寫作時會下意識的使用不少的三級標題 ### Header
## Header2 ### Header3 分段.</description></item><item><title>Algorithm - Note</title><link>https://HoshikawaRyuukou.github.io/posts/algorithm-note/</link><pubDate>Thu, 30 May 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/algorithm-note/</guid><description>Books fucking-algorithm hello-algo Repo The Algorithms</description></item><item><title>Regex - Note</title><link>https://HoshikawaRyuukou.github.io/posts/regex-note/</link><pubDate>Wed, 29 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/regex-note/</guid><description>Guide 三十分钟正则表达式教程 Tools RegExr: Learn, Build, &amp;amp; Test RegEx</description></item><item><title>Node.js - Note</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-note/</link><pubDate>Sun, 26 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-note/</guid><description>Guide Node.js究竟是什么？初学者指南 coreybutler/nvm-windows nvm-windows 管理 Windows Node.js 版本 [指令] npm cli &amp;amp; package.json 解决Node.js的命令行输出中文乱码问题（也适用于Electron） Module 什麼是前端模組化？ Multitasking Worker Threads in Node.JS Worker Threads : Multitasking in NodeJS Node.js Worker Threads Vs. Child Processes: Which one should you use?</description></item><item><title>Game Design - Inspiration</title><link>https://HoshikawaRyuukou.github.io/posts/game-design-inspiration/</link><pubDate>Thu, 23 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/game-design-inspiration/</guid><description>美術 坦輸療（坦克，輸出，治療師）的小冒險 機制 ティンクルスターナイツ　種族交流会地獄級なんですが Webbed ハンマーハートデリバリ― Remembery – Memory game pairs 鬥技場的阿利娜</description></item><item><title>Slot Design - Note</title><link>https://HoshikawaRyuukou.github.io/posts/slot-design-note/</link><pubDate>Wed, 22 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/slot-design-note/</guid><description>Guide SLOT設計王文章導讀 - SLOT設計王 Slots设计攻略导读 Know Your Slots 游戏中的伪随机 随机游走的赌徒是如何赔光的 How Slot Machines Work: Virtual Reel Mapping 抽卡体验设计：关于盲盒、抽卡、开箱的一切 Framework Publications | Slot Designer hankpan-dev/slotkit sta-ger/pokie Sample Casino Roulette Game Spotlight Pixel Farm by Twist Gaming</description></item><item><title>Game Design - Note</title><link>https://HoshikawaRyuukou.github.io/posts/game-design-note/</link><pubDate>Fri, 03 May 2024 21:06:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/game-design-note/</guid><description>Community IGDSHARE | 獨立遊戲開發者分享會 Blog 飛鳥涼不涼的遊戲營運觀察小站 THAT GAME DESIGNER - 遊戲設計師 游戏葡萄 Dev Blog QualiArtsエンジニアブログ Happy Elements株式会社 カカリアスタジオ Rank APPLION UI Interface In Game | Collection of video games UI | Screenshots and videos ゲームUIブログ Interview Nexon 《蔚藍檔案》的作曲家們 - #1 Nexon 《蔚藍檔案》的作曲家們 - #2 Nexon 《蔚藍檔案》的作曲家們 - #3 [訪談] 蔚藍檔案的過去、現在和未來（上） [訪談] 蔚藍檔案的過去、現在和未來（下） 淺談《Celeste》的教學引導設計與機制設計 《Celeste》如何打造Madeline的優異動態感？</description></item><item><title>Phenomena - Note</title><link>https://HoshikawaRyuukou.github.io/posts/phenomena-note/</link><pubDate>Tue, 30 Apr 2024 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/phenomena-note/</guid><description> 達克效應（DK Effect）的美麗錯誤 — — 對無知的無法認知：愚昧之巔、絕望之谷 一山還有一山高：談眼鏡蛇效應（Cobra Effect）</description></item><item><title>Javascript_TypeScript - Javascript Note</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-javascript-note/</link><pubDate>Mon, 29 Apr 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-javascript-note/</guid><description>Style Google JavaScript Style Guide Basic 作用域(scope)解說：let, const, var有什麼差？ Value與Reference的差異解說 async/await JavaScript 中的 async/await 是什麼？和 promise 有什麼差別？ Event Loop JavaScript Event Loop解說：單執行緒還能異步運算？ 請說明瀏覽器中的事件循環 (Event Loop) Object 為什麼推薦用 structureClone 在 JavaScript 做深拷貝? Promise Promise 是什麼？有什麼用途？ Others 前端 JavaScript 代码保护？！</description></item><item><title>Javascript_TypeScript - TypeScript Note</title><link>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-typescript-note/</link><pubDate>Mon, 29 Apr 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript_typescript-typescript-note/</guid><description>Style Google TypeScript Style Guide Tool JSON to TypeScript Basic TypeScript 物件中的 public, private, protected, static, readonly TypeScript – Using Disposable Coding guidelines 使用 undefined。不要使用 null。 tsc &amp;ndash;project tsconfig.json : 使用當前目錄下的 tsconfig.json &amp;ndash;showConfig : 檢視該目錄的 tsconfig.json (包含繼承的數值)</description></item><item><title>Unity - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/unity-packages/</link><pubDate>Sat, 13 Apr 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-packages/</guid><description>Package Manager Installing Packages using UPM Package manager -&amp;gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -&amp;gt; Packages: My Registries -&amp;gt; Install Guide Unity中 .asmdef文件的作用 使用OpenUPM发布自己的Unity项目 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM 【Unity】Package Manager活用術 Package Collection killop/anything_about_game baba-s/awesome-unity-open-source-on-github Animation PrimeTween Async UniTask Debug UnityIngameDebugConsole Dependency Injection VContainer Dialogue YarnSpinner-Unity Editor NaughtyAttributes Alchemy HotFix HybridCLR Localization Lean Localization Media UnityNativeCamera Messaging MessagePipe Particle Effect ParticleEffectForUGUI Persistence PlayerPrefs Editor &amp;amp; Utilities Resource Management YooAsset Rx (Reactive Extensions) UniRx R3 Serialization Newtonsoft.</description></item><item><title>VScode - Note</title><link>https://HoshikawaRyuukou.github.io/posts/vscode-note/</link><pubDate>Sat, 30 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/vscode-note/</guid><description>Diagrams Draw.io Integration Software Diagrams - Plant UML vs Mermaid Mermaid Doc Encoding VS Code採用Code Runner遇到的 Output中文亂碼問題 (Python) Display Visual Studio Code ( VS Code) 切換成中文版 Extensions Code Runner :emojisense: Hot Keys (Windows) 打開快捷鍵設定 : Ctrl + K Ctrl + S</description></item><item><title>Windows - Note</title><link>https://HoshikawaRyuukou.github.io/posts/windows-note/</link><pubDate>Fri, 29 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/windows-note/</guid><description>Disk 如何在Windows 10中刪除Hiberfil.sys（休眠）檔案 Shortcut Windows 11 顯示與清除歷史記錄 Other windows为什么有两个命令行工具？命令提示符与PowerShell有什么区别？</description></item><item><title>Unity - Basic - WebGL</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-webgl/</link><pubDate>Sat, 09 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-webgl/</guid><description>前述 使用 Unity 2022.3 開發，Unity 2022.1 在 iPhone/Android 上運行時不再顯示警告。似乎可以逐漸用於智慧手機專案。 Context 是 2D 小遊戲，以 webgl 1 輸出，暫時不需要 webgl 2 畫面效果。 Guide Unity User Manual 2022.3 (LTS)Platform developmentWebGL Unity WebGLビルドメモ - フレームシンセシス Unity 製 WebGL ゲームを AWS でお手軽公開 Unity WebGL 微信小游戏适配方案(公测) Template (Unity) Better Minimal WebGL Template Tests Unity WebGL Loading Test Instant Game Meta Instant Games Unity Instant Game Recommended Basic Todo 資源使用 Assetbundle 分包 資源限制下載數 ( 10個以內 ) 資源緩存 啟動封面範本修改 閒置時段下載資源 wasm 分包 (方案尋找中) Others 【Unity】WebGL開発時の注意事項 #Unity 游戏一键打包 #Facebook小游戏 解决方案 My WebGL assets Unity Webgl 问题总结 UnityWebGL移动端兼容性说明 Unity发布webgl获取浏览器的URL Unity WebGL で WebSocket を使う</description></item><item><title>Unity - Package - UniTask</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-unitask/</link><pubDate>Sat, 10 Feb 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-unitask/</guid><description>前述 UniTask - Unity 中實現效能最好的 async/await 的函式庫
Cysharp/UniTask Unity 中預設的非同步實現是 - Coroutine 協程，但協程有以下缺點
無法使用回傳值，需使用 callback 來解決。 異常處理很困難，因為不能在 try-catch 區塊內使用 yield。 需透過 MonoBehaviour.StartCoroutine 才能啟動。 UniTask 相較於 C# 原生的 Task 做了以下改進
刪除了 Task 在 Unity 不需要的功能。 非 MonoBehaviour 裡也能實現非同步。 記憶體/ GC / Unity PlayerLoop 等方面做最佳化。 UniTaskTracker 提供編輯器上可視化追蹤 await 狀態，這對於檢查是否有洩漏很有用。 UniTask 官方文件的基本功能寫得相當清楚，並附上一些入門介紹
UniTaskを使おう！ UniTask機能紹介 以下紀錄幾個重點主題
Awaiter UniTask 已經實作了相當豐富的 Awaiter 擴充，有需要自訂的可以參考以下規範
.NET 中什么样的类是可使用 await 异步等待的？ Thread UniTask.SwitchToThreadPool 允許後續處理在執行緒池中進行。 UniTask.SwitchToMainThread 切換到主執行緒，不會等待下一幀。 也可以使用 UniTask.Yield 切換到主執行緒，但它總是等待一幀。 但目前尚未有使用到的情境，之後有遇到再嘗試。</description></item><item><title>Unity - Basic - Android Build</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-android-build/</link><pubDate>Sat, 03 Feb 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-android-build/</guid><description>Settings gradleTemplate.properties : 專案的全域 Gradle 配置。 AndroidManifest.xml ：用於向 Android 構建工具、Android 作業系統和 Google Play 描述應用的基本資訊。 launcherManifest.xml 定義應用的啟動配置資訊 mainTemplate.gradle：自定義 Android 專案的 Gradle 構建過程，包括添加依賴項、修改編譯設定、配置簽名資訊等。 launcherTemolate.gradle ：包含有關如何構建 Android 應用程式的指令 baseProjectTemplate.gradle：所含的配置會在其他所有範本/Gradle 專案之間共用 Ref Unity 不通過Android studio 打包接SDK</description></item><item><title>Unity - Basic - AndroidJNIModule</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-androidjava/</link><pubDate>Sun, 28 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-androidjava/</guid><description>前述 這次的業務需求是
將 Google Play Install Referrer 接入 Unity
目前有使用到 AndroidJNIModule 中的
AndroidJavaClass AndroidJavaObject AndroidJavaProxy 但中途採了不少坑，特此紀錄一下。
基本知識 UnityEngine.AndroidJNIModule How to Create Android Java Callbacks to C# in Unity UnityからAndroidのクラスや関数を呼び出す AndroidJavaClass 可以實例化 Java 類、調用 Java 類的靜態方法，以及訪問 Java 類的靜態屬性。 AndroidJavaObject 創建 Java 對象的實例。 AndroidJavaProxy 允許在 Unity C# 腳本中實現 Java 接口。 允許我們在 Java 中調用方法，這些方法將調用 C# 類上的 匹配 方法。 注意 函數名匹配 (建議直接看 source code 裡面的值，本此次就遇到 官方文件與 jar 為匹配) android.os.Build.VERSION 將意味著要到一個公開類 android.os.Build$VERSION 將意味著進入一個內部類</description></item><item><title>Unity - Service - Google Play Install Referrer</title><link>https://HoshikawaRyuukou.github.io/posts/unity-service-google-play-install-referrer/</link><pubDate>Thu, 25 Jan 2024 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-service-google-play-install-referrer/</guid><description>簡述 Play Install Referrer
Play Install Referrer API : 非 Kotlin / Java 用戶使用 Play Install Referrer Library : 將上者封裝更方便 Kotlin / Java 使用 透過該服務能對 App 的下載與使用者進行歸因分析，用於評估推廣服務得成效，進而提升推廣效果與報酬率。
舊版 Play Install Referrer 在使用者下載應用程式後透過廣播傳送包含歸因參數的訊息。然而廣播的不可靠性和安全性問題，目前不再建議使用這個版本。 新版 Play Install Referrer 直接訪問本機 Google Play 應用程式商店中的記錄，索取 referrer 值，因此更加可靠。 快速上手 Unity 專案: 將依賴加在 maintemplate.gradle
dependencies { implementation(&amp;#34;com.android.installreferrer:installreferrer:2.2&amp;#34;) } 因為官方 API 文件寫的不全，建議到以下網站直接下載 aar 查看 jar 來對接 API
Google&amp;rsquo;s Maven Repository Maven Repository 使用服務的工作流為如下
建立連線 等待 callback 連線成功 索取 referrer 關閉連線 Referrer 格式 https://play.</description></item><item><title>Software Design - Architecture - VIPER</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-architecture-viper/</link><pubDate>Fri, 19 Jan 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-architecture-viper/</guid><description>簡述 VIPER (View-Interactor-Presenter-Entity-Router)
iOS VIPER架構實踐(一)：從MVC到MVVM到VIPER VIPER，更清晰的架构，解决复用和测试问题的利器系列1：VIPER架构演进史 有很多種實作流派，下圖是我比較偏好的模式呈現
VIPER 借鏡了 CA (Clean Architecture) 的思想為 MVC 提供一個新的設計方案
Entity 對應原本的 Model Controller 責任過重 -&amp;gt; 將業務邏輯移至 Interactor 並提高重用性 Controllers 之間耦合 -&amp;gt; 將導航邏輯移至 Router Presenter 作為 Binder 將 View / Interactor / Router 整合 啟發 VIPER 是筆者學習架構路上很重要的一個過渡，有以下兩點的思想轉變
顆粒度更細的單一職責 Interactor 封裝業務的概念在純 MVX 中是無法直接體會到，因此對之後學習 CA 時起了很大的緩衝，不然對於 Usecase 的設計應該會很不適應。
重視 Navigation 在學習 CA 中始終沒題到 feature/componet module 之間是如何互動的，也是在回頭複習 VIPER 時才重新意識到 Router 的重要性。當沒有特別規劃 Navigation 時很容易會造成 module 之間的耦合。</description></item><item><title>Unity - Service - Cloud Diagnostics</title><link>https://HoshikawaRyuukou.github.io/posts/unity-service-cloud-diagnostics/</link><pubDate>Tue, 16 Jan 2024 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-service-cloud-diagnostics/</guid><description>簡述 Official Home Page Official Doc 監控崩潰和異常報告 測試人員和應用使用者能直接提供用戶報告 啟用成本極低且非侵入式 有免費套餐，Personal 常規操作應該是沒問題，一旦超出了免費額度，系統將要求添加付款方式以繼續使用服務 快速上手 Cloud Diagnostics エラーやクラッシュを記録し、バグ特定の手助けになるUnity公式の無料サービス Unity Cloud Diagnostics UnityエディタやUnityで作ったゲームを強制的にクラッシュさせる方法 注意 Apple&amp;rsquo;s privacy survey Google Play data safety disclosures for Cloud Diagnostics</description></item><item><title>Unity - Environment</title><link>https://HoshikawaRyuukou.github.io/posts/unity-environment/</link><pubDate>Tue, 16 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-environment/</guid><description>⚠️ 指令操作會有過時/版本問題不在以下例出
VSCode 移除 Visual Studio Code Editor 已經停止維護 安裝 Visual Studio Editor 升級至 2.0.20 以上 Mac (M2) 安裝 dotnet sdk，須注意是否適用 ARM | ref 安裝 Mono | ref 安装 xcode 更新 Homebrew 更新 Ruby 至 3.x 並配置環境變數 (系統預設是 2.x) | ref 僅參考 ruby 更新部分 更新 gem 移除 CocoaPods | ref 安裝 CocoaPods ⚠️ 目前會有 VSCode 未完全關閉又重啟而導致 dotnet sdk 配置失效的狀況</description></item><item><title>Unity - Package Manager - Modify A Package</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-modify-a-package/</link><pubDate>Fri, 12 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-modify-a-package/</guid><description>情境 有需要客製化 Unity 官方 / git 直接導入 的 Package 時
操作 至 ProjrctRoot\Library\PackageCache 找到目標的 Package 剪下貼上至 ProjrctRoot\Packages 即可 Ref How can I modify built-in packages? Unity - 如何修改一个 Package 或是如何将 Package Local化</description></item><item><title>Unity - Package Manager - Private GitHub Repository</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-private-github-repository/</link><pubDate>Sun, 24 Dec 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-private-github-repository/</guid><description>情境 想分享私有庫但又不想去更改團隊或人員權限，Github 提供 Fine-Grained Token 能做到客製化的權限控制
操作 至 GitHub &amp;laquo;帳戶設定&amp;raquo;（非儲存庫設定） Developer Settings -&amp;gt; Personal Access Tokens -&amp;gt; Fine-Grained Tokens 生成 Token (Read-Only Permission for the repo Content). &amp;#34;com.yourusername.yourpackage&amp;#34;: &amp;#34;git+https://x-oauth-basic:&amp;lt;token&amp;gt;@&amp;lt;repo&amp;gt;?path=&amp;lt;folder&amp;gt;&amp;#34; Ref Install Unity Package from a private GitHub repository</description></item><item><title>Unity - Package - External Dependency Manager for Unity (EDM4U)</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-external-dependency-manager-for-unity-edm4u/</link><pubDate>Wed, 08 Nov 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-external-dependency-manager-for-unity-edm4u/</guid><description>前言 Google 停止維護 Game Package Registry (GPR) 導致不能直接使用 Package Manager 導入包。必須到封存檔網站下載「.tgz」手動導入。
Google Unity 套件 Install a package from a local tarball file 其他的相關的 Google Service 依賴(AR/Firebase/Google Play等)也可以用此方法導入。
設定 Assets &amp;gt; External Dependency Manager &amp;gt; Android Resolver &amp;gt; Settings 啟用這三個 Patch 並至 Player Settings &amp;gt; Publishing Settings 啟用以下選項 Auto resolution Assets &amp;gt; External Dependency Manager &amp;gt; Android Resolver &amp;gt; Force Resolve 後會去收集專案所有 Editor 資料夾下的 *Dependencies.xml 加到 mainTemplate 中</description></item><item><title>Unity - Basic - Asset Management</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</link><pubDate>Sat, 09 Sep 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</guid><description>AssetBundle Assets, Resources and AssetBundles Case Studies of Unity AssetBundle Efficient Encryption Addressable Frameworks Addressables 是在 AssetBundle 的基礎上對操作進行更友善的封裝，AssetBundle 有很多要小心的地方
AssetBundle 卸載 Addressable System 主要改善幾點
透過 name/label，而是不與資源直接連結，減少因移動或重命名資產而出錯的機會。 本地或是異地都可以追踪。 簡化打包和依賴管理(name/label/group/catalog)。 較好的記憶體管理機制(引用計數)與性能分析系統。 不同 Framework 在常規操作上大同小異，可以從資源最多的 Addressables 做觀念入門
Unity Addressables资源管理方式用起来太爽了，资源打包、加载、热更变得如此轻松（Addressable Asset System | 简称AA） Unity - Addressables项目总结（一）：基础工作流 Unity - Addressables项目总结（二）：业务需求 静态包、动态包有什么区别？何时使用增量更新？Addressables 更新流程大梳理 Repo Addressables tuyoogame/YooAsset Extra 为什么抛弃了 Addressable</description></item><item><title>Software Design - Pattern - ViewModel</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-viewmodel/</link><pubDate>Sun, 27 Aug 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-viewmodel/</guid><description>前述 此篇的實作參考到以下文件 (提到不少 Presentation layer 設計原則)
Android Developers 文件/指南/UI 層
該文件的更新頻率算高且會與時俱進，筆者印象中其架構設計從 MVVM -&amp;gt; Domain/Application Driven 設計，可以看出主流架構有產生變化。之後的討論雖然使用 ViewModel 但不會詳細介紹 MVVM 的細節，如果對 MVX 系列不熟，可以先讀筆者之前的文章 &amp;laquo;通用設計 - Pattern - MVP&amp;raquo; 裡面的 References。
探索 回到正題，筆者在最近的業務上遇到
如何在 服務端未完成 的情況下，讓 Client 獲得完整的體驗流 ?
以下用交叉反問的方式來分析問題
Q: 沒有服務端那資料來源哪來 ? A: 使用假資料
Q: 當表現層依賴的是 IService Interface 使用假資料時需要實作什麼 ? A: 只需要實作一個 FakeService 來產生假資料即可
Q: 當想要將業務與表現解耦時，很常使用中介者的手法來黏合兩者，如果使用標準的 MVP 實做，Presenter 實際做了哪些事呢 ? A: 監聽 View 事件/ 與 Service 互動/ 管理畫面狀態/ 呼叫 View 刷新</description></item><item><title>Unity - Basic - Memory Profiler</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</link><pubDate>Sun, 30 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</guid><description>注意 由於Unity 無法將性能分析器本身佔用的記憶體與運行模式的記憶體完全分開。要獲得應用程序的更精確數字和記憶體使用情況，應在要運行應用程序的目標設備和操作系統上分析應用程序。 如果需要在記憶體受限的平台上運行應用程序，設備上的總駐留量對於檢查低記憶體警告和由於記憶體耗盡而強制關閉非常有用。作為一般規則，它不應超過設備上可用總物理內存的 70%。 偵測 Leaked Managed Shell 的功能在 Memory Profiler 1.1.0-pre.1 Ref Memory Profiler Memory Profiler | 1.1.0-pre.1 - Unity - Manual Unity でメモリリーク？ Memory Profiler で Leaked Managed Shell をチェックしてみよう！ Inspecting memory with the new Memory Profiler package Memory Profiler로 애플리케이션의 물리적 메모리 사용량 분석 Unity内存分析与优化实践(1.1版本前)</description></item><item><title>Git - Rebase</title><link>https://HoshikawaRyuukou.github.io/posts/git-rebase/</link><pubDate>Sun, 16 Jul 2023 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-rebase/</guid><description> 之前筆者一直以為 rebase 是進行類似 剪下貼上 的操作，但實際上是 複製貼上
情境 合併時不會像 merge 時會有 commit 的節點 想整理 還沒推出去 的 commit 可以使用 避免修改已經推出去的歷史 如何取消操作 使用 reflog 列印出所有「歷史紀錄」找到 rebase 的前一個 commit id，並進行 reset 即可
git reflog git reset XXXXXXX --hard 此外當進行比較危險操作時 git 會額外紀錄前一個 head 於 ORIG_HEAD，因此也可以直接執行以下，來達到同樣效果
git reset ORIG_HEAD --hard Ref 另一種合併方式（使用 rebase） git rebase 用法 git rebase -i (drop) git rebase -i (pick) git rebase -i (reword)</description></item><item><title>Git - Pull Request</title><link>https://HoshikawaRyuukou.github.io/posts/git-pull-request/</link><pubDate>Fri, 14 Jul 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-pull-request/</guid><description> 有的環境也稱 Merge Request
情境 開發產品時一般會挑選固定一個分支做為可以上線的正式版本分支(master)，需注意的是在進行多人協同開發時，讓每個人都可以 Commit 到專案正式上線的分支不是個好的做法。
可以透過 pull request 方式控管權限，由負責管理這個專案的人收到其他開發者的 pull request 並確認無誤後便可進行合併，來確保產品分支處於隨時都是可上線的狀態。
參與開源專案時，在創建 pull request 之前，建議先在本地分支上運行 git rebase 命令，確保你的更改基於最新的進度以降低審查者的理解難度。
Ref 與其它開發者的互動 - 使用 Pull Request（PR）</description></item><item><title>Unity - Basic - Preprocessor Directives</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-preprocessor-directives/</link><pubDate>Fri, 07 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-preprocessor-directives/</guid><description>前述 中文稱作 : 前置處理器指示詞
筆者最近接觸到的遺舊專案中發現裡面大量地使用 條件式編譯
#if DEBUG Console.WriteLine(&amp;#34;Debug version&amp;#34;); #endif 筆者之前有使用也基本只使用 定義區域 (排版效果)
#region MyClass definition public class MyClass { static void Main(){...} } #endregion Unity 在處理平台裝置時也蠻常會出現的
public class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(&amp;#34;Unity Editor&amp;#34;); #endif #if UNITY_IOS Debug.Log(&amp;#34;iOS&amp;#34;); #endif #if UNITY_STANDALONE_OSX Debug.Log(&amp;#34;Standalone OSX&amp;#34;); #endif #if UNITY_STANDALONE_WIN Debug.Log(&amp;#34;Standalone Windows&amp;#34;); #endif } } 問題 那前置處理器指示詞有什麼問題呢? (參考日文那個 Ref 有比較明確的 Case)
編譯版本至少會是 2^(指示詞的分類數)種，持續的調試和測試變得非常困難。 Unit Test 中難以使用。 編譯檢查不起作用。 當巢狀結構出現時可讀性將大為降低。 上述這些狀況都會導致 延後發現問題的時間 !</description></item><item><title>Unity - Basic - iOS plug-in</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</link><pubDate>Wed, 05 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</guid><description>前述 這次的業務需求是
取得 ios 實機的 &amp;ldquo;地區&amp;rdquo;，並讓 C# 能拿到 Swift 所返回的字串
因為在 ios 的環境下 unity / C# 拿到的值並不正確。此外筆者對 Swift / Objective-C 幾乎零基礎，目前只針對一些教學文件做些修改，之後有機會更熟再回頭深究。
實作 SwiftDeviceInfoPlugin.swift 須放置於 Plugins\iOS 之下 import Foundation public class SwiftDeviceInfoPlugin { public static func getRegion() -&amp;gt; String { return Locale.current.regionCode ?? &amp;#34;Unknown&amp;#34; } } @_cdecl(&amp;#34;getRegion&amp;#34;) public func getRegion() -&amp;gt; UnsafePointer&amp;lt;CChar&amp;gt;? { let region = strdup(SwiftDeviceInfoPlugin.getRegion()) return UnsafePointer(region) } @_cdecl(&amp;ldquo;getRegion&amp;rdquo;)：這是一個 Swift 標記，表示下面的函數將使用cdecl樣式的名稱綁定。您只需知道此屬性向 C 公開了一個 Swift 函數 UnsafePointer&amp;lt;CChar&amp;gt;?，它是一個可為空的指向 C 風格字串（CChar）的指標。這使得 Swift 能夠以與 C 相容的方式提供訪問區域資訊的介面。 strdup() 用於創建預返回的字串的副本，並在堆上分配其記憶體。 public sealed class IOSDeviceInfoProvider : IDeviceInfoProvider { public string GetRegion() { return new System.</description></item><item><title>Software Design - Pattern - Service Locator</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-service-locator/</link><pubDate>Wed, 28 Jun 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-service-locator/</guid><description>前述 Service Locator 確實也是 IoC 的一種實作方式，不過採用的是 依賴尋找(Dependency Lookup) 的設計。 筆者之前有一陣子蠻常使用這 pattern，那時對 DI 與 IoC 的概念並不熟悉，只覺得這樣使用依賴變得很方便。
因為我可以在任何地方直接這樣取用資源
var target = ServiceLocator.Resovle&amp;lt;Target&amp;gt;(); 這樣的寫法有以下問題 :
透過 ServiceLocator 因為這個取用資源的過程是隱性的，不容易被直接發現。 想用誰就拿誰這件事也有點危險，Ex: View 可以拿到不屬於 Presentation layer 該碰的對象。 所以當 DI 與 IoC 的概念熟悉後，並且使用 DI / IoC Container 後就漸漸不使用這 pattern 了。
應用 但這次工作上反而覺得 Service Locator 可以勝任從 Singleton 過渡到 DI / IoC Container 的中繼階段。
因為這次接觸到的專案嚴重依賴 Singleton，且組員也已習慣 Singleton 的寫法了，要直切換到 DI / IoC Container 會有不小的陣痛期(當然實務上能不能切又是另一個故事了)。
於是筆者想起了 Service Locator，有以下理由
因為在使用上就很像是 Singleton 筆者希望組員能快速感受到 IoC 所帶來的紅利 集中管理依賴 實作 此模式使用稱為「服務定位器」的中央註冊表，它根據請求返回執行特定任務所需的對象。</description></item><item><title>Network - WebP</title><link>https://HoshikawaRyuukou.github.io/posts/network-webp/</link><pubDate>Thu, 22 Jun 2023 20:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/network-webp/</guid><description>設計目標 Google 以縮減線上影像的檔案大小為目標，同時維持不輸 JPEG、PNG、GIF 格式的圖片品質。
網站的瀏覽與速度不僅影響使用者的耐心，也會影響 SEO 的排名與檢索，透過顯著縮減相片和圖形大小，網頁就能加快載入速度，提供更優質的使用者體驗。
並持續在優化 WebP 2: experimental successor of the WebP image format
壓縮方式 有損壓縮 無失真壓縮 Ref WebP 檔案 Now in REALITY Tech #6 画像をWebP形式に対応した話 Now in REALITY Tech #37 UnityでWebPを扱えるようにした話</description></item><item><title>Test - Note</title><link>https://HoshikawaRyuukou.github.io/posts/test-note/</link><pubDate>Sat, 03 Jun 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/test-note/</guid><description>以下觀點不一定適用於各專案，請因地制宜。
在開始寫 code 之前 測試文化: 底下的人願意寫，上面的人願意給時間。 測試的順位: 從商業價值最高的功能開始。 較低的測試價值 需求尚未明朗又必須交付成果。 取決於經營者對價值的認定，其實跟程式沒多大關係。 不是所有的程式都可以測試，有時候為了測試，程式需要先重構成可以測試的樣子。 Unit Test 手動測試 慢 不穩定 脆弱 不方便 問題出在不可控
希望是可控的 可重現一樣結果 以整體專案的角度來看單元測試 專案內分為 不可控 與 可控 兩部分
不可控: 檔案/資料庫/第三方套件 可控: 除不可控以外自己所寫的部分 可控內分為 不可測 與 可測 兩部分
不可測: 與不可控接觸的部分，因此會希望這部分越單純越好。 可測: 為專案內價值較高，須小心維護的部分。 目標: 可測範圍盡量大，不可測盡量小。
單元測試相較於手動測試的優勢 ? 可以輕鬆的跑完多個 Test Cases Static 要不要測 ? 直接使用真實行為 透過測試框架強測 重構/隔離/依賴注入 Ref 一次搞懂單元測試、整合測試、端對端測試之間的差異 一起設計出可被單元測試的程式碼吧！ [Day 2]Unit Testing 簡介 .NET Core 和 .NET Standard 的單元測試最佳做法</description></item><item><title>Unity - Package - xLua</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</link><pubDate>Sun, 28 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</guid><description>本次操作 xLua 主要是做熱更方案的評估測試，筆者目前還是偏好使用 HybridCLR。
Official Tencent/xLua 評估 使用 lua 仍是目前主流/穩定做法 (畢竟也行之有年了)。 邏輯操作可能要移師到 lua 側。 缺少 ide 支援如果要在 lua 側 進行 unity 相關操作時，維護/除錯成本極高。 Example 在 lua 側進行 unity 相關操作
local speed = 10 local lightCpnt = nil function start() print(&amp;#34;lua start...&amp;#34;) print(&amp;#34;injected object&amp;#34;, lightObject) lightCpnt= lightObject:GetComponent(typeof(CS.UnityEngine.Light)) end function update() local r = CS.UnityEngine.Vector3.up * CS.UnityEngine.Time.deltaTime * speed self.transform:Rotate(r) lightCpnt.color = CS.UnityEngine.Color(CS.UnityEngine.Mathf.Sin(CS.UnityEngine.Time.time) / 2 + 0.5, 0, 0, 1) end function ondestroy() print(&amp;#34;lua destroy&amp;#34;) end</description></item><item><title>Unity - Editor - ScriptedImporter</title><link>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</link><pubDate>Sat, 27 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</guid><description>用途 使用C# 為Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。 注意 Scripted Importer 無法處理已由 Unity 本身處理的文件擴展名。 Example 這裡將 .lua 以 TextAsset
using UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, &amp;#34;lua&amp;#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( &amp;#34;text&amp;#34;, subAsset ); ctx.SetMainObject( subAsset ); } } Ref Scripted Importers [Unity] 资源工作流程 - ScriptedImporter</description></item><item><title>Software Design - Principle - Inversion of Control (IoC)</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-principle-inversion-of-control-ioc/</link><pubDate>Fri, 05 May 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-principle-inversion-of-control-ioc/</guid><description>反轉了什麼 ? 依賴對象的獲得被反轉了
在應用程式中設計總會有多個單元需要合作的情況，這時就會有配置依賴的需求，但這個配置應該由需求方來處理嗎?
讓依賴需求方自己處理最簡單的方式就是實例化(new)，但這可能會有以下問題:
不同需求方重複 new 是否會有浪費的問題? 能被共用嗎? 方便共用嗎? 到處 new 來 new 去，依賴的管理變得很亂 那不如找一個單位負責來處理依賴配置。我不自己 new，而是別人 new 完後(注入給我/讓我查找)，這麼所帶來的好處:
資源複用更方便: 統一由容器創建或保存對象，不需要每個需求方都自己 new 一個新的。 建造/使用分離: 依賴需求方操作其依賴項來完成任務才是他主要的責任，如果還要處理依賴項的實例化，責任就模糊了，因此將依賴項的創建和配置的控制權交給 IoC Container。 為此需要有一個 IoC Container 來處理，通常容器包含以下操作：
Register：註冊類型和依賴關係 Resolve：創建並註入依賴關係 Dispose：管理生命週期 實踐方式 最常見的方式分別是 依賴注入（Dependency Injection，DI）與 依賴尋找（Dependency Lookup）。
依賴尋找 可以簡單理解為 依賴需求方 &amp;laquo; 主動 &amp;raquo; 使用容器來取得依賴。依賴需求方直接使用 Locator.Resolve 取得依賴，但這種作法有些爭議(反模式)，依賴需求方是不是有註冊的項目都能任意取得阿 ?
Service Locator 服務定位器是依賴尋找的典型實作。
依賴注入 透過注入依賴項讓 依賴需求方 &amp;laquo; 被動 &amp;raquo; 使用容器來取得依賴，常透過三種方式注入。
建構子(推薦) 屬性 方法 權限相對清晰(建構子注入)，能用依賴項的都在建構子給你了，不過你要額外new 其他東西也是沒人攔得住。
這個方式通常透過框架來處理，此外依賴需求方是不知道容器的存在(理想狀態，但有時會需要一些注入標記)。</description></item><item><title>Unity - Package Manager - Sample Workflow</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-sample-workflow/</link><pubDate>Sat, 22 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-sample-workflow/</guid><description>Package Samples 對應有些模組的操作比較複雜繁瑣，有時需要有一些 Sample 做參考。官方 Package Manager 有個 &amp;ldquo;半套&amp;rdquo; Sample 工作流，讓人不是很舒服。
官方文件
Sample 資料夾後面加了波浪號 (~) 告訴 Unity 忽略 Samples~ 文件夾中的內容，此類文件夾不使用.meta文件進行跟踪。忽略 Samples~ 對 Package 使用者是好的，畢竟不是每個人都需要。
但對 Package 開發者，畢竟 Samples 也是要進版控的，而這樣改名的作法會徒增一些重命名的提交也有點煩躁(除非在修改 Sample 的過程中完全不提交)。原先想說寫個 Samples ↔ Samples~ 切換的腳本就好，會一直有 meta 檔的警告(刪掉/改名都還是在)。
官方作法 論壇中的某篇討論才記載他們的做法(倒是加到文件中阿&amp;hellip;)
在內部確實使用了名為 Samples 的文件夾 (沒有 Samples~ ) 在推送新包版本之前通過腳本對其進行重命名(透過 CI ) OpenUPM 的作者也是使用類似的工作流，總之筆者也調整為上述的方式。
透過 GitHub Actions Workflow 調整目錄名 筆者不熟 GitHub Actions/ YAML/ 文件操作，但這種初階的操作就交由 chatgpt 代勞，幫我省去不少實驗成本。這裡的操作只是堪用，應該有更好的方式。
以下是筆者要求的條件
想透過 GitHub Actions 中的 workflow 完成 如果 forPackage 分支已存在則將其刪除 從 main 建立新的 forPackage 分支 Assets/Modules 的所有子目錄(同時有 &amp;ldquo;package.</description></item><item><title>Unity - Package - HybridCLR</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</link><pubDate>Tue, 11 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</guid><description>先備知識 Assembly Definition (Asmdef) Unity 2017.3 以上版本的提供功能，主要解決龐大的程序集編譯時效率問題。
具體內容建議閱讀 Doc - Assembly definitions
Assembly-CSharp.dll Unity 預設整合的 dll，專案內未被自定義 Asmdef 劃分的腳本都會被整合到 Assembly-CSharp.dll
簡述 HybridCLR focus-creative-games/hybridclr focus-creative-games/hybridclr_trial HybridCLR 筆者已經應用於工作環境好一陣子了(從 2.X 版本開始)，其最讓人驚豔的地方在於，過往的開發流幾乎不用更動(當然要好 Asmdef 的規劃)，僅在打包時調整一下工作流即可。
其極大簡化過往麻煩且效率不彰的熱更流程。xLua 和 ILRuntime 在筆者看來最難受的事是「侵入性」極強，搞得綁手綁腳。大家也都抱怨很久了，但也沒有其他可靠方案，直到 HybridCLR 出現。
快速上手 3.0 版本後流程優化得更順暢了，照著 文件 可以很快地感受到其威力。
注意 请问，Generate All、补充元数据的DLL更新的执行时机的最佳实践？ 怎么卸载热更dll CLI 規範中只能以 AppDomain 形式卸載所有 dll，不支持卸載單獨的 dll。而 il2cpp 是單例 AppDomain，因此這個要求是不符合規範的。要採用 HybridCLR DHE 的商業方案。不過筆者倒是不太擔心，畢竟 Unity client 通常不是需要常駐的應用，使用者也不太會把應用的每一個功能都點一遍，初估是還可以接受的。</description></item><item><title>Unity - Basic - DontDestroyOnLoad</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</link><pubDate>Mon, 20 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</guid><description>用例 被標記為 DontDestroyOnLoad 的物件場景更改時不會被破壞。
全域管理器：因為整個遊戲期間一直存在。例如，音效管理器、遊戲設定管理器或玩家數據管理器等物件可以在場景切換時保留，以確保它們的功能和數據在各個場景中持續存在。 持久性數據：如果你有需要在多個場景中共享的持久性數據，可以將存儲這些數據的物件標記為 DontDestroyOnLoad。例如，玩家的遊戲進度或全域的配置設置等數據可以在場景切換時保留，以便在不同場景中訪問和更新。 UI 元素：某些UI元素，如遊戲狀態面板、計時器或得分顯示，可能需要在多個場景中保留。通過將這些UI元素物件標記為 DontDestroyOnLoad，可以確保它們在場景切換時不會被銷毀，以便在不同場景中持續顯示和更新。 問題 記憶體管理問題：使用 DontDestroyOnLoad 將遊戲物件保留在多個場景中可能會導致記憶體洩漏。如果你的遊戲物件不再需要，但沒有被正確銷毀，它們將繼續存在於記憶體中，佔用系統資源，可能導致性能下降。 場景管理問題：DontDestroyOnLoad 會打破場景之間的清晰界限。場景是 Unity 中組織和管理遊戲邏輯的基本單位，每個場景都應該是相對獨立的。通過在多個場景之間保持物件，會增加場景之間的耦合性，導致代碼難以維護和測試。 Ref Object.DontDestroyOnLoad</description></item><item><title>AI - Art</title><link>https://HoshikawaRyuukou.github.io/posts/ai-art/</link><pubDate>Fri, 10 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-art/</guid><description>Guide Stable-Diffusion 彙整 - 瑆知識 社群 Civitai 畫廊 Prompt Search PixAI.Art AIBooru Lizardon1025 Channel 杰克艾米立 Prompt Prompt Viewer Danbooru tag group:posture SDXL Prompts 進階指南 (1) - 鏡頭視角距離 Extra ImgPilot 2vXpSwA7/iroiro-lora Stable-Diffusion - Lora-Block-Weight XERSON005:1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0 PERSON105:1,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0</description></item><item><title>Visual Design - Note</title><link>https://HoshikawaRyuukou.github.io/posts/visual-design-note/</link><pubDate>Thu, 02 Mar 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/visual-design-note/</guid><description>Color 如何找出好配色？照著這個步驟做，讓你的設計更具吸引力！！ 什么是更好的渐变？ Color Tools Stocksy Adobe Color Canva VIVID GRADIENT GENERATOR TOOL</description></item><item><title>Art - Drawing - Note</title><link>https://HoshikawaRyuukou.github.io/posts/art-drawing-note/</link><pubDate>Wed, 01 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/art-drawing-note/</guid><description>新手村 给画画爱好者的入门经验分享，当初有人告诉我该多好！ Community Pinterest Channel taco1704 hide channel【顔と体の描き方講座】 曲奇放克 Practice Line of Action Book ミニキャラの描き方　「ちまっとかわいい」を描く基本＆表現テクニック 分析 【舊版獵人】的美術真的強到爆嗎？用插畫家的角度來分析看看。 / HUNTER x HUNTER (1999)</description></item><item><title>Unity - WorkFlow - Build &amp; Publish</title><link>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</link><pubDate>Mon, 27 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</guid><description>Build repositories.cfg could not be loaded. Unable to find player assembly: XXXX\Temp\StagingArea\Data\Managed\UnityEngine.TestRunner.dll Cocoapodsの更新にハマった【Unity】 Device Quickly preview your game on Android device | Unity tutorial Publish Privacy policy for your game? No problem! (generate and publish) Publish your UNITY game on Google Play Store - 2023 guide Misc Library not loaded: @rpath/FBAEMKit.framework/FBAEMKit</description></item><item><title>Hugo - Note</title><link>https://HoshikawaRyuukou.github.io/posts/hugo-note/</link><pubDate>Sat, 25 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/hugo-note/</guid><description>Install Hugo 從零開始 環境安裝(Windows) Themes Hugo Themes Image Rendering Images in Markdown Preview of Hugo Site 以管理員權限開啟 cmd mklink /D images .\static\images Quick Start 至 Hugo github release 下載執行檔 設置環境變數 hugo version hugo new site MyFreshWebsite &amp;ndash;format yaml cd MyFreshWebsite git init git submodule add &amp;ndash;depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod theme: [&amp;ldquo;PaperMod&amp;rdquo;] hugo server</description></item><item><title>Software Design - Modularization</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-modularization/</link><pubDate>Wed, 22 Feb 2023 21:21:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-modularization/</guid><description>前述 首先幾篇文章是基於 Clean Architecture 的基礎，建議先閱讀以下連結已具備基礎知識
The missing chapter CA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture 連結 34章摘要心得，請先觀看裡面的圖表(重要) CA Modularization Multiple ways of defining Clean Architecture layers Package by Component with Clean Modules in Java Package by feature or component Vertical Slice Slices vs. Layers Restructuring to a Vertical Slice Architecture Vertical Slice Architecture, not Layers! Modular Monolith Majestic Modular Monoliths (強烈建議) Modular Monolith architecture (強烈建議讀完這個系列) 各 Package 策略的圖請參考上方連結 34 章摘要心得</description></item><item><title>Unity - Basic - Sprite and Atlas</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</guid><description>Sprite 【2Dゲームで必須】UnityのSprite（スプライト）の単位をわかりやすく解説 【間違えやすい】Unityの正しい画像サイズとは Atlas 【Unity】SpriteをパックするSpriteAtlasの使い方 目的 減少DrawCall 圖集將圖片打包為2的冪次方的素材大小，可以提升性能 減小包體大小 注意 Sprite Atlas V1 - Always Enabled 啟用圖集時 Edit Mode : reference the packed Textures Play Mode : reference the original unpacked Textures SpriteAtlas AssetBundle 來打包時，不要勾選 Include In Build</description></item><item><title>Unity - Basics</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basics/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basics/</guid><description>Set Up 【游戏开发环境】Unity使用Mac电脑开发，开发环境的搭建（Mac mini M1 | VSCode | Git | 好用工具） Analysis Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Animation Introduction to 3D Animation Systems Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity Build repositories.cfg could not be loaded. unity Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Canvas Designing UI for Multiple Resolutions Unity Canvas Scaler 组件的使用 Unity分辨率适配方案设置 Editor 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them?</description></item><item><title>Unity - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/unity-sites/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-sites/</guid><description>Blog Yucchiy&amp;rsquo;s Note コガネブログ 老刘@开发笔记 (:3[kanのメモ帳] Game Dev Beginner - Everyone Can Make Games LIGHT11 PG日誌 きゅぶろぐ やらなイカ？ はなちるのマイノート くものす ピクセルブログ ねこじゃらシティ YAMADA TAISHI’s diary L&amp;rsquo;s Blog Raspberlyのブログ 渋谷ほととぎす通信 LianBai Lightjiao的博客 unityでいってみよう！ Blog (Enterprise) CyberAgent Developers Blog | サイバーエージェント デベロッパーズブログ REALITY｜note Mirrativ Tech Blog QualiArtsエンジニアブログ Channel Code Monkey M Studio Coco Code Collection XINCGer/Unity3DTraining Forum Qiita|Unity Zenn|Unity Unity Learning Materials Unity3d - 幻想社区 「unity」の人気の記事一覧｜note Unityゲーム開発者ギルド Events Unity Meetup Unity Advent Calendar Unityユースクリエイターカップ Community unityroom</description></item><item><title>Software Design - Architecture - Clean Architecture</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-architecture-clean-architecture/</link><pubDate>Sat, 04 Feb 2023 20:03:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-architecture-clean-architecture/</guid><description>以下 Clean Architecture 簡稱 CA
這裡還是先引用 Uncle Bob 的分層圖 The Clean Code Blog - The Clean Architecture 筆者認爲可擴展性是系統架構的重要考量。畢竟應用程式會演化，必須不斷更新與修改系統以滿足新的需求，而 CA 是其中一種實現方針。筆者在這裡不會寫出詳細的介紹，想了解的可以參考 Ref 整理的連結或是 CA 相關書籍。
本文著重於促使筆者思考方式改變的幾個重要觀念。
依賴關係 相依性: 向內圈依賴，且盡量避免跨層依賴 (有些例外之後說明)。 Dependency Inversion Principle (DIP): 內圈定義介面，外圈實作。 基於這兩個規則所帶來的是
單向依賴流 : 紊亂的依賴流可能造成牽一髮動全身的窘境。尤其是當 Domain 去依賴到細節時。 延後實作 : UseCase/Adapter 都是依賴於應用層所開出的介面。因此業務/畫面能獨立開發，不用互相等待(理想狀態)。 而筆者在實作時的基本型架構通常如下圖(比較接近 CA 書中的另外一張圖，我這裡做了簡化)，Adapter 只分成 Input/Output Port。 Domain: 領域邏輯 UseCase: 應用邏輯 Domain + UseCase: 業務邏輯 InputPort: 用例功能使用方介面 OutputPort: 用例功能支援方介面 Adapter: 將外部與用例功能接合的膠水代碼 不過架構會針對不同情況做調整，細節參考另一篇文章
架構設計 - Clean Architecture and Modularization</description></item><item><title>Git - Note</title><link>https://HoshikawaRyuukou.github.io/posts/git-note/</link><pubDate>Sat, 04 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-note/</guid><description>GUI Clients Fork Common 两小时Git教程 Git忽略规则.gitignore不生效 配置 Git 处理行结束符 Workflow 如何做好分支管理，保证高效CI/CD？ 【GeekHour教程】分支管理和工作流模型 Git 進階應用 Submodule 與 Subtree，使用它們來拆分專案 Operation git revert 是如何让你丢失代码的？ 十分钟学会常用git撤销操作，全面掌握git的时光机 git hook git hook 是每次執行 git 操作時都會運行的命令或腳本。 如果 git hook 的執行失敗，則 git 操作將中止。</description></item><item><title>Github - Note</title><link>https://HoshikawaRyuukou.github.io/posts/github-note/</link><pubDate>Sat, 04 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/github-note/</guid><description>Profile 如何建立獨一無二的 GitHub Profile！與三個很酷的設計及應用 tandpfun/skill-icons Collaboration 十分钟学会正确的github工作流，和开源作者们使用同一套流程 GitHub Actions GitHub Actions 文档 GitHub Marketplace GitHub Actions: Limit which branches can deploy to an environment GitHub Packages GitHub Packages 文档</description></item><item><title>Software Design - Pattern - Guard Clauses</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-guard-clauses/</link><pubDate>Tue, 10 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-guard-clauses/</guid><description>目的 符合 Fail Fast 的原則，驗證條件並在不滿足條件時立即停止執行。 增加可讀性(更扁平)，減少了巢狀判斷。 例子請參考 Guard Clause Extra - Guard Class 將通用的保護子句封裝在一個專門的類是一種很好的做法，可重用邏輯並編寫更具可讀性的保護子句。
可參考這個庫 GuardClauses Extra - Value Object Stop using trivial Guard Clauses! Try this instead
文章作者避免瑣碎 Guard 的方式，是使用 Value Object，來避免域接受到無效參數。這個作法在筆者看來才是真正意義上的 Fail Fast。(YT評論區也建議閱讀，有許多不錯的討論)
但不可否認的 Guard Clause 作法在大多情況下是有益的。
Ref Guard Clause Implementation Patterns: Guard Clause GuardClauses Stop using trivial Guard Clauses! Try this instead</description></item><item><title>CSharp - Note</title><link>https://HoshikawaRyuukou.github.io/posts/csharp-note/</link><pubDate>Thu, 05 Jan 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/csharp-note/</guid><description>語法 C# 的一些冷知识（其一） C# 的一些冷知识（其二） 捨棄 - C# 基本概念 C#中 ??、 ?、 ?: 、?.、? 问号 Type C# 4.0：Covariance 與 Contravariance 觀念入門 Data Different ways to return data in C# ValueTuple ValueTuple 是 value type，所以它使用的記憶體空間使用在 program stack，因此使用不會有 garbage collection
Format 內插字串 Collection C# 回傳內部資料集合的幾種方式，考慮封裝與設計需求 Iterate over two collections of equal length foreach (var (cell, id) in cells.Zip(randomizedIDs, (key, value) =&amp;gt; (Cell: key, ID: value))) { idDict[cell] = id; cell.selectCallback = Select; } Utils Random var random_list = list.</description></item><item><title>Network - Note</title><link>https://HoshikawaRyuukou.github.io/posts/network-note/</link><pubDate>Wed, 04 Jan 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/network-note/</guid><description> 【白话科普】域名？网址？原来域名是这么个玩意啊！ DNS工作原理 | 什么是DNS 它如何工作 CDN是什么 | CDN的工作机制 数字签名和CA数字证书的核心原理和作用 VPN概念，技术原理和误区 哈希究竟代表什么？哈希表和哈希函数的核心原理 交换机的核心工作原理 | 集线器、2层交换机和3层交换机的主要区别</description></item><item><title>Software Design - Domain-Driven Design 初探</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-domain-driven-design-%E5%88%9D%E6%8E%A2/</link><pubDate>Thu, 15 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-domain-driven-design-%E5%88%9D%E6%8E%A2/</guid><description>必須先聲明筆者仍在學習中，以下屬個人觀點
動機 筆者發現在使用 Clean Architecture (CA) 時越來越力不從心，因此開始研究 Domain-Driven Design (DDD)，事出有因，列出幾點問題與對應方式。
重複的程式碼 主因是 貧血域模型 (Anemic Domain Model)，表示模型中幾乎只有 Get/Set，這導致了 Domain層 (業務邏輯) 滲透到 Application層 (應用邏輯)，某些對 Domain 的操作重複出現在多個的 Usecase (應用邏輯)。 重新分析系統，區分出不同上下文，設計充血域模型，將業務邏輯設計進去。 域模型的一致性問題 Domain 面對四面八方的操作，顯得很亂且充滿不確定(會不會模型之間的關係因為更改而被破壞) 引入聚合(Aggregate)來維持保護邊界內的不變條件。 Primitive Obsession 這會造成對模型的不信任，進而寫出一些防禦性程式設計。 引入值物件(Value Object)來確保不變性與自我驗證(即不正確就不應該存在)。 以上這幾點是筆者比較有感的。
概述與想法 Domain-Driven Design (DDD)，出自 Eric Evans 2003 年出版的一本書，以領域模型為中心來進行系統的分析設計。不是架構也不是技術，是一種方法論，可以搭配不同類型的架構來實現
Layered Architecture Hexagonal Architecture Clean Architecture (以下稱 CA ) Command Query Responsibility Segregation (CQRS) 原著中是使用 Layered Architecture 的架構作為示範，但該章的重點是在隔離 Domain，在 Google 的時候有所謂 &amp;ldquo;DDD 架構圖&amp;rdquo;，但筆者覺得不太精確，因為 DDD 主要的發力點是在 Domain，應該稱作 &amp;ldquo;OO架構以DDD實作Domain&amp;rdquo; 會比較合適。</description></item><item><title>Software Design - Pattern - Data Transfer Object (DTO)</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-data-transfer-object-dto/</link><pubDate>Sun, 11 Dec 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-data-transfer-object-dto/</guid><description>什麼是 DTO？ Data Transfer Object (數據傳輸對象) 是定義如何在應用程序之間發送數據的對象。它僅用於發送和接收數據，本身不包含任何業務邏輯。
為什麼使用 DTO？ 輕鬆收發 在沒有任何邏輯的基礎上，可以僅使用序列化與反序列化就保證對象的完整性和可傳遞性。
避免過度暴露訊息 對分層或模組來說，彼此間應盡量降低耦合。下圖以公園廁所報修為案例。
這個資料流由鄉公所傳到基層人員手上，中間經過兩個邊界
鄉公所 | 工程公司 =&amp;gt; DTO (公文) 工程公司 | 基層人員 =&amp;gt; DTO (簡訊) 每個單位的關注點不同，在意的資料也會不同，DTO 做為邊界兩方做最小程度的媒介，隱藏的不該被關注(敏感)的事
印章對工程公司並不是必要資訊 詳細的時間格式是對基層人員並不是必要資訊 在實作上常被用於轉換 DomainModol -&amp;gt; DomainDto
注意事項 類別數量增加，請自行評估使用情形
Ref Cutting Edge - Pros and Cons of Data Transfer Objects The DTO (Data Transfer Object) Data Transfer Objects Clean Architecture : why not using the entity as request model of the use case (interactor) Difference between Entity and DTO</description></item><item><title>Software Design - Pattern - Model View Presenter (MVP)</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-model-view-presenter-mvp/</link><pubDate>Sat, 10 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-pattern-model-view-presenter-mvp/</guid><description>前述 關注點分離（Separation of Concerns，SoC）: 在軟體開發中，一個模組或組件應該專注於解決特定的問題，而不是同時處理多個功能。每個組件都有自己的職責範圍，並且與其他組件盡可能解耦合。
而 MVC / MVP / MVVM 是關注點分離於前端的經典應用，網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對此感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列的發展。
界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 【Unity】MV(R)Pパターンのすすめ Unravelling MVC, MVP and MVVM 以下則對筆者實作中比較常用的 MVP 多做一些討論
關注點(責任) 在 MVP 的構成下分成三個部分
Model: 應用程式的核心邏輯。 View: 應用程式的使用者介面，負責呈現數據和接收使用者的輸入。 Presenter: View 和 Model 之間的中介。 Passive View 這是 MVP 的一種實作風格，也是筆者主要使用的風格。
Presenter 對 View 有完全控制權 View 提供方法與事件給 Presenter 使用 View 對 Presenter 一無所知 以猜拳遊戲的 View 為例</description></item><item><title>Assets - Note</title><link>https://HoshikawaRyuukou.github.io/posts/assets-note/</link><pubDate>Tue, 22 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/assets-note/</guid><description>Audio 魔王魂 効果音ラボ フリーBGM（音楽素材）無料ダウンロード｜DOVA-SYNDROME フリー効果音素材・無料効果音 Color Coolors Palettable Feature Graphics Google Play Feature Graphics Font 中文免費字體 Google Fonts 2022/0113更新# 36個合法免費高品質字體 fontget Icon ICOOON MONO iconmonstr Flaticon IconKitchen Game-icons.net Image Unsplash Image API | Free HD Photo API Lorem Picsum Photosku 2023 熱門 47 個可商用無版權免費圖庫懶人包（圖片、圖示、圖標、素材、背景） OKUMONO Misc Opengameart Kenney かわいいフリー素材集 いらすとや Textures Poly Haven Tools 網路資源列表| DeTools Repo itch.io</description></item><item><title>Software Design - Navigation</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-navigation/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-navigation/</guid><description>以下 Feature 指的是一個功能獨立的模組，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任?
以下先討論 2 種狀況。
A 直接依賴 B 簡單粗暴的強耦合破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; Feature B A 引入導航器間接依賴 B 這作法將導航操作收斂到某個類中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 重新思考導航這件事
Feature 應該知道自己是能夠 被導航 或是 能導航到哪 嗎? 到底 A 能導航到 B 這件事是誰決定的? 應該隱約地感覺到了吧，導航並不屬於 A 也不屬於 B，導航是一個獨立操作，需要一個額外的單位來負責。此外這個單位多是屬於 App 級別的(因為該層級有對其他模組的正當訪問性，畢竟是負責做統合的)。</description></item><item><title>Software Design - Principle - Dependency Inversion Principle (DIP)</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-principle-dependency-inversion-principle-dip/</link><pubDate>Tue, 15 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-principle-dependency-inversion-principle-dip/</guid><description>依賴倒置原則 Dependency Inversion Principle，以下皆簡稱 DIP。
為什麼需要 先來看定義
高層次的模塊不應該依賴於低層次的模塊，兩者都應該依賴於抽象接口 抽象接口不應該依賴於具體實現。而具體實現則應該依賴於抽象接口 文謅謅的，但重點似乎是抽象。不如直接看個狀況劇:
有一個 Project A 需要使用播廣告的功能。分別採 2 個做法
直接依賴 直覺的做法。Project A 直接依賴於廣告模組(UnityAds)，這裡模組 Project A 被迫去了解 UnityAds 的實作細節(怎麼初始化/下載廣告/播廣告)。
目前沒甚麼問題，運作得很好&amp;hellip; 但很快問題就來了。UnityAds 因為某些原因不能用了! (假設後臺被打了什麼的)。於是找了另一個廣告模組(AdMob)，想要如法炮製，但有幾點可能會不好受。
要改的地方很分散 (廣告被 Project A 多處使用) Project A 需要處理不同的 API格式 (了解細節，單例、Callback、事件&amp;hellip;) 導致原先依賴 UnityAds 的模組需要重新編譯 (造成浪費時間) 原因是直接依賴外部模組導致的，相對於你的系統 UnityAds 是個外人，是不穩定的，去依賴一個不穩定的東西，也會導致自己變得不穩定。
依賴倒置 仔細想一下，Project A 直接依賴 UnityAds 是必要的嗎? 需求是播 UnityAds 的廣告? 還是播廣告? 為了實現穩定廣告服務的依賴源，我們將其抽象化
public interface IAdService { void Initialize(); void Load(); void Show(); } 但 UnityAds 與 AdMob 又不能直接實作這個介面怎麼辦，可以用配接器模式(Adapter Pattern)寫個轉接頭，想辦法讓外部細節符合 IAdService 的需求。現在需要廣告服務的部分均透過 IAdService來操作，不需再知道外部廣告模組的細節。</description></item><item><title>Network - RPC</title><link>https://HoshikawaRyuukou.github.io/posts/network-rpc/</link><pubDate>Mon, 07 Nov 2022 21:06:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/network-rpc/</guid><description>RPC (Remote Procedure Call，遠端程序呼叫) 是一種通信協定，多用於分佈式系統的通信。
目的 讓客戶端呼叫遠程函式就像呼叫本地函式一樣。將網路通信封裝成函式來使用，那麼客戶端將不需要關心網路協定/模型。
流程 client 客戶端通過本地呼叫的方式呼叫服務 client stub 接收到請求後將參數序列化成能夠進行網路傳輸的訊息體 client stub 找到服務地址，並將訊息發送給服務端 server stub 收到訊息後進行反序列化 server stub 根據反序列化結果呼叫本地服務 本地服務執行並將處理結果返回給 server stub server stub 將結果序列化並發送至 client stub client stub 接收到訊息，並進行反序列化 client 得到最終結果 Ref 怎么理解rpc，既然有http请求了为啥还要用rpc？ 谁能用通俗的语言解释一下什么是 RPC 框架？</description></item><item><title>Philosophy - Ship of Theseus</title><link>https://HoshikawaRyuukou.github.io/posts/philosophy-ship-of-theseus/</link><pubDate>Sun, 06 Nov 2022 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/philosophy-ship-of-theseus/</guid><description>問題 - 忒修斯之船 1世紀時的希臘作家普魯塔克問到
如果忒修斯的船上的木頭逐漸被替換，直到所有的木頭都不是原來的木頭，那這艘船還是原來的那艘船嗎？
思考 這艘船在被賦予存在意義之前，就不過是一堆木頭與金屬，如果沒有使用他的人，那麼船將沒有他的意義。因此只要賦予它存在意義的人還在，或者說這份存在意義能夠被繼承下去，無論它變成什麼樣子，它還是那艘船。</description></item><item><title>Hugo - Hello Blog</title><link>https://HoshikawaRyuukou.github.io/posts/hugo-hello-blog/</link><pubDate>Sat, 05 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/hugo-hello-blog/</guid><description>Blog 起初筆者覺得使用 Github Repository + Markdown 當作筆記就足矣。但隨著筆記越多越雜，只使用文件夾結構 + 目錄超連結，在查找上越覺得不便，還是需要有一套系統來代勞。Blog/筆記 平台玲瑯滿目，但寄身於平台的風險難以忽視(倒站/政策改變)，網站搬家也讓人很頭疼。之前就知道靜態網站能架在 Github 上，只是一直沒研究，剛好趁這個機會練習一下 Web 前端的技能。最後的方案是 Github Pages + Hugo。
Hugo 網上的教學也很多，筆者先是快速瀏覽一下幾篇文章再動工，這裡就不手把手介紹，這主要記錄一些筆者遇到的坑。
Hugo 貼身打造個人部落格系列 網站開張！在 GitHub Pages 架設 Hugo 靜態網站 開始 官方的文件 Official Doc 已經足夠清楚了，照著 Quick Start 跑完就有一個完整的畫面(以靜態網站來說)，但這裡有幾個注意的點。
使用 Binary (Cross-platform) 配置 Hugo 時，有 hugo / hugo_extended 版本，且要手動配置環境變數。extended 支援 Sass/SCSS，這裡沒注意到花了不少時間，想說改個主題佈局怎麼編譯不過，Hugo Discourse Support。 設置 .gitignore 主題 主題有很多選擇 Official Link / Github Tag - hugo-theme，有的已經打磨得很完善。筆者對這個 Blog 希望以簡潔明快為主，紀錄是第一要務。最終採用這個 Theme - Cactus (變心可換問題不大)，之後肯定會進行一些魔改的，不然自架的意義就小很多了。
選擇上幾點注意
避開一些太舊的主題 (跟 Hugo 衝突 / js腳本過舊&amp;hellip;) 第三方 API 遇到大改動時要排除一下才能建置 ( FB / IG 讓好多主題要改&amp;hellip;) 修改上幾點注意</description></item></channel></rss>