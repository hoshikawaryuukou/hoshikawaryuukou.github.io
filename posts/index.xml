<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 識之箱庭</title><link>https://HoshikawaRyuukou.github.io/posts/</link><description>Recent content in Posts on 識之箱庭</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>HoshikawaRyuukou</copyright><lastBuildDate>Tue, 02 Jul 2024 08:11:00 +0000</lastBuildDate><atom:link href="https://HoshikawaRyuukou.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Node.js - Package - Prettier</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-package-prettier/</link><pubDate>Tue, 02 Jul 2024 08:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-package-prettier/</guid><description>Quick Chat Prettier 是一個代碼格式化工具，用於保持代碼風格一致。
Guide Prettier · Opinionated Code Formatter Install npm install -D prettier eslint-plugin-prettier eslint-config-prettier eslint-plugin-prettier : ESLint 插件，用於將 Prettier 內嵌到 ESLint 中，使 ESLint 可以報告 Prettier 的格式錯誤。 eslint-config-prettier : ESLint 配置，用於關閉所有 ESLint 中的格式相關規則，以避免與 Prettier 產生衝突。 Configure .prettierrc Configuration File · Prettier Configure .prettierignore Ignoring Code · Prettier Configure eslint.config.js eslint-plugin-prettier - Configuration (new: eslint.config.js) eslint-config-prettier - eslint.config.js (flat config) import eslintConfigPrettier from &amp;#39;eslint-config-prettier&amp;#39;; import eslintPluginPrettierRecommended from &amp;#39;eslint-plugin-prettier/recommended&amp;#39;; module.exports = [ // Any other config imports go at the top eslintConfigPrettier, eslintPluginPrettierRecommended, ]; Issue 當跨平台協同的時候會有結尾符的問題</description></item><item><title>Node.js - Package - ESLint</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-package-eslint/</link><pubDate>Mon, 01 Jul 2024 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-package-eslint/</guid><description>Quick Chat ESLint v9 已經推出一段時間了，這次更新帶來了破壞性的變化，特別是在 ESLint 配置方面。由於之前插件的支援尚未到位，所以我暫時觀望。但隨著主流前端框架的跟進使用，現在是時候進行嘗試了。
另外，從 ESLint v8.53.0 開始，官方將逐步廢除格式化規則，並預計在 v10 完全廢除。官方在這篇文章中解釋了放棄格式化規則的原因：
Deprecation of formatting rules
最後，建議使用 Prettier 作為格式化需求的替代方案。
Guide ESLint - Pluggable JavaScript Linter Introducing the ESLint Configuration Migrator 前端工程化工具系列（一）—— ESLint(v9.4.0)：代码质量守护者 基础篇 前端工程化工具系列（二）—— ESLint(v9.4.0)：代码质量守护者 进阶篇 Install npx eslint --init // 執行完後會警告提示，因為 typescript-eslint 尚未正式支援 eslint v9 // 要安裝支援 eslint v9 的 typescript-eslint npm install typescript-eslint@8.0.0-alpha.39 npm outdated // 檢查是否有更新的 alpha Configuration 當前筆者使用的是標準規則，有實際需求時再回來記錄。</description></item><item><title>Mathematics - Note</title><link>https://HoshikawaRyuukou.github.io/posts/mathematics-note/</link><pubDate>Sun, 30 Jun 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/mathematics-note/</guid><description>Channel FunInCode Case 【数之道 18】&amp;ldquo;马尔可夫链&amp;quot;是什么？ 三門問題 三個囚犯問題 Algorithm Alias Method: 非均匀随机抽样算法 mackysoft/Choice Darts, Dice, and Coins: Sampling from a Discrete Distribution</description></item><item><title>Node.js - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-packages/</link><pubDate>Sat, 22 Jun 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-packages/</guid><description>Package npm trends 為什麼 pnpm 比 npm 更快且更省空間？ CLI chalk cli-table3 IO rimraf Rimraf详细介绍 IoC InversifyJS Multitasking workerpool</description></item><item><title>Telegarm - Note</title><link>https://HoshikawaRyuukou.github.io/posts/telegarm-note/</link><pubDate>Sat, 22 Jun 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/telegarm-note/</guid><description>Bot - API Token 搜索 BotFather 並開始對話。 使用 /newbot 命令創建一個新的機器人，按提示操作。 創建完成後，你會獲得一個 API Token，將其保存下來。 Bot - Chat ID 將你創建的機器人添加到你想發訊息的群組中。 發送一條消息到該群組。 使用以下 URL 來獲取群組的更新: https://api.telegram.org/bot&amp;lt;YourBotToken&amp;gt;/getUpdates 查看返回的 JSON 數據，找到 chat 字段中的 id，這就是群組的 Chat ID。 { &amp;#34;ok&amp;#34;: true, &amp;#34;result&amp;#34;: [ { &amp;#34;update_id&amp;#34;: 123456789, &amp;#34;message&amp;#34;: { &amp;#34;message_id&amp;#34;: 1, &amp;#34;from&amp;#34;: {}, &amp;#34;chat&amp;#34;: { &amp;#34;id&amp;#34;: -1001234567890, &amp;#34;title&amp;#34;: &amp;#34;Your Group Title&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;supergroup&amp;#34; }, &amp;#34;date&amp;#34;: 1617821123, &amp;#34;text&amp;#34;: &amp;#34;Your Message&amp;#34; } } ] } Sticker Telegram 貼圖 DIY教學</description></item><item><title>Documentation - README</title><link>https://HoshikawaRyuukou.github.io/posts/documentation-readme/</link><pubDate>Tue, 18 Jun 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/documentation-readme/</guid><description>Quick Chat 最近筆者從 Unity 轉向了 Node.js，因此花了大量時間在 npm 上尋找合適的套件。大部分的 README 都寫得很清晰，但也有少數寫得難以理解。
README 是 Repository 的門面，這是毋庸置疑的。創建一個好的自述文件，可以向用戶（包括使用者和開發者）顯示基本信息，但不應該用他們可能不需要的內容來淹沒他們。
筆者認為應該從一開始就認真對待 README，而不是在最後(專案收尾之際)才一股腦地將資訊灌入，這樣會降低其品質。
Guide 你知道對專案來說，README.md 有多麼重要嗎？ ── 工程師血淚史 README 的藝術 Markdown + Vscode Markdown All in One Markdown Preview Github Styling Template README-Template.md GitHub README Templates Strategy 為誰而寫 必須意識讀文件的人分成使用者和開發者，README 在佈局上要有明確的邊界。
以使用者角度 Tutorial Reference 以開發者角度 環境設定/測試/部署/發布方法 開發流程/編碼規範等 避免 README 過長 這個視專案而定，當 README 內容越來越多時可以考慮將其拆分至其他文檔，而 README.md 則改做為文檔的索引頁。
README.md RELEASELOG.md CHANGELOG.md CONTRIBUTING.md ./docs/Tutorials/xx.md ./docs/Examples/xx.md 避免 Header 過度使用 原本寫作時會下意識的使用不少的三級標題 ### Header
## Header2 ### Header3 分段.</description></item><item><title>Algorithm - Note</title><link>https://HoshikawaRyuukou.github.io/posts/algorithm-note/</link><pubDate>Thu, 30 May 2024 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/algorithm-note/</guid><description>Books fucking-algorithm hello-algo</description></item><item><title>Regex - Note</title><link>https://HoshikawaRyuukou.github.io/posts/regex-note/</link><pubDate>Wed, 29 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/regex-note/</guid><description>Guide 三十分钟正则表达式教程 Tools RegExr: Learn, Build, &amp;amp; Test RegEx</description></item><item><title>Node.js - Commands</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-commands/</link><pubDate>Sun, 26 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-commands/</guid><description>Install 特性/用途 npm install npm ci (npm clean-install) 安裝依據 根據 package.json 和 package-lock.json 只根據 package-lock.json 安裝來源 使用本地緩存來加快安裝速度 直接從註冊表下載軟體包 是否需要 package-lock.json 否 是 是否更新 package-lock.json 是，可能會更新 否，不會更新 是否清理 node_modules 否 是 速度 較慢 (需要解析和更新 package-lock.json) 較快 一致性 可能不同次安裝結果不同 保證一致，每次安裝結果相同 使用場景 開發環境 CI/CD 環境 npm install args args 作用 -g, &amp;ndash;global 全局安裝 -D, &amp;ndash;save-dev 套件將添加到 devDependencies -E, &amp;ndash;save-exact 保存的依賴項版本號是確切的版本號 Package npm pack : 以 .tgz 導出 package npm outdated : 檢查目前專案中安裝的 npm 套件是否有可用的更新版本</description></item><item><title>Node.js - Note</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-note/</link><pubDate>Sun, 26 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-note/</guid><description> Module 什麼是前端模組化？ Multitasking Worker Threads in Node.JS Worker Threads : Multitasking in NodeJS Node.js Worker Threads Vs. Child Processes: Which one should you use? Vite Vite 是什麼? 為什麼要用 Vite? 它解決了哪些問題? 又是如何解決?</description></item><item><title>Vue - Note</title><link>https://HoshikawaRyuukou.github.io/posts/vue-note/</link><pubDate>Thu, 23 May 2024 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/vue-note/</guid><description>Books 从零开始学习Vue3核心技术知识 Vue3 入门指南与实战案例 Guide Vue.js 手牽手，一起嗑光全家桶</description></item><item><title>Slot Design - Note</title><link>https://HoshikawaRyuukou.github.io/posts/slot-design-note/</link><pubDate>Wed, 22 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/slot-design-note/</guid><description>Guide SLOT設計王文章導讀 - SLOT設計王 Slots设计攻略导读 Know Your Slots 游戏中的伪随机 随机游走的赌徒是如何赔光的 How Slot Machines Work: Virtual Reel Mapping 抽卡体验设计：关于盲盒、抽卡、开箱的一切 Framework slotdesigner sta-ger/pokie</description></item><item><title>Game Design - Note</title><link>https://HoshikawaRyuukou.github.io/posts/game-design-note/</link><pubDate>Fri, 03 May 2024 21:06:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/game-design-note/</guid><description>Community IGDSHARE | 獨立遊戲開發者分享會 Blog 飛鳥涼不涼的遊戲營運觀察小站 Dev Blog QualiArtsエンジニアブログ Happy Elements株式会社 カカリアスタジオ Rank APPLION Readings 岩田聰如是說：從天才程式設計師到遊戲公司社長，任天堂中興之主傳奇的一生。 Interview Nexon 《蔚藍檔案》的作曲家們 - #1 Nexon 《蔚藍檔案》的作曲家們 - #2 Nexon 《蔚藍檔案》的作曲家們 - #3 [訪談] 蔚藍檔案的過去、現在和未來（上） [訪談] 蔚藍檔案的過去、現在和未來（下） 淺談《Celeste》的教學引導設計與機制設計 《Celeste》如何打造Madeline的優異動態感？ Inspiration 目指せ1億！覆面パズル団</description></item><item><title>Tools</title><link>https://HoshikawaRyuukou.github.io/posts/tools/</link><pubDate>Thu, 02 May 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/tools/</guid><description>Antivirus DefenderUI File-Sharing HFS: HTTP File Server (version 3) Media VLC media player 如何安裝FFmpeg ScreenToGif YoutubeDownloader Twitter 影片下載器 Translation Saladict 沙拉查词 BallonsTranslator Simulation KeymouseGo Others Emojipedia 史上最簡單「一頁式網站」建置工具！ | Google Sites 協作平台快速上手 只會用 Office 畫流程圖？許多人試用過這個後直呼回不去了 👍 | Draw.io 教學 Code Image Spritesheet Cutter</description></item><item><title>Phenomena - Note</title><link>https://HoshikawaRyuukou.github.io/posts/phenomena-note/</link><pubDate>Tue, 30 Apr 2024 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/phenomena-note/</guid><description> 達克效應（DK Effect）的美麗錯誤 — — 對無知的無法認知：愚昧之巔、絕望之谷 一山還有一山高：談眼鏡蛇效應（Cobra Effect）</description></item><item><title>JavaScript - Note</title><link>https://HoshikawaRyuukou.github.io/posts/javascript-note/</link><pubDate>Mon, 29 Apr 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/javascript-note/</guid><description>async/await JavaScript 中的 async/await 是什麼？和 promise 有什麼差別？ Event Loop JavaScript Event Loop解說：單執行緒還能異步運算？ 請說明瀏覽器中的事件循環 (Event Loop) Scope 作用域(scope)解說：let, const, var有什麼差？【JavaScript基礎】 Style Google JavaScript Style Guide Object 為什麼推薦用 structureClone 在 JavaScript 做深拷貝? Promise Promise 是什麼？有什麼用途？</description></item><item><title>TypeScript - Note</title><link>https://HoshikawaRyuukou.github.io/posts/typescript-note/</link><pubDate>Mon, 29 Apr 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/typescript-note/</guid><description>Style Google TypeScript Style Guide Tool JSON to TypeScript</description></item><item><title>Unity - Packages</title><link>https://HoshikawaRyuukou.github.io/posts/unity-packages/</link><pubDate>Sat, 13 Apr 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-packages/</guid><description>Package Manager Installing Packages using UPM Package manager -&amp;gt; Advanced project settings Add Scoped Registries Name: package.openupm.com URL: https://package.openupm.com Scope(s): com.cysharp.unitask Package manager -&amp;gt; Packages: My Registries -&amp;gt; Install Guide Unity中 .asmdef文件的作用 使用OpenUPM发布自己的Unity项目 开发Unity PackageManager 插件包 Creating Custom Packages for Unity 2018.3 How to remodel your project for asmdef and UPM 【Unity】Package Manager活用術 Package Collection killop/anything_about_game baba-s/awesome-unity-open-source-on-github Animation PrimeTween Async UniTask Debug UnityIngameDebugConsole Dependency Injection VContainer Dialogue YarnSpinner-Unity Editor NaughtyAttributes Alchemy HotFix HybridCLR Localization Lean Localization Media UnityNativeCamera Messaging MessagePipe Particle Effect ParticleEffectForUGUI Persistence PlayerPrefs Editor &amp;amp; Utilities Resource Management YooAsset Rx (Reactive Extensions) UniRx Serialization Newtonsoft.</description></item><item><title>Node.js - Unit Test ( TypeScript + Mocha + Chai )</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-unit-test-typescript-+-mocha-+-chai/</link><pubDate>Wed, 03 Apr 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-unit-test-typescript-+-mocha-+-chai/</guid><description>Guide Setup a new TypeScript project with Mocha support 如何在 TypeScript + ESM + Mocha + tsconfig-paths 下运行 Mocha 测试用例 Chai Configure npm install -D typescript mocha ts-mocha chai npm install -D @types/node npm install -D @types/mocha npm install -D @types/chai test 文件至於 根附錄 test/ 之下，使用 *.spec.ts 格式命名
.mocharc.json
{ &amp;#34;extension&amp;#34;: [ &amp;#34;ts&amp;#34; ], &amp;#34;spec&amp;#34;: &amp;#34;test/**/*.spec.ts&amp;#34;, &amp;#34;import&amp;#34;: &amp;#34;tsx&amp;#34; } package.json
{ &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;ts-mocha&amp;#34; } } simpleTest.spec.ts
describe(&amp;#39;Simple Test&amp;#39;, () =&amp;gt; { it(&amp;#39;should pass this simple test&amp;#39;, () =&amp;gt; { const x = 2; const y = 2; const sum = x + y; expect(sum).</description></item><item><title>VScode - Note</title><link>https://HoshikawaRyuukou.github.io/posts/vscode-note/</link><pubDate>Sat, 30 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/vscode-note/</guid><description>Diagrams Draw.io Integration Software Diagrams - Plant UML vs Mermaid Mermaid Doc Encoding VS Code採用Code Runner遇到的 Output中文亂碼問題 (Python) Display Visual Studio Code ( VS Code) 切換成中文版 Extensions Code Runner</description></item><item><title>Windows - Note</title><link>https://HoshikawaRyuukou.github.io/posts/windows-note/</link><pubDate>Fri, 29 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/windows-note/</guid><description>Disk 如何在Windows 10中刪除Hiberfil.sys（休眠）檔案 Shortcut Windows 11 顯示與清除歷史記錄</description></item><item><title>Programming - Basic</title><link>https://HoshikawaRyuukou.github.io/posts/programming-basic/</link><pubDate>Sat, 16 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/programming-basic/</guid><description>演算法 Hello 算法</description></item><item><title>Node.js - Configure</title><link>https://HoshikawaRyuukou.github.io/posts/node.js-configure/</link><pubDate>Wed, 13 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/node.js-configure/</guid><description>Guide Node.js究竟是什么？初学者指南 Setup Node.js Projects with TypeScript, ESLint and Prettier [指令] npm cli &amp;amp; package.json Multiple exports with types in a Typescript Package Environment coreybutler/nvm-windows nvm-windows 管理 Windows Node.js 版本 解决Node.js的命令行输出中文乱码问题（也适用于Electron） tsx: 替代 node 指令、支持运行 TypeScript &amp;amp; ESM 的 CLI 程序 Config @tsconfig/node20 : Node 20 推薦 tsconfig.json Project Configure npm install -g typescript npm install -g tsx npm init -y npm install -D typescript npm install -D tsx npm install -D @types/node npm install -D @tsconfig/node20 tsc --init ESLint Understanding ESLint Configuration: .</description></item><item><title>Unity - Basic - WebGL</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-webgl/</link><pubDate>Sat, 09 Mar 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-webgl/</guid><description>前述 使用 Unity 2022.3 開發，Unity 2022.1 在 iPhone/Android 上運行時不再顯示警告。似乎可以逐漸用於智慧手機專案。 Context 是 2D 小遊戲，以 webgl 1 輸出，暫時不需要 webgl 2 畫面效果。 Guide Unity User Manual 2022.3 (LTS)Platform developmentWebGL Unity WebGLビルドメモ - フレームシンセシス Unity 製 WebGL ゲームを AWS でお手軽公開 Unity WebGL 微信小游戏适配方案(公测) Template (Unity) Better Minimal WebGL Template Tests Unity WebGL Loading Test Instant Game Meta Instant Games Unity Instant Game Recommended Basic Todo 資源使用 Assetbundle 分包 資源限制下載數 ( 10個以內 ) 資源緩存 啟動封面範本修改 閒置時段下載資源 wasm 分包 (方案尋找中) Others 【Unity】WebGL開発時の注意事項 #Unity 游戏一键打包 #Facebook小游戏 解决方案 My WebGL assets Unity Webgl 问题总结 UnityWebGL移动端兼容性说明 Unity发布webgl获取浏览器的URL Unity WebGL で WebSocket を使う</description></item><item><title>Unity - Package - UniTask</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-unitask/</link><pubDate>Sat, 10 Feb 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-unitask/</guid><description>前述 UniTask - Unity 中實現效能最好的 async/await 的函式庫
Cysharp/UniTask Unity 中預設的非同步實現是 - Coroutine 協程，但協程有以下缺點
無法使用回傳值，需使用 callback 來解決。 異常處理很困難，因為不能在 try-catch 區塊內使用 yield。 需透過 MonoBehaviour.StartCoroutine 才能啟動。 UniTask 相較於 C# 原生的 Task 做了以下改進
刪除了 Task 在 Unity 不需要的功能。 非 MonoBehaviour 裡也能實現非同步。 記憶體/ GC / Unity PlayerLoop 等方面做最佳化。 UniTaskTracker 提供編輯器上可視化追蹤 await 狀態，這對於檢查是否有洩漏很有用。 UniTask 官方文件的基本功能寫得相當清楚，並附上一些入門介紹
UniTaskを使おう！ UniTask機能紹介 以下紀錄幾個重點主題
Awaiter UniTask 已經實作了相當豐富的 Awaiter 擴充，有需要自訂的可以參考以下規範
.NET 中什么样的类是可使用 await 异步等待的？ Thread UniTask.SwitchToThreadPool 允許後續處理在執行緒池中進行。 UniTask.SwitchToMainThread 切換到主執行緒，不會等待下一幀。 也可以使用 UniTask.Yield 切換到主執行緒，但它總是等待一幀。 但目前尚未有使用到的情境，之後有遇到再嘗試。</description></item><item><title>Unity - Basic - Android Build</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-android-build/</link><pubDate>Sat, 03 Feb 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-android-build/</guid><description>Settings gradleTemplate.properties : 專案的全域 Gradle 配置。 AndroidManifest.xml ：用於向 Android 構建工具、Android 作業系統和 Google Play 描述應用的基本資訊。 launcherManifest.xml 定義應用的啟動配置資訊 mainTemplate.gradle：自定義 Android 專案的 Gradle 構建過程，包括添加依賴項、修改編譯設定、配置簽名資訊等。 launcherTemolate.gradle ：包含有關如何構建 Android 應用程式的指令 baseProjectTemplate.gradle：所含的配置會在其他所有範本/Gradle 專案之間共用 Ref Unity 不通過Android studio 打包接SDK</description></item><item><title>Unity - Basic - AndroidJNIModule</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-androidjava/</link><pubDate>Sun, 28 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-androidjava/</guid><description>前述 這次的業務需求是
將 Google Play Install Referrer 接入 Unity
目前有使用到 AndroidJNIModule 中的
AndroidJavaClass AndroidJavaObject AndroidJavaProxy 但中途採了不少坑，特此紀錄一下。
基本知識 UnityEngine.AndroidJNIModule How to Create Android Java Callbacks to C# in Unity UnityからAndroidのクラスや関数を呼び出す AndroidJavaClass 可以實例化 Java 類、調用 Java 類的靜態方法，以及訪問 Java 類的靜態屬性。 AndroidJavaObject 創建 Java 對象的實例。 AndroidJavaProxy 允許在 Unity C# 腳本中實現 Java 接口。 允許我們在 Java 中調用方法，這些方法將調用 C# 類上的 匹配 方法。 注意 函數名匹配 (建議直接看 source code 裡面的值，本此次就遇到 官方文件與 jar 為匹配) android.os.Build.VERSION 將意味著要到一個公開類 android.os.Build$VERSION 將意味著進入一個內部類</description></item><item><title>Unity - Service - Google Play Install Referrer</title><link>https://HoshikawaRyuukou.github.io/posts/unity-service-google-play-install-referrer/</link><pubDate>Thu, 25 Jan 2024 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-service-google-play-install-referrer/</guid><description>簡述 Play Install Referrer
Play Install Referrer API : 非 Kotlin / Java 用戶使用 Play Install Referrer Library : 將上者封裝更方便 Kotlin / Java 使用 透過該服務能對 App 的下載與使用者進行歸因分析，用於評估推廣服務得成效，進而提升推廣效果與報酬率。
舊版 Play Install Referrer 在使用者下載應用程式後透過廣播傳送包含歸因參數的訊息。然而廣播的不可靠性和安全性問題，目前不再建議使用這個版本。 新版 Play Install Referrer 直接訪問本機 Google Play 應用程式商店中的記錄，索取 referrer 值，因此更加可靠。 快速上手 Unity 專案: 將依賴加在 maintemplate.gradle
dependencies { implementation(&amp;#34;com.android.installreferrer:installreferrer:2.2&amp;#34;) } 因為官方 API 文件寫的不全，建議到以下網站直接下載 aar 查看 jar 來對接 API
Google&amp;rsquo;s Maven Repository Maven Repository 使用服務的工作流為如下
建立連線 等待 callback 連線成功 索取 referrer 關閉連線 Referrer 格式 https://play.</description></item><item><title>Architecture - VIPER</title><link>https://HoshikawaRyuukou.github.io/posts/architecture-viper/</link><pubDate>Fri, 19 Jan 2024 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/architecture-viper/</guid><description>簡述 VIPER (View-Interactor-Presenter-Entity-Router)
iOS VIPER架構實踐(一)：從MVC到MVVM到VIPER VIPER，更清晰的架构，解决复用和测试问题的利器系列1：VIPER架构演进史 有很多種實作流派，下圖是我比較偏好的模式呈現
VIPER 借鏡了 CA (Clean Architecture) 的思想為 MVC 提供一個新的設計方案
Entity 對應原本的 Model Controller 責任過重 -&amp;gt; 將業務邏輯移至 Interactor 並提高重用性 Controllers 之間耦合 -&amp;gt; 將導航邏輯移至 Router Presenter 作為 Binder 將 View / Interactor / Router 整合 啟發 VIPER 是筆者學習架構路上很重要的一個過渡，有以下兩點的思想轉變
顆粒度更細的單一職責 Interactor 封裝業務的概念在純 MVX 中是無法直接體會到，因此對之後學習 CA 時起了很大的緩衝，不然對於 Usecase 的設計應該會很不適應。
重視 Navigation 在學習 CA 中始終沒題到 feature/componet module 之間是如何互動的，也是在回頭複習 VIPER 時才重新意識到 Router 的重要性。當沒有特別規劃 Navigation 時很容易會造成 module 之間的耦合。</description></item><item><title>Unity - Service - Cloud Diagnostics</title><link>https://HoshikawaRyuukou.github.io/posts/unity-service-cloud-diagnostics/</link><pubDate>Tue, 16 Jan 2024 22:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-service-cloud-diagnostics/</guid><description>簡述 Official Home Page Official Doc 監控崩潰和異常報告 測試人員和應用使用者能直接提供用戶報告 啟用成本極低且非侵入式 有免費套餐，Personal 常規操作應該是沒問題，一旦超出了免費額度，系統將要求添加付款方式以繼續使用服務 快速上手 Cloud Diagnostics エラーやクラッシュを記録し、バグ特定の手助けになるUnity公式の無料サービス Unity Cloud Diagnostics UnityエディタやUnityで作ったゲームを強制的にクラッシュさせる方法 注意 Apple&amp;rsquo;s privacy survey Google Play data safety disclosures for Cloud Diagnostics</description></item><item><title>Unity - Environment</title><link>https://HoshikawaRyuukou.github.io/posts/unity-environment/</link><pubDate>Tue, 16 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-environment/</guid><description>⚠️ 指令操作會有過時/版本問題不在以下例出
VSCode 移除 Visual Studio Code Editor 已經停止維護 安裝 Visual Studio Editor 升級至 2.0.20 以上 Mac (M2) 安裝 dotnet sdk，須注意是否適用 ARM | ref 安裝 Mono | ref 安装 xcode 更新 Homebrew 更新 Ruby 至 3.x 並配置環境變數 (系統預設是 2.x) | ref 僅參考 ruby 更新部分 更新 gem 移除 CocoaPods | ref 安裝 CocoaPods ⚠️ 目前會有 VSCode 未完全關閉又重啟而導致 dotnet sdk 配置失效的狀況</description></item><item><title>Unity - Package Manager - Modify A Package</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-modify-a-package/</link><pubDate>Fri, 12 Jan 2024 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-modify-a-package/</guid><description>情境 有需要客製化 Unity 官方 / git 直接導入 的 Package 時
操作 至 ProjrctRoot\Library\PackageCache 找到目標的 Package 剪下貼上至 ProjrctRoot\Packages 即可 Ref How can I modify built-in packages? Unity - 如何修改一个 Package 或是如何将 Package Local化</description></item><item><title>Unity - Package Manager - Private GitHub Repository</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-private-github-repository/</link><pubDate>Sun, 24 Dec 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-private-github-repository/</guid><description>情境 想分享私有庫但又不想去更改團隊或人員權限，Github 提供 Fine-Grained Token 能做到客製化的權限控制
操作 至 GitHub &amp;laquo;帳戶設定&amp;raquo;（非儲存庫設定） Developer Settings -&amp;gt; Personal Access Tokens -&amp;gt; Fine-Grained Tokens 生成 Token (Read-Only Permission for the repo Content). &amp;#34;com.yourusername.yourpackage&amp;#34;: &amp;#34;git+https://x-oauth-basic:&amp;lt;token&amp;gt;@&amp;lt;repo&amp;gt;?path=&amp;lt;folder&amp;gt;&amp;#34; Ref Install Unity Package from a private GitHub repository</description></item><item><title>Unity - Package - External Dependency Manager for Unity (EDM4U)</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-external-dependency-manager-for-unity-edm4u/</link><pubDate>Wed, 08 Nov 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-external-dependency-manager-for-unity-edm4u/</guid><description>前言 Google 停止維護 Game Package Registry (GPR) 導致不能直接使用 Package Manager 導入包。必須到封存檔網站下載「.tgz」手動導入。
Google Unity 套件 Install a package from a local tarball file 其他的相關的 Google Service 依賴(AR/Firebase/Google Play等)也可以用此方法導入。
設定 Assets &amp;gt; External Dependency Manager &amp;gt; Android Resolver &amp;gt; Settings 啟用這三個 Patch 並至 Player Settings &amp;gt; Publishing Settings 啟用以下選項 Auto resolution Assets &amp;gt; External Dependency Manager &amp;gt; Android Resolver &amp;gt; Force Resolve 後會去收集專案所有 Editor 資料夾下的 *Dependencies.xml 加到 mainTemplate 中</description></item><item><title>Unity - Basic - Asset Management</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</link><pubDate>Sat, 09 Sep 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-asset-management/</guid><description>AssetBundle Assets, Resources and AssetBundles Case Studies of Unity AssetBundle Efficient Encryption Addressable Frameworks Addressables 是在 AssetBundle 的基礎上對操作進行更友善的封裝，AssetBundle 有很多要小心的地方
AssetBundle 卸載 Addressable System 主要改善幾點
透過 name/label，而是不與資源直接連結，減少因移動或重命名資產而出錯的機會。 本地或是異地都可以追踪。 簡化打包和依賴管理(name/label/group/catalog)。 較好的記憶體管理機制(引用計數)與性能分析系統。 不同 Framework 在常規操作上大同小異，可以從資源最多的 Addressables 做觀念入門
Unity Addressables资源管理方式用起来太爽了，资源打包、加载、热更变得如此轻松（Addressable Asset System | 简称AA） Unity - Addressables项目总结（一）：基础工作流 Unity - Addressables项目总结（二）：业务需求 静态包、动态包有什么区别？何时使用增量更新？Addressables 更新流程大梳理 Repo Addressables tuyoogame/YooAsset Extra 为什么抛弃了 Addressable</description></item><item><title>Pattern - ViewModel</title><link>https://HoshikawaRyuukou.github.io/posts/pattern-viewmodel/</link><pubDate>Sun, 27 Aug 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/pattern-viewmodel/</guid><description>前述 此篇的實作參考到以下文件 (提到不少 Presentation layer 設計原則)
Android Developers 文件/指南/UI 層
該文件的更新頻率算高且會與時俱進，筆者印象中其架構設計從 MVVM -&amp;gt; Domain/Application Driven 設計，可以看出主流架構有產生變化。之後的討論雖然使用 ViewModel 但不會詳細介紹 MVVM 的細節，如果對 MVX 系列不熟，可以先讀筆者之前的文章 &amp;laquo;通用設計 - Pattern - MVP&amp;raquo; 裡面的 References。
探索 回到正題，筆者在最近的業務上遇到
如何在 服務端未完成 的情況下，讓 Client 獲得完整的體驗流 ?
以下用交叉反問的方式來分析問題
Q: 沒有服務端那資料來源哪來 ? A: 使用假資料
Q: 當表現層依賴的是 IService Interface 使用假資料時需要實作什麼 ? A: 只需要實作一個 FakeService 來產生假資料即可
Q: 當想要將業務與表現解耦時，很常使用中介者的手法來黏合兩者，如果使用標準的 MVP 實做，Presenter 實際做了哪些事呢 ? A: 監聽 View 事件/ 與 Service 互動/ 管理畫面狀態/ 呼叫 View 刷新</description></item><item><title>Unity - Basic - Memory Profiler</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</link><pubDate>Sun, 30 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-memory-profiler/</guid><description>注意 由於Unity 無法將性能分析器本身佔用的記憶體與運行模式的記憶體完全分開。要獲得應用程序的更精確數字和記憶體使用情況，應在要運行應用程序的目標設備和操作系統上分析應用程序。 如果需要在記憶體受限的平台上運行應用程序，設備上的總駐留量對於檢查低記憶體警告和由於記憶體耗盡而強制關閉非常有用。作為一般規則，它不應超過設備上可用總物理內存的 70%。 偵測 Leaked Managed Shell 的功能在 Memory Profiler 1.1.0-pre.1 Ref Memory Profiler Memory Profiler | 1.1.0-pre.1 - Unity - Manual Unity でメモリリーク？ Memory Profiler で Leaked Managed Shell をチェックしてみよう！ Inspecting memory with the new Memory Profiler package Memory Profiler로 애플리케이션의 물리적 메모리 사용량 분석 Unity内存分析与优化实践(1.1版本前)</description></item><item><title>Git - Rebase</title><link>https://HoshikawaRyuukou.github.io/posts/git-rebase/</link><pubDate>Sun, 16 Jul 2023 20:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-rebase/</guid><description> 之前筆者一直以為 rebase 是進行類似 剪下貼上 的操作，但實際上是 複製貼上
情境 合併時不會像 merge 時會有 commit 的節點 想整理 還沒推出去 的 commit 可以使用 避免修改已經推出去的歷史 如何取消操作 使用 reflog 列印出所有「歷史紀錄」找到 rebase 的前一個 commit id，並進行 reset 即可
git reflog git reset XXXXXXX --hard 此外當進行比較危險操作時 git 會額外紀錄前一個 head 於 ORIG_HEAD，因此也可以直接執行以下，來達到同樣效果
git reset ORIG_HEAD --hard Ref 另一種合併方式（使用 rebase） git rebase 用法 git rebase -i (drop) git rebase -i (pick) git rebase -i (reword)</description></item><item><title>Git - Pull Request</title><link>https://HoshikawaRyuukou.github.io/posts/git-pull-request/</link><pubDate>Fri, 14 Jul 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-pull-request/</guid><description> 有的環境也稱 Merge Request
情境 開發產品時一般會挑選固定一個分支做為可以上線的正式版本分支(master)，需注意的是在進行多人協同開發時，讓每個人都可以 Commit 到專案正式上線的分支不是個好的做法。
可以透過 pull request 方式控管權限，由負責管理這個專案的人收到其他開發者的 pull request 並確認無誤後便可進行合併，來確保產品分支處於隨時都是可上線的狀態。
參與開源專案時，在創建 pull request 之前，建議先在本地分支上運行 git rebase 命令，確保你的更改基於最新的進度以降低審查者的理解難度。
Ref 與其它開發者的互動 - 使用 Pull Request（PR）</description></item><item><title>Unity - Basic - Preprocessor Directives</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-preprocessor-directives/</link><pubDate>Fri, 07 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-preprocessor-directives/</guid><description>前述 中文稱作 : 前置處理器指示詞
筆者最近接觸到的遺舊專案中發現裡面大量地使用 條件式編譯
#if DEBUG Console.WriteLine(&amp;#34;Debug version&amp;#34;); #endif 筆者之前有使用也基本只使用 定義區域 (排版效果)
#region MyClass definition public class MyClass { static void Main(){...} } #endregion Unity 在處理平台裝置時也蠻常會出現的
public class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(&amp;#34;Unity Editor&amp;#34;); #endif #if UNITY_IOS Debug.Log(&amp;#34;iOS&amp;#34;); #endif #if UNITY_STANDALONE_OSX Debug.Log(&amp;#34;Standalone OSX&amp;#34;); #endif #if UNITY_STANDALONE_WIN Debug.Log(&amp;#34;Standalone Windows&amp;#34;); #endif } } 問題 那前置處理器指示詞有什麼問題呢? (參考日文那個 Ref 有比較明確的 Case)
編譯版本至少會是 2^(指示詞的分類數)種，持續的調試和測試變得非常困難。 Unit Test 中難以使用。 編譯檢查不起作用。 當巢狀結構出現時可讀性將大為降低。 上述這些狀況都會導致 延後發現問題的時間 !</description></item><item><title>Unity - Basic - iOS plug-in</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</link><pubDate>Wed, 05 Jul 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-ios-plug-in/</guid><description>前述 這次的業務需求是
取得 ios 實機的 &amp;ldquo;地區&amp;rdquo;，並讓 C# 能拿到 Swift 所返回的字串
因為在 ios 的環境下 unity / C# 拿到的值並不正確。此外筆者對 Swift / Objective-C 幾乎零基礎，目前只針對一些教學文件做些修改，之後有機會更熟再回頭深究。
實作 SwiftDeviceInfoPlugin.swift 須放置於 Plugins\iOS 之下 import Foundation public class SwiftDeviceInfoPlugin { public static func getRegion() -&amp;gt; String { return Locale.current.regionCode ?? &amp;#34;Unknown&amp;#34; } } @_cdecl(&amp;#34;getRegion&amp;#34;) public func getRegion() -&amp;gt; UnsafePointer&amp;lt;CChar&amp;gt;? { let region = strdup(SwiftDeviceInfoPlugin.getRegion()) return UnsafePointer(region) } @_cdecl(&amp;ldquo;getRegion&amp;rdquo;)：這是一個 Swift 標記，表示下面的函數將使用cdecl樣式的名稱綁定。您只需知道此屬性向 C 公開了一個 Swift 函數 UnsafePointer&amp;lt;CChar&amp;gt;?，它是一個可為空的指向 C 風格字串（CChar）的指標。這使得 Swift 能夠以與 C 相容的方式提供訪問區域資訊的介面。 strdup() 用於創建預返回的字串的副本，並在堆上分配其記憶體。 public sealed class IOSDeviceInfoProvider : IDeviceInfoProvider { public string GetRegion() { return new System.</description></item><item><title>Pattern - Service Locator</title><link>https://HoshikawaRyuukou.github.io/posts/pattern-service-locator/</link><pubDate>Wed, 28 Jun 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/pattern-service-locator/</guid><description>前述 Service Locator 確實也是 IoC 的一種實作方式，不過採用的是 依賴尋找(Dependency Lookup) 的設計。 筆者之前有一陣子蠻常使用這 pattern，那時對 DI 與 IoC 的概念並不熟悉，只覺得這樣使用依賴變得很方便。
因為我可以在任何地方直接這樣取用資源
var target = ServiceLocator.Resovle&amp;lt;Target&amp;gt;(); 這樣的寫法有以下問題 :
透過 ServiceLocator 因為這個取用資源的過程是隱性的，不容易被直接發現。 想用誰就拿誰這件事也有點危險，Ex: View 可以拿到不屬於 Presentation layer 該碰的對象。 所以當 DI 與 IoC 的概念熟悉後，並且使用 DI / IoC Container 後就漸漸不使用這 pattern 了。
應用 但這次工作上反而覺得 Service Locator 可以勝任從 Singleton 過渡到 DI / IoC Container 的中繼階段。
因為這次接觸到的專案嚴重依賴 Singleton，且組員也已習慣 Singleton 的寫法了，要直切換到 DI / IoC Container 會有不小的陣痛期(當然實務上能不能切又是另一個故事了)。
於是筆者想起了 Service Locator，有以下理由
因為在使用上就很像是 Singleton 筆者希望組員能快速感受到 IoC 所帶來的紅利 集中管理依賴 實作 此模式使用稱為「服務定位器」的中央註冊表，它根據請求返回執行特定任務所需的對象。</description></item><item><title>FileFormat - WebP</title><link>https://HoshikawaRyuukou.github.io/posts/fileformat-webp/</link><pubDate>Thu, 22 Jun 2023 20:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/fileformat-webp/</guid><description>設計目標 Google 以縮減線上影像的檔案大小為目標，同時維持不輸 JPEG、PNG、GIF 格式的圖片品質。
網站的瀏覽與速度不僅影響使用者的耐心，也會影響SEO的排名與檢索，透過顯著縮減相片和圖形大小，網頁就能加快載入速度，提供更優質的使用者體驗。
並持續在優化 WebP 2: experimental successor of the WebP image format
壓縮方式 有損壓縮 無失真壓縮 Ref WebP 檔案 Now in REALITY Tech #6 画像をWebP形式に対応した話 Now in REALITY Tech #37 UnityでWebPを扱えるようにした話</description></item><item><title>Test - Note</title><link>https://HoshikawaRyuukou.github.io/posts/test-note/</link><pubDate>Sat, 03 Jun 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/test-note/</guid><description>以下觀點不一定適用於各專案，請因地制宜。
在開始寫 code 之前 測試文化: 底下的人願意寫，上面的人願意給時間。 測試的順位: 從商業價值最高的功能開始。 較低的測試價值 需求尚未明朗又必須交付成果。 取決於經營者對價值的認定，其實跟程式沒多大關係。 不是所有的程式都可以測試，有時候為了測試，程式需要先重構成可以測試的樣子。 Unit Test 手動測試 慢 不穩定 脆弱 不方便 問題出在不可控
希望是可控的 可重現一樣結果 以整體專案的角度來看單元測試 專案內分為 不可控 與 可控 兩部分
不可控: 檔案/資料庫/第三方套件 可控: 除不可控以外自己所寫的部分 可控內分為 不可測 與 可測 兩部分
不可測: 與不可控接觸的部分，因此會希望這部分越單純越好。 可測: 為專案內價值較高，須小心維護的部分。 目標: 可測範圍盡量大，不可測盡量小。
單元測試相較於手動測試的優勢 ? 可以輕鬆的跑完多個 Test Cases Static 要不要測 ? 直接使用真實行為 透過測試框架強測 重構/隔離/依賴注入 Ref 一次搞懂單元測試、整合測試、端對端測試之間的差異 一起設計出可被單元測試的程式碼吧！ [Day 2]Unit Testing 簡介 .NET Core 和 .NET Standard 的單元測試最佳做法</description></item><item><title>Unity - Package - xLua</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</link><pubDate>Sun, 28 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-xlua/</guid><description>本次操作 xLua 主要是做熱更方案的評估測試，筆者目前還是偏好使用 HybridCLR。
Official Tencent/xLua 評估 使用 lua 仍是目前主流/穩定做法 (畢竟也行之有年了)。 邏輯操作可能要移師到 lua 側。 缺少 ide 支援如果要在 lua 側 進行 unity 相關操作時，維護/除錯成本極高。 Example 在 lua 側進行 unity 相關操作
local speed = 10 local lightCpnt = nil function start() print(&amp;#34;lua start...&amp;#34;) print(&amp;#34;injected object&amp;#34;, lightObject) lightCpnt= lightObject:GetComponent(typeof(CS.UnityEngine.Light)) end function update() local r = CS.UnityEngine.Vector3.up * CS.UnityEngine.Time.deltaTime * speed self.transform:Rotate(r) lightCpnt.color = CS.UnityEngine.Color(CS.UnityEngine.Mathf.Sin(CS.UnityEngine.Time.time) / 2 + 0.5, 0, 0, 1) end function ondestroy() print(&amp;#34;lua destroy&amp;#34;) end</description></item><item><title>Unity - Editor - ScriptedImporter</title><link>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</link><pubDate>Sat, 27 May 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-editor-scriptedimporter/</guid><description>用途 使用C# 為Unity 本身不支持的文件格式編寫自定義資源導入器，從而添加支持。 注意 Scripted Importer 無法處理已由 Unity 本身處理的文件擴展名。 Example 這裡將 .lua 以 TextAsset
using UnityEngine; using System.IO; using UnityEditor.AssetImporters; [ScriptedImporter( 1, &amp;#34;lua&amp;#34; )] public class LuaImporter : ScriptedImporter { public override void OnImportAsset( AssetImportContext ctx ) { TextAsset subAsset = new TextAsset( File.ReadAllText( ctx.assetPath ) ); ctx.AddObjectToAsset( &amp;#34;text&amp;#34;, subAsset ); ctx.SetMainObject( subAsset ); } } Ref Scripted Importers [Unity] 资源工作流程 - ScriptedImporter</description></item><item><title>Principle - Inversion of Control (IoC)</title><link>https://HoshikawaRyuukou.github.io/posts/principle-inversion-of-control-ioc/</link><pubDate>Fri, 05 May 2023 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/principle-inversion-of-control-ioc/</guid><description>反轉了什麼 ? 依賴對象的獲得被反轉了
在應用程式中設計總會有多個單元需要合作的情況，這時就會有配置依賴的需求，但這個配置應該由需求方來處理嗎?
讓依賴需求方自己處理最簡單的方式就是實例化(new)，但這可能會有以下問題:
不同需求方重複 new 是否會有浪費的問題? 能被共用嗎? 方便共用嗎? 到處 new 來 new 去，依賴的管理變得很亂 那不如找一個單位負責來處理依賴配置。我不自己 new，而是別人 new 完後(注入給我/讓我查找)，這麼所帶來的好處:
資源複用更方便: 統一由容器創建或保存對象，不需要每個需求方都自己 new 一個新的。 建造/使用分離: 依賴需求方操作其依賴項來完成任務才是他主要的責任，如果還要處理依賴項的實例化，責任就模糊了，因此將依賴項的創建和配置的控制權交給 IoC Container。 為此需要有一個 IoC Container 來處理，通常容器包含以下操作：
Register：註冊類型和依賴關係 Resolve：創建並註入依賴關係 Dispose：管理生命週期 實踐方式 最常見的方式分別是 依賴注入（Dependency Injection，DI）與 依賴尋找（Dependency Lookup）。
依賴尋找 可以簡單理解為 依賴需求方 &amp;laquo; 主動 &amp;raquo; 使用容器來取得依賴。依賴需求方直接使用 Locator.Resolve 取得依賴，但這種作法有些爭議(反模式)，依賴需求方是不是有註冊的項目都能任意取得阿 ?
Service Locator 服務定位器是依賴尋找的典型實作。
依賴注入 透過注入依賴項讓 依賴需求方 &amp;laquo; 被動 &amp;raquo; 使用容器來取得依賴，常透過三種方式注入。
建構子(推薦) 屬性 方法 權限相對清晰(建構子注入)，能用依賴項的都在建構子給你了，不過你要額外new 其他東西也是沒人攔得住。
這個方式通常透過框架來處理，此外依賴需求方是不知道容器的存在(理想狀態，但有時會需要一些注入標記)。</description></item><item><title>Unity - Package Manager - Sample Workflow</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-sample-workflow/</link><pubDate>Sat, 22 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-manager-sample-workflow/</guid><description>Package Samples 對應有些模組的操作比較複雜繁瑣，有時需要有一些 Sample 做參考。官方 Package Manager 有個 &amp;ldquo;半套&amp;rdquo; Sample 工作流，讓人不是很舒服。
官方文件
Sample 資料夾後面加了波浪號 (~) 告訴 Unity 忽略 Samples~ 文件夾中的內容，此類文件夾不使用.meta文件進行跟踪。忽略 Samples~ 對 Package 使用者是好的，畢竟不是每個人都需要。
但對 Package 開發者，畢竟 Samples 也是要進版控的，而這樣改名的作法會徒增一些重命名的提交也有點煩躁(除非在修改 Sample 的過程中完全不提交)。原先想說寫個 Samples ↔ Samples~ 切換的腳本就好，會一直有 meta 檔的警告(刪掉/改名都還是在)。
官方作法 論壇中的某篇討論才記載他們的做法(倒是加到文件中阿&amp;hellip;)
在內部確實使用了名為 Samples 的文件夾 (沒有 Samples~ ) 在推送新包版本之前通過腳本對其進行重命名(透過 CI ) OpenUPM 的作者也是使用類似的工作流，總之筆者也調整為上述的方式。
透過 GitHub Actions Workflow 調整目錄名 筆者不熟 GitHub Actions/ YAML/ 文件操作，但這種初階的操作就交由 chatgpt 代勞，幫我省去不少實驗成本。這裡的操作只是堪用，應該有更好的方式。
以下是筆者要求的條件
想透過 GitHub Actions 中的 workflow 完成 如果 forPackage 分支已存在則將其刪除 從 main 建立新的 forPackage 分支 Assets/Modules 的所有子目錄(同時有 &amp;ldquo;package.</description></item><item><title>Unity - Package - HybridCLR</title><link>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</link><pubDate>Tue, 11 Apr 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-package-hybridclr/</guid><description>先備知識 Assembly Definition (Asmdef) Unity 2017.3 以上版本的提供功能，主要解決龐大的程序集編譯時效率問題。
具體內容建議閱讀 Doc - Assembly definitions
Assembly-CSharp.dll Unity 預設整合的 dll，專案內未被自定義 Asmdef 劃分的腳本都會被整合到 Assembly-CSharp.dll
簡述 HybridCLR focus-creative-games/hybridclr focus-creative-games/hybridclr_trial HybridCLR 筆者已經應用於工作環境好一陣子了(從 2.X 版本開始)，其最讓人驚豔的地方在於，過往的開發流幾乎不用更動(當然要好 Asmdef 的規劃)，僅在打包時調整一下工作流即可。
其極大簡化過往麻煩且效率不彰的熱更流程。xLua 和 ILRuntime 在筆者看來最難受的事是「侵入性」極強，搞得綁手綁腳。大家也都抱怨很久了，但也沒有其他可靠方案，直到 HybridCLR 出現。
快速上手 3.0 版本後流程優化得更順暢了，照著 文件 可以很快地感受到其威力。
注意 请问，Generate All、补充元数据的DLL更新的执行时机的最佳实践？ 怎么卸载热更dll CLI 規範中只能以 AppDomain 形式卸載所有 dll，不支持卸載單獨的 dll。而 il2cpp 是單例 AppDomain，因此這個要求是不符合規範的。要採用 HybridCLR DHE 的商業方案。不過筆者倒是不太擔心，畢竟 Unity client 通常不是需要常駐的應用，使用者也不太會把應用的每一個功能都點一遍，初估是還可以接受的。</description></item><item><title>Unity - Basic - DontDestroyOnLoad</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</link><pubDate>Mon, 20 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-dontdestroyonload/</guid><description>用例 被標記為 DontDestroyOnLoad 的物件場景更改時不會被破壞。
全域管理器：因為整個遊戲期間一直存在。例如，音效管理器、遊戲設定管理器或玩家數據管理器等物件可以在場景切換時保留，以確保它們的功能和數據在各個場景中持續存在。 持久性數據：如果你有需要在多個場景中共享的持久性數據，可以將存儲這些數據的物件標記為 DontDestroyOnLoad。例如，玩家的遊戲進度或全域的配置設置等數據可以在場景切換時保留，以便在不同場景中訪問和更新。 UI 元素：某些UI元素，如遊戲狀態面板、計時器或得分顯示，可能需要在多個場景中保留。通過將這些UI元素物件標記為 DontDestroyOnLoad，可以確保它們在場景切換時不會被銷毀，以便在不同場景中持續顯示和更新。 問題 記憶體管理問題：使用 DontDestroyOnLoad 將遊戲物件保留在多個場景中可能會導致記憶體洩漏。如果你的遊戲物件不再需要，但沒有被正確銷毀，它們將繼續存在於記憶體中，佔用系統資源，可能導致性能下降。 場景管理問題：DontDestroyOnLoad 會打破場景之間的清晰界限。場景是 Unity 中組織和管理遊戲邏輯的基本單位，每個場景都應該是相對獨立的。通過在多個場景之間保持物件，會增加場景之間的耦合性，導致代碼難以維護和測試。 Ref Object.DontDestroyOnLoad</description></item><item><title>AI - Stable Diffusion</title><link>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion/</link><pubDate>Fri, 10 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/ai-stable-diffusion/</guid><description>Env 安裝 Python : 3.10.6 版 (不得超過) cmd where python 檢查安裝位置 Window 10 以上用戶須把 WindowsApps 商店的 python 關閉 設定 &amp;gt; 應用程式與功能 &amp;gt; 應用程式執行別名 &amp;gt; 將 python 相關的關閉 安裝 CUDA : cmd nvidia-smi 查看顯卡支援的最高 CUDA 版本 安裝 xformers : 安裝 ComfyUI : github repo Guide Stable Diffusion ComfyUI 入门介绍 Checkpoint Pony Diffusion 什么是Pony？介绍C站当下最流行的底模Pony V6。又名小马模型。 Pony Diffusion V6 出图技巧 autismmix RealCartoon-Anime 社群 Civitai 畫廊 Prompt Search chichi-pui PixAI.Art 頻道 杰克艾米立 AIツール関係 AI FREAK Prompt AI繪圖魔導書 NovelAI魔咒小课堂 NovelAI tag生成器 V2.</description></item><item><title>Visual Design - Note</title><link>https://HoshikawaRyuukou.github.io/posts/visual-design-note/</link><pubDate>Thu, 02 Mar 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/visual-design-note/</guid><description>Color 如何找出好配色？照著這個步驟做，讓你的設計更具吸引力！！ 什么是更好的渐变？ Color Tools Stocksy Adobe Color Canva VIVID GRADIENT GENERATOR TOOL</description></item><item><title>Drawing - Note</title><link>https://HoshikawaRyuukou.github.io/posts/drawing-note/</link><pubDate>Wed, 01 Mar 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/drawing-note/</guid><description>新手村 给画画爱好者的入门经验分享，当初有人告诉我该多好！ Community Pinterest Channel taco1704 hide channel【顔と体の描き方講座】 Practice Line of Action Book ミニキャラの描き方　「ちまっとかわいい」を描く基本＆表現テクニック</description></item><item><title>Unity - WorkFlow - Build &amp; Publish</title><link>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</link><pubDate>Mon, 27 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-workflow-build-publish/</guid><description>Build repositories.cfg could not be loaded. Unable to find player assembly: XXXX\Temp\StagingArea\Data\Managed\UnityEngine.TestRunner.dll Device Quickly preview your game on Android device | Unity tutorial Publish Privacy policy for your game? No problem! (generate and publish) Publish your UNITY game on Google Play Store - 2023 guide Misc Library not loaded: @rpath/FBAEMKit.framework/FBAEMKit</description></item><item><title>Hugo - Note</title><link>https://HoshikawaRyuukou.github.io/posts/hugo-note/</link><pubDate>Sat, 25 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/hugo-note/</guid><description>Install Hugo 從零開始 環境安裝(Windows) Themes Hugo Themes Image Rendering Images in Markdown Preview of Hugo Site 以管理員權限開啟 cmd mklink /D images .\static\images</description></item><item><title>Architecture - Modularization</title><link>https://HoshikawaRyuukou.github.io/posts/architecture-modularization/</link><pubDate>Wed, 22 Feb 2023 21:21:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/architecture-modularization/</guid><description>前述 首先幾篇文章是基於 Clean Architecture 的基礎，建議先閱讀以下連結已具備基礎知識
The missing chapter CA 原著 Chapter 34 - The missing chapter - Actual implementation details of an architecture 連結 34章摘要心得，請先觀看裡面的圖表(重要) CA Modularization Multiple ways of defining Clean Architecture layers Package by Component with Clean Modules in Java Package by feature or component Vertical Slice Slices vs. Layers Restructuring to a Vertical Slice Architecture Vertical Slice Architecture, not Layers! Modular Monolith Majestic Modular Monoliths (強烈建議) Modular Monolith architecture (強烈建議讀完這個系列) 各 Package 策略的圖請參考上方連結 34 章摘要心得</description></item><item><title>Unity - Basic - Sprite and Atlas</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basic-sprite/</guid><description>Sprite 【2Dゲームで必須】UnityのSprite（スプライト）の単位をわかりやすく解説 【間違えやすい】Unityの正しい画像サイズとは Atlas 【Unity】SpriteをパックするSpriteAtlasの使い方 目的 減少DrawCall 圖集將圖片打包為2的冪次方的素材大小，可以提升性能 減小包體大小 注意 Sprite Atlas V1 - Always Enabled 啟用圖集時 Edit Mode : reference the packed Textures Play Mode : reference the original unpacked Textures SpriteAtlas AssetBundle 來打包時，不要勾選 Include In Build</description></item><item><title>Unity - Basics</title><link>https://HoshikawaRyuukou.github.io/posts/unity-basics/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-basics/</guid><description>Set Up 【游戏开发环境】Unity使用Mac电脑开发，开发环境的搭建（Mac mini M1 | VSCode | Git | 好用工具） Analysis Unity Optimize Your Game Using Profiler Unity 手機遊戲最佳化雜談– 內建Profiling Animation Introduction to 3D Animation Systems Audio Unity Audio Clip Import Settings For The Best Performance Audio tutorial for Unity: the Audio Mixer The right way to make a volume slider in Unity Build repositories.cfg could not be loaded. unity Camera Understanding Orthographic Size 探寻 Unity Camera 属性之 Clear Flags Unityの画面のアスペクト比と解像度を自動変換　全スマホ・複数解像度に対応させる Canvas Designing UI for Multiple Resolutions Unity Canvas Scaler 组件的使用 Unity分辨率适配方案设置 Editor 在unity编辑器不同位置添加菜单 SerializeReferenceをつけている型をリネーム・削除する時の注意点 What are EditorBuildSettings config objects used for or how can I use them?</description></item><item><title>Unity - Sites</title><link>https://HoshikawaRyuukou.github.io/posts/unity-sites/</link><pubDate>Mon, 20 Feb 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/unity-sites/</guid><description>Blog Yucchiy&amp;rsquo;s Note コガネブログ LIGHT11 PG日誌 渋谷ほととぎす通信 きゅぶろぐ Raspberlyのブログ やらなイカ？ Game Dev Beginner - Everyone Can Make Games LianBai (:3[kanのメモ帳] Unityゲーム開発者ギルド L&amp;rsquo;s Blog 老刘@开发笔记 はなちるのマイノート くものす Mirrativ Tech Blog Lightjiao的博客 ピクセルブログ unityでいってみよう！ ねこじゃらシティ YAMADA TAISHI’s diary Blog (Enterprise) CyberAgent Developers Blog | サイバーエージェント デベロッパーズブログ REALITY｜note Channel Code Monkey M Studio Coco Code 游戏石匠Super Collection XINCGer/Unity3DTraining Forum Qiita|Unity Zenn|Unity Unity Learning Materials Unity3d - 幻想社区 「unity」の人気の記事一覧｜note Events Unity Meetup Unity Advent Calendar Unityユースクリエイターカップ Community unityroom</description></item><item><title>Architecture - Clean Architecture</title><link>https://HoshikawaRyuukou.github.io/posts/architecture-clean-architecture/</link><pubDate>Sat, 04 Feb 2023 20:03:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/architecture-clean-architecture/</guid><description>以下 Clean Architecture 簡稱 CA
這裡還是先引用 Uncle Bob 的分層圖 The Clean Code Blog - The Clean Architecture 筆者認爲可擴展性是系統架構的重要考量。畢竟應用程式會演化，必須不斷更新與修改系統以滿足新的需求，而 CA 是其中一種實現方針。筆者在這裡不會寫出詳細的介紹，想了解的可以參考 Ref 整理的連結或是 CA 相關書籍。
本文著重於促使筆者思考方式改變的幾個重要觀念。
依賴關係 相依性: 向內圈依賴，且盡量避免跨層依賴 (有些例外之後說明)。 Dependency Inversion Principle (DIP): 內圈定義介面，外圈實作。 基於這兩個規則所帶來的是
單向依賴流 : 紊亂的依賴流可能造成牽一髮動全身的窘境。尤其是當 Domain 去依賴到細節時。 延後實作 : UseCase/Adapter 都是依賴於應用層所開出的介面。因此業務/畫面能獨立開發，不用互相等待(理想狀態)。 而筆者在實作時的基本型架構通常如下圖(比較接近 CA 書中的另外一張圖，我這裡做了簡化)，Adapter 只分成 Input/Output Port。 Domain: 領域邏輯 UseCase: 應用邏輯 Domain + UseCase: 業務邏輯 InputPort: 用例功能使用方介面 OutputPort: 用例功能支援方介面 Adapter: 將外部與用例功能接合的膠水代碼 不過架構會針對不同情況做調整，細節參考另一篇文章
架構設計 - Clean Architecture and Modularization</description></item><item><title>Git - Note</title><link>https://HoshikawaRyuukou.github.io/posts/git-note/</link><pubDate>Sat, 04 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/git-note/</guid><description>GUI Clients Fork Common 两小时Git教程 Git忽略规则.gitignore不生效 配置 Git 处理行结束符 Workflow 如何做好分支管理，保证高效CI/CD？ 【GeekHour教程】分支管理和工作流模型 Git 進階應用 Submodule 與 Subtree，使用它們來拆分專案 Operation git revert 是如何让你丢失代码的？ 十分钟学会常用git撤销操作，全面掌握git的时光机</description></item><item><title>Github - Note</title><link>https://HoshikawaRyuukou.github.io/posts/github-note/</link><pubDate>Sat, 04 Feb 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/github-note/</guid><description>Profile 如何建立獨一無二的 GitHub Profile！與三個很酷的設計及應用 tandpfun/skill-icons Workflow 十分钟学会正确的github工作流，和开源作者们使用同一套流程</description></item><item><title>Pattern - Guard Clauses</title><link>https://HoshikawaRyuukou.github.io/posts/pattern-guard-clauses/</link><pubDate>Tue, 10 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/pattern-guard-clauses/</guid><description>目的 符合 Fail Fast 的原則，驗證條件並在不滿足條件時立即停止執行。 增加可讀性(更扁平)，減少了巢狀判斷。 例子請參考 Guard Clause Extra - Guard Class 將通用的保護子句封裝在一個專門的類是一種很好的做法，可重用邏輯並編寫更具可讀性的保護子句。
可參考這個庫 GuardClauses Extra - Value Object Stop using trivial Guard Clauses! Try this instead
文章作者避免瑣碎 Guard 的方式，是使用 Value Object，來避免域接受到無效參數。這個作法在筆者看來才是真正意義上的 Fail Fast。(YT評論區也建議閱讀，有許多不錯的討論)
但不可否認的 Guard Clause 作法在大多情況下是有益的。
Ref Guard Clause Implementation Patterns: Guard Clause GuardClauses Stop using trivial Guard Clauses! Try this instead</description></item><item><title>CSharp - Note</title><link>https://HoshikawaRyuukou.github.io/posts/csharp-note/</link><pubDate>Thu, 05 Jan 2023 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/csharp-note/</guid><description>語法 C# 的一些冷知识（其一） C# 的一些冷知识（其二） 捨棄 - C# 基本概念 C#中 ??、 ?、 ?: 、?.、? 问号 Type C# 4.0：Covariance 與 Contravariance 觀念入門 Data Different ways to return data in C# ValueTuple ValueTuple 是 value type，所以它使用的記憶體空間使用在 program stack，因此使用不會有 garbage collection
Format 內插字串 Collection C# 回傳內部資料集合的幾種方式，考慮封裝與設計需求 Iterate over two collections of equal length foreach (var (cell, id) in cells.Zip(randomizedIDs, (key, value) =&amp;gt; (Cell: key, ID: value))) { idDict[cell] = id; cell.selectCallback = Select; } Utils Random var random_list = list.</description></item><item><title>Network - Note</title><link>https://HoshikawaRyuukou.github.io/posts/network-note/</link><pubDate>Wed, 04 Jan 2023 13:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/network-note/</guid><description> 【白话科普】域名？网址？原来域名是这么个玩意啊！ DNS工作原理 | 什么是DNS 它如何工作 CDN是什么 | CDN的工作机制 数字签名和CA数字证书的核心原理和作用 VPN概念，技术原理和误区 哈希究竟代表什么？哈希表和哈希函数的核心原理</description></item><item><title>Software Design - Note</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-note/</link><pubDate>Mon, 02 Jan 2023 21:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-note/</guid><description>Blogs Khalil Stemmler | Become a confident crafter. Learn to write testable, scalable TypeScript. Entropy Wins - A blog on Software Architecture, Design and Craftsmanship jyt0532&amp;rsquo;s Blog Tomas Tulka&amp;rsquo;s Blog CodeOpinion Advice for junior developers Guide DevIQ Others The Last Responsible Moment DRY is about Knowledge</description></item><item><title>Software Design - Domain-Driven Design 初探</title><link>https://HoshikawaRyuukou.github.io/posts/software-design-domain-driven-design-%E5%88%9D%E6%8E%A2/</link><pubDate>Thu, 15 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/software-design-domain-driven-design-%E5%88%9D%E6%8E%A2/</guid><description>必須先聲明筆者仍在學習中，以下屬個人觀點
動機 筆者發現在使用 Clean Architecture (CA) 時越來越力不從心，因此開始研究 Domain-Driven Design (DDD)，事出有因，列出幾點問題與對應方式。
重複的程式碼 主因是 貧血域模型 (Anemic Domain Model)，表示模型中幾乎只有 Get/Set，這導致了 Domain層 (業務邏輯) 滲透到 Application層 (應用邏輯)，某些對 Domain 的操作重複出現在多個的 Usecase (應用邏輯)。 重新分析系統，區分出不同上下文，設計充血域模型，將業務邏輯設計進去。 域模型的一致性問題 Domain 面對四面八方的操作，顯得很亂且充滿不確定(會不會模型之間的關係因為更改而被破壞) 引入聚合(Aggregate)來維持保護邊界內的不變條件。 Primitive Obsession 這會造成對模型的不信任，進而寫出一些防禦性程式設計。 引入值物件(Value Object)來確保不變性與自我驗證(即不正確就不應該存在)。 以上這幾點是筆者比較有感的。
概述與想法 Domain-Driven Design (DDD)，出自 Eric Evans 2003 年出版的一本書，以領域模型為中心來進行系統的分析設計。不是架構也不是技術，是一種方法論，可以搭配不同類型的架構來實現
Layered Architecture Hexagonal Architecture Clean Architecture (以下稱 CA ) Command Query Responsibility Segregation (CQRS) 原著中是使用 Layered Architecture 的架構作為示範，但該章的重點是在隔離 Domain，在 Google 的時候有所謂 &amp;ldquo;DDD 架構圖&amp;rdquo;，但筆者覺得不太精確，因為 DDD 主要的發力點是在 Domain，應該稱作 &amp;ldquo;OO架構以DDD實作Domain&amp;rdquo; 會比較合適。</description></item><item><title>Pattern - Data Transfer Object (DTO)</title><link>https://HoshikawaRyuukou.github.io/posts/pattern-data-transfer-object-dto/</link><pubDate>Sun, 11 Dec 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/pattern-data-transfer-object-dto/</guid><description>什麼是 DTO？ Data Transfer Object (數據傳輸對象) 是定義如何在應用程序之間發送數據的對象。它僅用於發送和接收數據，本身不包含任何業務邏輯。
為什麼使用 DTO？ 輕鬆收發 在沒有任何邏輯的基礎上，可以僅使用序列化與反序列化就保證對象的完整性和可傳遞性。
避免過度暴露訊息 對分層或模組來說，彼此間應盡量降低耦合。下圖以公園廁所報修為案例。
這個資料流由鄉公所傳到基層人員手上，中間經過兩個邊界
鄉公所 | 工程公司 =&amp;gt; DTO (公文) 工程公司 | 基層人員 =&amp;gt; DTO (簡訊) 每個單位的關注點不同，在意的資料也會不同，DTO 做為邊界兩方做最小程度的媒介，隱藏的不該被關注(敏感)的事
印章對工程公司並不是必要資訊 詳細的時間格式是對基層人員並不是必要資訊 在實作上常被用於轉換 DomainModol -&amp;gt; DomainDto
注意事項 類別數量增加，請自行評估使用情形
Ref Cutting Edge - Pros and Cons of Data Transfer Objects The DTO (Data Transfer Object) Data Transfer Objects Clean Architecture : why not using the entity as request model of the use case (interactor) Difference between Entity and DTO</description></item><item><title>Pattern - Model View Presenter (MVP)</title><link>https://HoshikawaRyuukou.github.io/posts/pattern-model-view-presenter-mvp/</link><pubDate>Sat, 10 Dec 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/pattern-model-view-presenter-mvp/</guid><description>前述 關注點分離（Separation of Concerns，SoC）: 在軟體開發中，一個模組或組件應該專注於解決特定的問題，而不是同時處理多個功能。每個組件都有自己的職責範圍，並且與其他組件盡可能解耦合。
而 MVC / MVP / MVVM 是關注點分離於前端的經典應用，網上已經有很多不錯的文章，再寫一份類似的整理文章意義也不大，對此感到陌生，不妨閱讀以下連結，會幫助你理解 MV系列的發展。
界面之下：还原真实的MV*模式 正确认识 MVC/MVP/MVVM 站在思想层面看MVX架构 MVP Pattern: Part 2 Supervising Controller Part 2 — Converting Presenters into ViewModels 【Unity】MV(R)Pパターンのすすめ 以下則對筆者實作中比較常用的 MVP 多做一些討論
關注點(責任) 在 MVP 的構成下分成三個部分
Model: 應用程式的核心邏輯。 View: 應用程式的使用者介面，負責呈現數據和接收使用者的輸入。 Presenter: View 和 Model 之間的中介。 Passive View 這是 MVP 的一種實作風格，也是筆者主要使用的風格。
Presenter 對 View 有完全控制權 View 提供方法與事件給 Presenter 使用 View 對 Presenter 一無所知 以猜拳遊戲的 View 為例
public class View : MonoBehaviour { [SerializeField] private Text messageText; [SerializeField] private Button[] playerChoices; [SerializeField] private Button nextButton; private readonly Subject&amp;lt;Choice&amp;gt; playerChoiceSelected = new Subject&amp;lt;Choice&amp;gt;(); private readonly CompositeDisposable disposables = new CompositeDisposable(); public IObservable&amp;lt;Choice&amp;gt; PlayerChoiceSelected =&amp;gt; playerChoiceSelected; public IObservable&amp;lt;Unit&amp;gt; PlayerNextRequested =&amp;gt; nextButton.</description></item><item><title>Assets - Note</title><link>https://HoshikawaRyuukou.github.io/posts/assets-note/</link><pubDate>Tue, 22 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/assets-note/</guid><description>Audio 魔王魂 効果音ラボ フリーBGM（音楽素材）無料ダウンロード｜DOVA-SYNDROME フリー効果音素材・無料効果音 Color Coolors Palettable Feature Graphics Google Play Feature Graphics Font 中文免費字體 Google Fonts 2022/0113更新# 36個合法免費高品質字體 fontget Icon ICOOON MONO iconmonstr Flaticon IconKitchen Game-icons.net Image Unsplash Image API | Free HD Photo API Lorem Picsum Photosku 2023 熱門 47 個可商用無版權免費圖庫懶人包（圖片、圖示、圖標、素材、背景） OKUMONO Misc Opengameart Kenney かわいいフリー素材集 いらすとや Textures Poly Haven Tools 網路資源列表| DeTools Repo itch.io</description></item><item><title>Architecture - Navigation</title><link>https://HoshikawaRyuukou.github.io/posts/architecture-navigation/</link><pubDate>Wed, 16 Nov 2022 21:11:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/architecture-navigation/</guid><description>以下 Feature 指的是一個功能獨立的模組，Feature A 將簡稱 A。
問題 應用程式中有一個由 A 到 B 的導航，那這個導航是誰的責任?
以下先討論 2 種狀況。
A 直接依賴 B 簡單粗暴的強耦合破壞了 A 的獨立性。當流程發生變化時，可能需要到各個 Feature 去修改。
Feature A -&amp;gt; Feature B A 引入導航器間接依賴 B 這作法將導航操作收斂到某個類中，但 A 仍然隱含的知道 B，這同樣破壞了 A 的獨立性。
Feature A -&amp;gt; INavigator.Route(View.FeatureB) // Enum or Feature A -&amp;gt; INavigator.Route(&amp;#34;FeatureB&amp;#34;) // 魔術字串 or Feature A -&amp;gt; INavigator.RouteFeatureB() 重新思考導航這件事
Feature 應該知道自己是能夠 被導航 或是 能導航到哪 嗎? 到底 A 能導航到 B 這件事是誰決定的? 應該隱約地感覺到了吧，導航並不屬於 A 也不屬於 B，導航是一個獨立操作，需要一個額外的單位來負責。此外這個單位多是屬於 App 級別的(因為該層級有對其他模組的正當訪問性，畢竟是負責做統合的)。</description></item><item><title>Principle - Dependency Inversion Principle (DIP)</title><link>https://HoshikawaRyuukou.github.io/posts/principle-dependency-inversion-principle-dip/</link><pubDate>Tue, 15 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/principle-dependency-inversion-principle-dip/</guid><description>依賴倒置原則 Dependency Inversion Principle，以下皆簡稱 DIP。
為什麼需要 先來看定義
高層次的模塊不應該依賴於低層次的模塊，兩者都應該依賴於抽象接口 抽象接口不應該依賴於具體實現。而具體實現則應該依賴於抽象接口 文謅謅的，但重點似乎是抽象。不如直接看個狀況劇:
有一個 Project A 需要使用播廣告的功能。分別採 2 個做法
直接依賴 直覺的做法。Project A 直接依賴於廣告模組(UnityAds)，這裡模組 Project A 被迫去了解 UnityAds 的實作細節(怎麼初始化/下載廣告/播廣告)。
目前沒甚麼問題，運作得很好&amp;hellip; 但很快問題就來了。UnityAds 因為某些原因不能用了! (假設後臺被打了什麼的)。於是找了另一個廣告模組(AdMob)，想要如法炮製，但有幾點可能會不好受。
要改的地方很分散 (廣告被 Project A 多處使用) Project A 需要處理不同的 API格式 (了解細節，單例、Callback、事件&amp;hellip;) 導致原先依賴 UnityAds 的模組需要重新編譯 (造成浪費時間) 原因是直接依賴外部模組導致的，相對於你的系統 UnityAds 是個外人，是不穩定的，去依賴一個不穩定的東西，也會導致自己變得不穩定。
依賴倒置 仔細想一下，Project A 直接依賴 UnityAds 是必要的嗎? 需求是播 UnityAds 的廣告? 還是播廣告? 為了實現穩定廣告服務的依賴源，我們將其抽象化
public interface IAdService { void Initialize(); void Load(); void Show(); } 但 UnityAds 與 AdMob 又不能直接實作這個介面怎麼辦，可以用配接器模式(Adapter Pattern)寫個轉接頭，想辦法讓外部細節符合 IAdService 的需求。現在需要廣告服務的部分均透過 IAdService來操作，不需再知道外部廣告模組的細節。</description></item><item><title>Network - RPC</title><link>https://HoshikawaRyuukou.github.io/posts/network-rpc/</link><pubDate>Mon, 07 Nov 2022 21:06:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/network-rpc/</guid><description>RPC (Remote Procedure Call，遠端程序呼叫) 是一種通信協定，多用於分佈式系統的通信。
目的 讓客戶端呼叫遠程函式就像呼叫本地函式一樣。將網路通信封裝成函式來使用，那麼客戶端將不需要關心網路協定/模型。
流程 client 客戶端通過本地呼叫的方式呼叫服務 client stub 接收到請求後將參數序列化成能夠進行網路傳輸的訊息體 client stub 找到服務地址，並將訊息發送給服務端 server stub 收到訊息後進行反序列化 server stub 根據反序列化結果呼叫本地服務 本地服務執行並將處理結果返回給 server stub server stub 將結果序列化並發送至 client stub client stub 接收到訊息，並進行反序列化 client 得到最終結果 Ref 怎么理解rpc，既然有http请求了为啥还要用rpc？ 谁能用通俗的语言解释一下什么是 RPC 框架？</description></item><item><title>Philosophy - 忒修斯之船 (Ship of Theseus)</title><link>https://HoshikawaRyuukou.github.io/posts/philosophy-%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9-ship-of-theseus/</link><pubDate>Sun, 06 Nov 2022 21:20:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/philosophy-%E5%BF%92%E4%BF%AE%E6%96%AF%E4%B9%8B%E8%88%B9-ship-of-theseus/</guid><description>問題 1世紀時的希臘作家普魯塔克問到
如果忒修斯的船上的木頭逐漸被替換，直到所有的木頭都不是原來的木頭，那這艘船還是原來的那艘船嗎？
思考 這艘船在被賦予存在意義之前，就不過是一堆木頭與金屬，如果沒有使用他的人，那麼船將沒有他的意義。因此只要賦予它存在意義的人還在，或者說這份存在意義能夠被繼承下去，無論它變成什麼樣子，它還是那艘船。</description></item><item><title>Hugo - Hello Blog</title><link>https://HoshikawaRyuukou.github.io/posts/hugo-hello-blog/</link><pubDate>Sat, 05 Nov 2022 20:05:00 +0000</pubDate><guid>https://HoshikawaRyuukou.github.io/posts/hugo-hello-blog/</guid><description>Blog 起初筆者覺得使用 Github Repository + Markdown 當作筆記就足矣。但隨著筆記越多越雜，只使用文件夾結構 + 目錄超連結，在查找上越覺得不便，還是需要有一套系統來代勞。Blog/筆記 平台玲瑯滿目，但寄身於平台的風險難以忽視(倒站/政策改變)，網站搬家也讓人很頭疼。之前就知道靜態網站能架在 Github 上，只是一直沒研究，剛好趁這個機會練習一下 Web 前端的技能。最後的方案是 Github Pages + Hugo。
Hugo 網上的教學也很多，筆者先是快速瀏覽一下幾篇文章再動工，這裡就不手把手介紹，這主要記錄一些筆者遇到的坑。
Hugo 貼身打造個人部落格系列 網站開張！在 GitHub Pages 架設 Hugo 靜態網站 開始 官方的文件 Official Doc 已經足夠清楚了，照著 Quick Start 跑完就有一個完整的畫面(以靜態網站來說)，但這裡有幾個注意的點。
使用 Binary (Cross-platform) 配置 Hugo 時，有 hugo / hugo_extended 版本，且要手動配置環境變數。extended 支援 Sass/SCSS，這裡沒注意到花了不少時間，想說改個主題佈局怎麼編譯不過，Hugo Discourse Support。 設置 .gitignore 主題 主題有很多選擇 Official Link / Github Tag - hugo-theme，有的已經打磨得很完善。筆者對這個 Blog 希望以簡潔明快為主，紀錄是第一要務。最終採用這個 Theme - Cactus (變心可換問題不大)，之後肯定會進行一些魔改的，不然自架的意義就小很多了。
選擇上幾點注意
避開一些太舊的主題 (跟 Hugo 衝突 / js腳本過舊&amp;hellip;) 第三方 API 遇到大改動時要排除一下才能建置 ( FB / IG 讓好多主題要改&amp;hellip;) 修改上幾點注意</description></item></channel></rss>